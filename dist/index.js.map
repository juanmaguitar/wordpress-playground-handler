{
  "version": 3,
  "sources": ["../src/playground.ts", "../src/utils.ts", "../src/playgroundHandler.ts", "../src/lib.ts"],
  "sourcesContent": ["import { createNodeFsMountHandler, loadNodeRuntime } from \"@php-wasm/node\";\nimport {\n  bootWordPress,\n  resolveWordPressRelease\n} from \"@wp-playground/wordpress\";\nimport { PHPRequestHandler } from \"@php-wasm/universal\";\nimport { rootCertificates } from \"tls\";\n\nimport { compileBlueprint, runBlueprintSteps } from \"@wp-playground/blueprints\";\nimport {fetchFileAsFileObject} from \"./utils.js\";\nimport { Blueprint } from \"@wp-playground/blueprints\";\n\ninterface MountPaths {\n  databasePath?: string;\n  muPluginsPath?: string;\n}\n\n// Move all logic into a function and export it\nexport async function createPlaygroundRequestHandler(blueprint: Blueprint, mountPaths?: MountPaths): Promise<PHPRequestHandler> {\n  \n\n  const wpDetails = await resolveWordPressRelease(\"6.8\");\n  const wordPressZip = await fetchFileAsFileObject(\n    wpDetails.releaseUrl,\n    `${wpDetails.version}.zip`\n  );\n  \n  const sqliteIntegrationPluginZip = await fetchFileAsFileObject(\n    \"https://github.com/WordPress/sqlite-database-integration/archive/refs/heads/develop.zip\",\n    \"sqlite.zip\"\n  );\n  \n  const requestHandler = await bootWordPress({\n    siteUrl: \"http://localhost:8080\",\n    createPhpRuntime: async () =>\n      await loadNodeRuntime(\"8.3\"),\n    wordPressZip,\n    sqliteIntegrationPluginZip,\n    sapiName: \"cli\",\n    createFiles: {\n      \"/internal/shared/ca-bundle.crt\": rootCertificates.join(\"\\n\"),\n    },\n    phpIniEntries: {\n      \"openssl.cafile\": \"/internal/shared/ca-bundle.crt\",\n      allow_url_fopen: \"1\",\n      disable_functions: \"\",\n    },\n    cookieStore: false,\n  });\n\n  const php = await requestHandler.getPrimaryPhp();\n  \n  if (mountPaths?.databasePath) {\n    php.mkdir(\"/wordpress/wp-content/database/\");   \n    php.mount(\n      \"/wordpress/wp-content/database/\",\n      createNodeFsMountHandler(mountPaths.databasePath)\n    );\n  }\n\n  if (mountPaths?.muPluginsPath) {\n    php.mkdir(\"/wordpress/wp-content/mu-plugins/\");\n    php.mount(\n      \"/wordpress/wp-content/mu-plugins/\",\n      createNodeFsMountHandler(mountPaths.muPluginsPath)\n    );\n  }\n  \n  const compiledBlueprint = await compileBlueprint(blueprint);  \n  await runBlueprintSteps(compiledBlueprint, php);\n\n  return requestHandler;\n}", "import { PHPRequest, PHPRequestHandler, PHPResponse } from \"@php-wasm/universal\";\n\n// Sends a PHP request using the provided handler and follows HTTP 301/302 redirects recursively until a non-redirect response is received.\nexport const requestFollowRedirects = async (\n  handler: PHPRequestHandler,\n  request: PHPRequest\n): Promise<PHPResponse> => {\n  let response = await handler.request(request);\n  while (\n    [301, 302].includes(response.httpStatusCode) &&\n    response.headers[\"location\"] &&\n    response.headers[\"location\"].length === 1\n  ) {\n    response = await requestFollowRedirects(handler, {\n      url: response.headers[\"location\"][0],\n    });\n  }\n  return response;\n};\n\n// Fetches a file from the given URL and returns it as a File object with the specified file name. Throws an error if the fetch fails.\nexport async function fetchFileAsFileObject(\n  url: string,\n  fileName: string\n): Promise<File> {\n  const response = await fetch(url);\n  if (!response.ok)\n    throw new Error(`Failed to fetch ${url}: ${response.statusText}`);\n  const blob = await response.blob();\n  return new File([blob], fileName);\n}\n", "import { PHPRequestHandler } from \"@php-wasm/universal\";\nimport { Blueprint } from \"@wp-playground/blueprints\";\nimport { createPlaygroundRequestHandler } from \"./playground.js\";\nimport { MountPaths } from \"./lib.js\";\n\nconst HANDLER_PROMISE_SYMBOL = Symbol.for('HANDLER_PROMISE');\n\ninterface PlaygroundGlobal {\n  [key: symbol]: Promise<PHPRequestHandler> | undefined;\n}\n\nexport function getSingletonHandlerPromise(blueprint: Blueprint, mountPaths?: MountPaths): Promise<PHPRequestHandler> {\n  const globalObj = global as unknown as PlaygroundGlobal;\n  \n  if (!globalObj[HANDLER_PROMISE_SYMBOL]) {\n    globalObj[HANDLER_PROMISE_SYMBOL] = createHandler(blueprint, mountPaths);\n  }\n  return globalObj[HANDLER_PROMISE_SYMBOL]!;\n}\n\nasync function createHandler(blueprint: Blueprint, mountPaths?: MountPaths): Promise<PHPRequestHandler> {\n  console.log(\"Creating singleton Playground handler...\");\n  const handler = await createPlaygroundRequestHandler(blueprint, mountPaths);\n  console.log(\"Singleton Playground handler created successfully\");\n  return handler;\n}", "import { PHPRequestHandler } from \"@php-wasm/universal\";\nimport { Blueprint } from \"@wp-playground/blueprints\";\nimport { getSingletonHandlerPromise } from \"./playgroundHandler.js\";\nimport { readFileSync } from \"fs\";\nimport { resolve } from \"path\";\n\nexport interface MountPaths {\n  databasePath?: string;\n  muPluginsPath?: string;\n}\n\nexport interface PlaygroundOptions {\n  blueprintPath?: string;\n  blueprint?: Blueprint;\n  mountPaths?: MountPaths;\n}\n\nlet cachedHandler: Promise<PHPRequestHandler> | null = null;\n\nexport async function getPlaygroundHandler(options: PlaygroundOptions = {}): Promise<PHPRequestHandler> {\n  if (!cachedHandler) {\n    let blueprint: Blueprint;\n    \n    if (options.blueprint) {\n      blueprint = options.blueprint;\n    } else if (options.blueprintPath) {\n      blueprint = JSON.parse(\n        readFileSync(resolve(options.blueprintPath), \"utf8\")\n      ) as Blueprint;\n    } else {\n      blueprint = JSON.parse(\n        readFileSync(resolve(\"./wordpress/blueprint.json\"), \"utf8\")\n      ) as Blueprint;\n    }\n    \n    cachedHandler = getSingletonHandlerPromise(blueprint, options.mountPaths);\n  }\n  \n  return cachedHandler;\n}\n\nexport { PHPRequestHandler, PHPRequest, PHPResponse } from \"@php-wasm/universal\";\nexport { Blueprint } from \"@wp-playground/blueprints\";"],
  "mappings": ";;;;AAAA,SAAS,0BAA0B,uBAAuB;AAC1D;AAAA,EACE;AAAA,EACA;AAAA,OACK;AAEP,SAAS,wBAAwB;AAEjC,SAAS,kBAAkB,yBAAyB;;;ACapD,eAAsB,sBACpB,KACA,UACe;AACf,QAAM,WAAW,MAAM,MAAM,GAAG;AAChC,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,mBAAmB,GAAG,KAAK,SAAS,UAAU,EAAE;AAClE,QAAM,OAAO,MAAM,SAAS,KAAK;AACjC,SAAO,IAAI,KAAK,CAAC,IAAI,GAAG,QAAQ;AAClC;AATsB;;;ADHtB,eAAsB,+BAA+B,WAAsB,YAAqD;AAG9H,QAAM,YAAY,MAAM,wBAAwB,KAAK;AACrD,QAAM,eAAe,MAAM;AAAA,IACzB,UAAU;AAAA,IACV,GAAG,UAAU,OAAO;AAAA,EACtB;AAEA,QAAM,6BAA6B,MAAM;AAAA,IACvC;AAAA,IACA;AAAA,EACF;AAEA,QAAM,iBAAiB,MAAM,cAAc;AAAA,IACzC,SAAS;AAAA,IACT,kBAAkB,mCAChB,MAAM,gBAAgB,KAAK,GADX;AAAA,IAElB;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV,aAAa;AAAA,MACX,kCAAkC,iBAAiB,KAAK,IAAI;AAAA,IAC9D;AAAA,IACA,eAAe;AAAA,MACb,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,IACrB;AAAA,IACA,aAAa;AAAA,EACf,CAAC;AAED,QAAM,MAAM,MAAM,eAAe,cAAc;AAE/C,MAAI,YAAY,cAAc;AAC5B,QAAI,MAAM,iCAAiC;AAC3C,QAAI;AAAA,MACF;AAAA,MACA,yBAAyB,WAAW,YAAY;AAAA,IAClD;AAAA,EACF;AAEA,MAAI,YAAY,eAAe;AAC7B,QAAI,MAAM,mCAAmC;AAC7C,QAAI;AAAA,MACF;AAAA,MACA,yBAAyB,WAAW,aAAa;AAAA,IACnD;AAAA,EACF;AAEA,QAAM,oBAAoB,MAAM,iBAAiB,SAAS;AAC1D,QAAM,kBAAkB,mBAAmB,GAAG;AAE9C,SAAO;AACT;AAtDsB;;;AEbtB,IAAM,yBAAyB,OAAO,IAAI,iBAAiB;AAMpD,SAAS,2BAA2B,WAAsB,YAAqD;AACpH,QAAM,YAAY;AAElB,MAAI,CAAC,UAAU,sBAAsB,GAAG;AACtC,cAAU,sBAAsB,IAAI,cAAc,WAAW,UAAU;AAAA,EACzE;AACA,SAAO,UAAU,sBAAsB;AACzC;AAPgB;AAShB,eAAe,cAAc,WAAsB,YAAqD;AACtG,UAAQ,IAAI,0CAA0C;AACtD,QAAM,UAAU,MAAM,+BAA+B,WAAW,UAAU;AAC1E,UAAQ,IAAI,mDAAmD;AAC/D,SAAO;AACT;AALe;;;ACjBf,SAAS,oBAAoB;AAC7B,SAAS,eAAe;AAqCxB,SAAS,mBAAmB,YAAY,mBAAmB;AAC3D,SAAS,iBAAiB;AAzB1B,IAAI,gBAAmD;AAEvD,eAAsB,qBAAqB,UAA6B,CAAC,GAA+B;AACtG,MAAI,CAAC,eAAe;AAClB,QAAI;AAEJ,QAAI,QAAQ,WAAW;AACrB,kBAAY,QAAQ;AAAA,IACtB,WAAW,QAAQ,eAAe;AAChC,kBAAY,KAAK;AAAA,QACf,aAAa,QAAQ,QAAQ,aAAa,GAAG,MAAM;AAAA,MACrD;AAAA,IACF,OAAO;AACL,kBAAY,KAAK;AAAA,QACf,aAAa,QAAQ,4BAA4B,GAAG,MAAM;AAAA,MAC5D;AAAA,IACF;AAEA,oBAAgB,2BAA2B,WAAW,QAAQ,UAAU;AAAA,EAC1E;AAEA,SAAO;AACT;AApBsB;",
  "names": []
}
