"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main/ts/index.ts
var ts_exports = {};
__export(ts_exports, {
  TStrategy: () => TStrategy,
  extend: () => extend,
  load: () => load,
  loadSync: () => loadSync,
  parse: () => parse,
  populate: () => populate,
  populateSync: () => populateSync,
  prepare: () => prepare,
  resolve: () => resolve,
  vmap: () => vmap
});
module.exports = __toCommonJS(ts_exports);

// src/main/ts/load.ts
var import_node_fs = __toESM(require("node:fs"), 1);
var import_node_module = require("node:module");
var import_node_path = __toESM(require("node:path"), 1);
var import_node_process = __toESM(require("node:process"), 1);
var import_node_url = __toESM(require("node:url"), 1);

// src/main/ts/util.ts
var import_node_util = __toESM(require("node:util"), 1);
var isString = (value) => typeof value === "string";
var isFn = (value) => typeof value === "function";
var isObject = (value) => value !== null && typeof value === "object";
var isCloneable = (value) => isObject(value) && !import_node_util.default.types.isProxy(value) && !isFn(value) && ![RegExp, Date, Promise, Map, Set, WeakMap, WeakSet].some((c) => value instanceof c);
var stripBom = (content) => content.codePointAt(0) === 65279 ? content.slice(1) : content;
var pipe = (value, hook) => isFn(value == null ? void 0 : value.then) ? value.then(hook) : hook(value);
var getSeed = (value) => isCloneable(value) ? Array.isArray(value) ? [] : Object.create(Object.getPrototypeOf(value)) : void 0;
var getProps = (value) => [
  ...(Array.isArray(value) ? Object.keys : Object.getOwnPropertyNames)(value),
  ...Object.getOwnPropertySymbols(value)
];
var match = (input, pattern) => {
  if (pattern === input || pattern === "*")
    return true;
  if (pattern[0] === "^")
    return new RegExp(pattern).test(input);
  if (pattern.includes("*") || pattern.includes("?")) {
    return new RegExp("^" + pattern.replaceAll(".", "\\.").replaceAll("?", ".").replaceAll("**", ".+").replaceAll("*", "[^.]+") + "$").test(input);
  }
  return false;
};
var unsetKeys = (v, keys) => {
  for (const key of keys) {
    v == null ? true : delete v[key];
  }
  return v;
};

// src/main/ts/load.ts
var import_meta = {};
var r = import_meta.url ? (0, import_node_module.createRequire)(import_meta.url) : require;
var _require = (id) => r(normalizeRequirePath(id));
var _import = (id) => import_meta.url ? import(normalizeImportPath(id)) : _require(id);
var cjs = /* @__PURE__ */ new Set([".cjs", ".cts"]);
var anyjs = /* @__PURE__ */ new Set(["", ".js", ".ts", ".mjs", ".mts", ...cjs]);
var parse = ({ contents }) => JSON.parse(contents);
var loadSync = ({ resolved: id }) => !isDotFile(id) && anyjs.has(import_node_path.default.extname(id)) ? _require(id) : stripBom(import_node_fs.default.readFileSync(id, "utf8"));
var load = (_0) => __async(void 0, [_0], function* ({ resolved: id }) {
  const ext = import_node_path.default.extname(id);
  if (cjs.has(ext))
    return _require(id);
  return !isDotFile(id) && anyjs.has(ext) ? unwrapDefault(yield _import(id)) : stripBom(yield import_node_fs.default.promises.readFile(id, "utf8"));
});
var resolve = ({ id, cwd, sync }) => id.startsWith(".") ? import_node_path.default.resolve(cwd, id) : resolveExternalModulePath(id, sync);
var locateResource = ({ cwd, root, id, sync, resolve: resolve2 }) => {
  const base = import_node_path.default.resolve(import_node_process.default.cwd(), cwd != null ? cwd : ".");
  const def = { cwd: base, root: root || base, id, sync };
  if (!isString(id))
    return def;
  const rawPath = resolve2(def);
  const normalizedPath = rawPath.startsWith("file:") ? import_node_url.default.fileURLToPath(rawPath) : rawPath;
  const dir = import_node_path.default.dirname(normalizedPath);
  if (dir === ".")
    return def;
  return {
    id: "./" + import_node_path.default.basename(normalizedPath),
    cwd: dir,
    root: root || dir,
    sync
  };
};
var loadResource = (ctx) => {
  const { config, cwd, cache, extendKeys } = ctx;
  const resource = isString(config) ? import_node_path.default.join(cwd, config) : config;
  if (!cache.has(resource)) {
    const value = processResource(ctx);
    cache.set(resource, value);
    return value;
  }
  return pipe(cache.get(resource), (v) => unsetKeys(v, extendKeys));
};
var processResource = (ctx) => {
  const { load: load2, config, cwd, parse: parse2, prepare: prepare2, resolve: resolve2, vmap: vmap2, sync, root } = ctx;
  const hctx = { id: config, root, cwd, sync };
  return pipe(isString(config) ? pipe(
    pipe(
      resolve2(hctx),
      (resolved) => load2(__spreadValues({ resolved }, hctx))
    ),
    (contents) => isString(contents) ? parse2(__spreadProps(__spreadValues({}, hctx), { contents, ext: import_node_path.default.extname(config) })) : contents
  ) : config, (c) => prepare2(c, __spreadProps(__spreadValues({}, hctx), { vmap: vmap2 })));
};
var normalizeImportPath = (id) => id.startsWith("file:") || !id.includes(":") ? id : import_node_url.default.pathToFileURL(id).href;
var normalizeRequirePath = (id) => id.startsWith("file:") ? import_node_url.default.fileURLToPath(id) : id;
var resolveExternalModulePath = (id, sync) => {
  var _a, _b, _c;
  const resolver = sync ? r.resolve : ((_b = (_a = import_meta.resolveSync) != null ? _a : import_meta.resolve) == null ? void 0 : _b.bind(import_meta)) || r.resolve;
  return id.includes(":") ? id : (_c = resolver(id)) != null ? _c : id;
};
var unwrapDefault = (value) => {
  var _a;
  return (_a = value == null ? void 0 : value.default) != null ? _a : value;
};
var isDotFile = (id) => import_node_path.default.basename(id)[0] === ".";

// src/main/ts/interface.ts
var TStrategy = /* @__PURE__ */ ((TStrategy2) => {
  TStrategy2["OVERRIDE"] = "override";
  TStrategy2["MERGE"] = "merge";
  TStrategy2["POPULATE"] = "populate";
  TStrategy2["IGNORE"] = "ignore";
  TStrategy2["REBASE"] = "rebase";
  return TStrategy2;
})(TStrategy || {});

// src/main/ts/extend.ts
var getRule = (p, rules) => rules[Object.keys(rules).find((k) => match(p, k))] || rules["*"] || "override" /* OVERRIDE */;
var extend = (opts) => {
  const {
    sources = [],
    rules = {},
    prefix = "",
    index = {}
  } = opts;
  const result = index[prefix] = index[prefix] || getSeed(sources[0]);
  const ctx = { result, sources, prefix, rules, index };
  return Array.isArray(result) ? extendArray(ctx) : extendObject(ctx);
};
var extendArray = ({ result, sources, prefix, rules }) => {
  const rule = getRule(prefix, rules);
  if (rule === "ignore" /* IGNORE */)
    return result;
  if (rule === "merge" /* MERGE */) {
    result.push(...sources.flat(1));
  } else {
    result.length = 0;
    result.push(...sources.slice(-1).flat(1));
  }
  return result;
};
var extendObject = ({ result, sources, prefix, rules, index }) => {
  for (const source of sources) {
    for (const key of getProps(source)) {
      const p = `${prefix ? prefix + "." : ""}${key}`;
      const rule = getRule(p, rules);
      const value = source[key];
      if (rule === "ignore" /* IGNORE */)
        continue;
      result[key] = isObject(value) && rule === "merge" /* MERGE */ ? extend({
        sources: [value],
        rules,
        prefix: p,
        index
      }) : value;
    }
  }
  return result;
};

// src/main/ts/populate.ts
var import_node_path2 = __toESM(require("node:path"), 1);

// src/main/ts/prepare.ts
var prepare = (value, { vmap: vmap2, cwd, root, id } = {}) => _clone({ value, cwd, vmap: vmap2, root, id });
var _vmap = ({ value }) => value;
var vmap = _vmap;
var _clone = ({
  value,
  id,
  cwd = process.cwd(),
  root = cwd,
  resource = value,
  memo = /* @__PURE__ */ new Map(),
  seed = getSeed(value),
  vmap: vmap2 = _vmap,
  prefix = ""
}) => seed ? getProps(value).reduce((m, k) => {
  const p = `${prefix}${k.toString()}`;
  const v = vmap2({
    value: value[k],
    key: k,
    prefix: p,
    resource,
    id,
    cwd,
    root
  });
  if (memo.has(v)) {
    m[k] = memo.get(v);
  } else {
    const _seed = getSeed(v);
    if (_seed) {
      memo.set(v, _seed);
      _clone({
        value: v,
        seed: _seed,
        prefix: `${p}.`,
        memo,
        vmap: vmap2,
        resource,
        cwd,
        id,
        root
      });
      m[k] = _seed;
    } else {
      m[k] = v;
    }
  }
  return m;
}, seed) : value;

// src/main/ts/populate.ts
var populate = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (config, opts = {}) {
  const ctx = createCtx(config, opts, load, populate);
  const _config = yield loadResource(ctx);
  const extras = yield Promise.all(populateExtras(_config, ctx));
  return assembleValue(_config, extras, ctx);
});
var populateSync = (config, opts = {}) => {
  const ctx = createCtx(config, opts, loadSync, populateSync, true);
  const _config = loadResource(ctx);
  const extras = populateExtras(_config, ctx);
  return assembleValue(_config, extras, ctx);
};
var createCtx = (config, opts, loader, populate2, sync = false) => {
  const _opts = parseOpts(opts);
  const rules = _opts.rules || {};
  const _extendKeys = Object.keys(rules).filter((k) => rules[k] === "populate" /* POPULATE */);
  const extendKeys = _extendKeys.length > 0 ? _extendKeys : ["extends"];
  const _resolve = _opts.resolve || resolve;
  const { cwd, id: _config, root } = locateResource({
    id: config,
    resolve: _resolve,
    cwd: _opts.cwd,
    root: _opts.root,
    sync
  });
  return __spreadProps(__spreadValues({
    load: loader,
    prepare,
    parse,
    cache: /* @__PURE__ */ new Map(),
    resolve: _resolve
  }, _opts), {
    root,
    merge: buildMerge(_opts.merge, rules),
    vmap: buildVmap(_opts.vmap, rules),
    rules,
    extendKeys,
    populate: populate2,
    cwd,
    config: _config,
    sync
  });
};
var anyStrategy = Object.values(TStrategy);
var parseOpts = (opts = {}) => Object.values(opts).every((v) => anyStrategy.includes(v)) ? { rules: opts } : opts;
var buildMerge = (merge, rules) => isFn(merge) ? merge : (...sources) => extend({
  sources,
  rules
});
var buildVmap = (vmap2, rules = {}) => isFn(vmap2) ? vmap2 : ({ value, cwd, root, prefix }) => cwd !== root && getRule(prefix, rules) === "rebase" /* REBASE */ ? import_node_path2.default.join(import_node_path2.default.relative(root, cwd), value) : value;
var populateExtras = (config, ctx) => [...new Set([ctx.extendKeys.map((k) => config == null ? void 0 : config[k]), ctx.extends].flat(2))].filter(Boolean).map((extra) => ctx.populate(extra, __spreadProps(__spreadValues({}, ctx), { extends: void 0 })));
var assembleValue = (config, extras, ctx) => unsetKeys(ctx.merge(getSeed(config), ...extras, config), ctx.extendKeys);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TStrategy,
  extend,
  load,
  loadSync,
  parse,
  populate,
  populateSync,
  prepare,
  resolve,
  vmap
});
