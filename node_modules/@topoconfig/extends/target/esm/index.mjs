var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/main/ts/load.ts
import fs from "node:fs";
import { createRequire } from "node:module";
import path from "node:path";
import process2 from "node:process";
import url from "node:url";

// src/main/ts/util.ts
import util from "node:util";
var isString = (value) => typeof value === "string";
var isFn = (value) => typeof value === "function";
var isObject = (value) => value !== null && typeof value === "object";
var isCloneable = (value) => isObject(value) && !util.types.isProxy(value) && !isFn(value) && ![RegExp, Date, Promise, Map, Set, WeakMap, WeakSet].some((c) => value instanceof c);
var stripBom = (content) => content.codePointAt(0) === 65279 ? content.slice(1) : content;
var pipe = (value, hook) => isFn(value?.then) ? value.then(hook) : hook(value);
var getSeed = (value) => isCloneable(value) ? Array.isArray(value) ? [] : Object.create(Object.getPrototypeOf(value)) : void 0;
var getProps = (value) => [
  ...(Array.isArray(value) ? Object.keys : Object.getOwnPropertyNames)(value),
  ...Object.getOwnPropertySymbols(value)
];
var match = (input, pattern) => {
  if (pattern === input || pattern === "*")
    return true;
  if (pattern[0] === "^")
    return new RegExp(pattern).test(input);
  if (pattern.includes("*") || pattern.includes("?")) {
    return new RegExp("^" + pattern.replaceAll(".", "\\.").replaceAll("?", ".").replaceAll("**", ".+").replaceAll("*", "[^.]+") + "$").test(input);
  }
  return false;
};
var unsetKeys = (v, keys) => {
  for (const key of keys) {
    delete v?.[key];
  }
  return v;
};

// src/main/ts/load.ts
var r = import.meta.url ? createRequire(import.meta.url) : __require;
var _require = (id) => r(normalizeRequirePath(id));
var _import = (id) => import.meta.url ? import(normalizeImportPath(id)) : _require(id);
var cjs = /* @__PURE__ */ new Set([".cjs", ".cts"]);
var anyjs = /* @__PURE__ */ new Set(["", ".js", ".ts", ".mjs", ".mts", ...cjs]);
var parse = ({ contents }) => JSON.parse(contents);
var loadSync = ({ resolved: id }) => !isDotFile(id) && anyjs.has(path.extname(id)) ? _require(id) : stripBom(fs.readFileSync(id, "utf8"));
var load = async ({ resolved: id }) => {
  const ext = path.extname(id);
  if (cjs.has(ext))
    return _require(id);
  return !isDotFile(id) && anyjs.has(ext) ? unwrapDefault(await _import(id)) : stripBom(await fs.promises.readFile(id, "utf8"));
};
var resolve = ({ id, cwd, sync }) => id.startsWith(".") ? path.resolve(cwd, id) : resolveExternalModulePath(id, sync);
var locateResource = ({ cwd, root, id, sync, resolve: resolve2 }) => {
  const base = path.resolve(process2.cwd(), cwd ?? ".");
  const def = { cwd: base, root: root || base, id, sync };
  if (!isString(id))
    return def;
  const rawPath = resolve2(def);
  const normalizedPath = rawPath.startsWith("file:") ? url.fileURLToPath(rawPath) : rawPath;
  const dir = path.dirname(normalizedPath);
  if (dir === ".")
    return def;
  return {
    id: "./" + path.basename(normalizedPath),
    cwd: dir,
    root: root || dir,
    sync
  };
};
var loadResource = (ctx) => {
  const { config, cwd, cache, extendKeys } = ctx;
  const resource = isString(config) ? path.join(cwd, config) : config;
  if (!cache.has(resource)) {
    const value = processResource(ctx);
    cache.set(resource, value);
    return value;
  }
  return pipe(cache.get(resource), (v) => unsetKeys(v, extendKeys));
};
var processResource = (ctx) => {
  const { load: load2, config, cwd, parse: parse2, prepare: prepare2, resolve: resolve2, vmap: vmap2, sync, root } = ctx;
  const hctx = { id: config, root, cwd, sync };
  return pipe(isString(config) ? pipe(
    pipe(
      resolve2(hctx),
      (resolved) => load2({ resolved, ...hctx })
    ),
    (contents) => isString(contents) ? parse2({ ...hctx, contents, ext: path.extname(config) }) : contents
  ) : config, (c) => prepare2(c, { ...hctx, vmap: vmap2 }));
};
var normalizeImportPath = (id) => id.startsWith("file:") || !id.includes(":") ? id : url.pathToFileURL(id).href;
var normalizeRequirePath = (id) => id.startsWith("file:") ? url.fileURLToPath(id) : id;
var resolveExternalModulePath = (id, sync) => {
  const resolver = sync ? r.resolve : (import.meta.resolveSync ?? import.meta.resolve)?.bind(import.meta) || r.resolve;
  return id.includes(":") ? id : resolver(id) ?? id;
};
var unwrapDefault = (value) => value?.default ?? value;
var isDotFile = (id) => path.basename(id)[0] === ".";

// src/main/ts/interface.ts
var TStrategy = /* @__PURE__ */ ((TStrategy2) => {
  TStrategy2["OVERRIDE"] = "override";
  TStrategy2["MERGE"] = "merge";
  TStrategy2["POPULATE"] = "populate";
  TStrategy2["IGNORE"] = "ignore";
  TStrategy2["REBASE"] = "rebase";
  return TStrategy2;
})(TStrategy || {});

// src/main/ts/extend.ts
var getRule = (p, rules) => rules[Object.keys(rules).find((k) => match(p, k))] || rules["*"] || "override" /* OVERRIDE */;
var extend = (opts) => {
  const {
    sources = [],
    rules = {},
    prefix = "",
    index = {}
  } = opts;
  const result = index[prefix] = index[prefix] || getSeed(sources[0]);
  const ctx = { result, sources, prefix, rules, index };
  return Array.isArray(result) ? extendArray(ctx) : extendObject(ctx);
};
var extendArray = ({ result, sources, prefix, rules }) => {
  const rule = getRule(prefix, rules);
  if (rule === "ignore" /* IGNORE */)
    return result;
  if (rule === "merge" /* MERGE */) {
    result.push(...sources.flat(1));
  } else {
    result.length = 0;
    result.push(...sources.slice(-1).flat(1));
  }
  return result;
};
var extendObject = ({ result, sources, prefix, rules, index }) => {
  for (const source of sources) {
    for (const key of getProps(source)) {
      const p = `${prefix ? prefix + "." : ""}${key}`;
      const rule = getRule(p, rules);
      const value = source[key];
      if (rule === "ignore" /* IGNORE */)
        continue;
      result[key] = isObject(value) && rule === "merge" /* MERGE */ ? extend({
        sources: [value],
        rules,
        prefix: p,
        index
      }) : value;
    }
  }
  return result;
};

// src/main/ts/populate.ts
import path2 from "node:path";

// src/main/ts/prepare.ts
var prepare = (value, { vmap: vmap2, cwd, root, id } = {}) => _clone({ value, cwd, vmap: vmap2, root, id });
var _vmap = ({ value }) => value;
var vmap = _vmap;
var _clone = ({
  value,
  id,
  cwd = process.cwd(),
  root = cwd,
  resource = value,
  memo = /* @__PURE__ */ new Map(),
  seed = getSeed(value),
  vmap: vmap2 = _vmap,
  prefix = ""
}) => seed ? getProps(value).reduce((m, k) => {
  const p = `${prefix}${k.toString()}`;
  const v = vmap2({
    value: value[k],
    key: k,
    prefix: p,
    resource,
    id,
    cwd,
    root
  });
  if (memo.has(v)) {
    m[k] = memo.get(v);
  } else {
    const _seed = getSeed(v);
    if (_seed) {
      memo.set(v, _seed);
      _clone({
        value: v,
        seed: _seed,
        prefix: `${p}.`,
        memo,
        vmap: vmap2,
        resource,
        cwd,
        id,
        root
      });
      m[k] = _seed;
    } else {
      m[k] = v;
    }
  }
  return m;
}, seed) : value;

// src/main/ts/populate.ts
var populate = async (config, opts = {}) => {
  const ctx = createCtx(config, opts, load, populate);
  const _config = await loadResource(ctx);
  const extras = await Promise.all(populateExtras(_config, ctx));
  return assembleValue(_config, extras, ctx);
};
var populateSync = (config, opts = {}) => {
  const ctx = createCtx(config, opts, loadSync, populateSync, true);
  const _config = loadResource(ctx);
  const extras = populateExtras(_config, ctx);
  return assembleValue(_config, extras, ctx);
};
var createCtx = (config, opts, loader, populate2, sync = false) => {
  const _opts = parseOpts(opts);
  const rules = _opts.rules || {};
  const _extendKeys = Object.keys(rules).filter((k) => rules[k] === "populate" /* POPULATE */);
  const extendKeys = _extendKeys.length > 0 ? _extendKeys : ["extends"];
  const _resolve = _opts.resolve || resolve;
  const { cwd, id: _config, root } = locateResource({
    id: config,
    resolve: _resolve,
    cwd: _opts.cwd,
    root: _opts.root,
    sync
  });
  return {
    load: loader,
    prepare,
    parse,
    cache: /* @__PURE__ */ new Map(),
    resolve: _resolve,
    ..._opts,
    root,
    merge: buildMerge(_opts.merge, rules),
    vmap: buildVmap(_opts.vmap, rules),
    rules,
    extendKeys,
    populate: populate2,
    cwd,
    config: _config,
    sync
  };
};
var anyStrategy = Object.values(TStrategy);
var parseOpts = (opts = {}) => Object.values(opts).every((v) => anyStrategy.includes(v)) ? { rules: opts } : opts;
var buildMerge = (merge, rules) => isFn(merge) ? merge : (...sources) => extend({
  sources,
  rules
});
var buildVmap = (vmap2, rules = {}) => isFn(vmap2) ? vmap2 : ({ value, cwd, root, prefix }) => cwd !== root && getRule(prefix, rules) === "rebase" /* REBASE */ ? path2.join(path2.relative(root, cwd), value) : value;
var populateExtras = (config, ctx) => [...new Set([ctx.extendKeys.map((k) => config?.[k]), ctx.extends].flat(2))].filter(Boolean).map((extra) => ctx.populate(extra, { ...ctx, extends: void 0 }));
var assembleValue = (config, extras, ctx) => unsetKeys(ctx.merge(getSeed(config), ...extras, config), ctx.extendKeys);
export {
  TStrategy,
  extend,
  load,
  loadSync,
  parse,
  populate,
  populateSync,
  prepare,
  resolve,
  vmap
};
