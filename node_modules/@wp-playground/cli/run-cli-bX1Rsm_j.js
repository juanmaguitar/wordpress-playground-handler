import { logger as xe, errorLogPath as ns } from "@php-wasm/logger";
import { ProgressTracker as rs, EmscriptenDownloadMonitor as is } from "@php-wasm/progress";
import { SupportedPHPVersions as ss, PHPResponse as os, consumeAPI as Yn, exposeAPI as Zn } from "@php-wasm/universal";
import { resolveRemoteBlueprint as as, isBlueprintBundle as cs, compileBlueprint as ls, runBlueprintSteps as fs } from "@wp-playground/blueprints";
import { RecommendedPHPVersion as Qr, zipDirectory as Vn, unzipFile as us } from "@wp-playground/common";
import ye, { existsSync as ei } from "fs";
import Je, { basename as kt, join as Pn } from "path";
import { Worker as ds } from "worker_threads";
import { resolveWordPressRelease as ps } from "@wp-playground/wordpress";
import mt from "fs-extra";
import ms, { cpus as hs } from "os";
import xs from "express";
import { FileLockManagerForNode as ws } from "@php-wasm/node";
import gs from "yargs";
import { Semaphore as Dn } from "@php-wasm/util";
function _s(n) {
  const t = process.cwd(), e = [...n.mount || []], r = [...n.mountBeforeInstall || []];
  if (ri(t)) {
    const c = kt(t);
    e.push({
      hostPath: t,
      vfsPath: `/wordpress/wp-content/plugins/${c}`
    });
  } else if (ni(t)) {
    const c = kt(t);
    e.push({
      hostPath: t,
      vfsPath: `/wordpress/wp-content/themes/${c}`
    });
  } else if (ti(t))
    e.push(...Gn(t));
  else if (vn(t)) {
    const c = ye.readdirSync(t), l = [];
    for (const f of c)
      f.startsWith("wp-content") || l.push({
        hostPath: `${t}/${f}`,
        vfsPath: `/wordpress/${f}`
      });
    r.push(
      ...l,
      ...Gn(Pn(t, "wp-content"))
    );
  } else
    e.push({ hostPath: t, vfsPath: "/wordpress" });
  const s = n.blueprint || {};
  s.steps = [...s.steps || [], ...ys(t)];
  const a = n.skipWordPressSetup || vn(t);
  return {
    ...n,
    blueprint: s,
    mount: e,
    mountBeforeInstall: r,
    skipWordPressSetup: a
  };
}
function vn(n) {
  const t = ye.readdirSync(n);
  return t.includes("wp-admin") && t.includes("wp-includes") && t.includes("wp-content");
}
function ti(n) {
  const t = ye.readdirSync(n);
  return t.includes("themes") || t.includes("plugins") || t.includes("mu-plugins") || t.includes("uploads");
}
function ni(n) {
  if (!ye.readdirSync(n).includes("style.css"))
    return !1;
  const e = ye.readFileSync(Pn(n, "style.css"), "utf8");
  return !!/^(?:[ \t]*<\?php)?[ \t/*#@]*Theme Name:(.*)$/im.exec(e);
}
function ri(n) {
  const t = ye.readdirSync(n), e = /^(?:[ \t]*<\?php)?[ \t/*#@]*Plugin Name:(.*)$/im;
  return !!t.filter((s) => s.endsWith(".php")).find((s) => {
    const a = ye.readFileSync(Pn(n, s), "utf8");
    return !!e.exec(a);
  });
}
function Gn(n) {
  return ye.readdirSync(n).filter((e) => !e.startsWith("index.php")).map((e) => ({
    hostPath: `${n}/${e}`,
    vfsPath: `/wordpress/wp-content/${e}`
  }));
}
function ys(n) {
  return ri(n) ? [
    {
      step: "activatePlugin",
      pluginPath: `/wordpress/wp-content/plugins/${kt(n)}`
    }
  ] : ni(n) ? [
    {
      step: "activateTheme",
      themeFolderName: kt(n)
    }
  ] : ti(n) || vn(n) ? [
    {
      step: "runPHP",
      code: `<?php
					require_once '/wordpress/wp-load.php';
					$theme = wp_get_theme();
					if (!$theme->exists()) {
						$themes = wp_get_themes();
						if (count($themes) > 0) {
							$themeName = array_keys($themes)[0];
							switch_theme($themeName);
						}
					}
				`
    }
  ] : [];
}
const En = Je.join(ms.homedir(), ".wordpress-playground");
async function bs(n) {
  return await ii(
    "https://github.com/WordPress/sqlite-database-integration/archive/refs/heads/develop.zip",
    "sqlite.zip",
    n
  );
}
async function ii(n, t, e) {
  const r = Je.join(En, t);
  return mt.existsSync(r) || (mt.ensureDirSync(En), await vs(n, r, e)), si(r);
}
async function vs(n, t, e) {
  const s = (await e.monitorFetch(fetch(n))).body.getReader(), a = `${t}.partial`, c = mt.createWriteStream(a);
  for (; ; ) {
    const { done: l, value: f } = await s.read();
    if (f && c.write(f), l)
      break;
  }
  c.close(), c.closed || await new Promise((l, f) => {
    c.on("finish", () => {
      mt.renameSync(a, t), l(null);
    }), c.on("error", (_) => {
      mt.removeSync(a), f(_);
    });
  });
}
function si(n, t) {
  return new File([mt.readFileSync(n)], kt(n));
}
async function Es(n) {
  const t = xs(), e = await new Promise((a, c) => {
    const l = t.listen(n.port, () => {
      const f = l.address();
      f === null || typeof f == "string" ? c(new Error("Server address is not available")) : a(l);
    });
  });
  t.use("/", async (a, c) => {
    const l = await n.handleRequest({
      url: a.url,
      headers: Ss(a),
      method: a.method,
      body: await ks(a)
    });
    c.statusCode = l.httpStatusCode;
    for (const f in l.headers)
      c.setHeader(f, l.headers[f]);
    c.end(l.bytes);
  });
  const s = e.address().port;
  return await n.onBind(e, s);
}
const ks = async (n) => await new Promise((t) => {
  const e = [];
  n.on("data", (r) => {
    e.push(r);
  }), n.on("end", () => {
    t(new Uint8Array(Buffer.concat(e)));
  });
}), Ss = (n) => {
  const t = {};
  if (n.rawHeaders && n.rawHeaders.length)
    for (let e = 0; e < n.rawHeaders.length; e += 2)
      t[n.rawHeaders[e].toLowerCase()] = n.rawHeaders[e + 1];
  return t;
}, As = "" + new URL("worker-thread-BQ8BezvJ.js", import.meta.url).href;
class Ts {
  constructor(t) {
    this.workerLoads = [], this.addWorker(t);
  }
  addWorker(t) {
    this.workerLoads.push({
      worker: t,
      activeRequests: /* @__PURE__ */ new Set()
    });
  }
  async handleRequest(t) {
    let e = this.workerLoads[0];
    for (let s = 1; s < this.workerLoads.length; s++) {
      const a = this.workerLoads[s];
      a.activeRequests.size < e.activeRequests.size && (e = a);
    }
    const r = e.worker.request(t);
    return e.activeRequests.add(r), r.url = t.url, r.finally(() => {
      e.activeRequests.delete(r);
    });
  }
}
const Rs = () => (async () => "Suspending" in WebAssembly)();
function Fs(n) {
  return /^latest$|^trunk$|^nightly$|^(?:(\d+)\.(\d+)(?:\.(\d+))?)((?:-beta(?:\d+)?)|(?:-RC(?:\d+)?))?$/.test(n);
}
function Kn(n) {
  const t = [];
  for (const e of n) {
    const r = e.split(":");
    if (r.length !== 2)
      throw new Error(`Invalid mount format: ${e}.
				Expected format: /host/path:/vfs/path.
				If your path contains a colon, e.g. C:\\myplugin, use the --mount-dir option instead.
				Example: --mount-dir C:\\my-plugin /wordpress/wp-content/plugins/my-plugin`);
    const [s, a] = r;
    if (!ei(s))
      throw new Error(`Host path does not exist: ${s}`);
    t.push({ hostPath: s, vfsPath: a });
  }
  return t;
}
function Cs(n) {
  if (n.length % 2 !== 0)
    throw new Error("Invalid mount format. Expected: /host/path /vfs/path");
  const t = [];
  for (let e = 0; e < n.length; e += 2) {
    const r = n[e], s = n[e + 1];
    if (!ei(r))
      throw new Error(`Host path does not exist: ${r}`);
    t.push({
      hostPath: Je.resolve(process.cwd(), r),
      vfsPath: s
    });
  }
  return t;
}
class oi extends Error {
  constructor(t, e) {
    super(t, {
      ...e,
      cause: {
        isReportableInCLI: !0
      }
    }), this.isReportableInCLI = !0, this.isReportableInCLI = !0;
  }
  static getReportableCause(t) {
    let e = 0;
    const r = 15, s = [t];
    for (; s.length > 0 && e < r; ) {
      const a = s.pop();
      if (a instanceof Error) {
        if (a.isReportableInCLI)
          return a;
        Array.isArray(a.cause) ? s.push(...a.cause) : s.push(a.cause), e++, e >= r && xe.warn(
          "Recursion limit exceeded while checking if error is reportable"
        );
      }
    }
    return null;
  }
}
new Dn({ concurrency: 15 });
new Dn({ concurrency: 10 });
class Ln extends Error {
  constructor(t) {
    super(t), this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(t) {
    const e = new Ln(t.message);
    return e.code = t.code, e.data = t.data, e.caller = t.caller, e.stack = t.stack, e;
  }
  get isIsomorphicGitError() {
    return !0;
  }
}
var Is = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(n) {
  (function(t) {
    t(typeof DO_NOT_EXPORT_CRC > "u" ? n : {});
  })(function(t) {
    t.version = "1.2.2";
    function e() {
      for (var b = 0, C = new Array(256), v = 0; v != 256; ++v)
        b = v, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, C[v] = b;
      return typeof Int32Array < "u" ? new Int32Array(C) : C;
    }
    var r = e();
    function s(b) {
      var C = 0, v = 0, S = 0, M = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
      for (S = 0; S != 256; ++S) M[S] = b[S];
      for (S = 0; S != 256; ++S)
        for (v = b[S], C = 256 + S; C < 4096; C += 256) v = M[C] = v >>> 8 ^ b[v & 255];
      var L = [];
      for (S = 1; S != 16; ++S) L[S - 1] = typeof Int32Array < "u" ? M.subarray(S * 256, S * 256 + 256) : M.slice(S * 256, S * 256 + 256);
      return L;
    }
    var a = s(r), c = a[0], l = a[1], f = a[2], _ = a[3], x = a[4], w = a[5], g = a[6], k = a[7], P = a[8], m = a[9], d = a[10], h = a[11], y = a[12], T = a[13], D = a[14];
    function A(b, C) {
      for (var v = C ^ -1, S = 0, M = b.length; S < M; ) v = v >>> 8 ^ r[(v ^ b.charCodeAt(S++)) & 255];
      return ~v;
    }
    function R(b, C) {
      for (var v = C ^ -1, S = b.length - 15, M = 0; M < S; ) v = D[b[M++] ^ v & 255] ^ T[b[M++] ^ v >> 8 & 255] ^ y[b[M++] ^ v >> 16 & 255] ^ h[b[M++] ^ v >>> 24] ^ d[b[M++]] ^ m[b[M++]] ^ P[b[M++]] ^ k[b[M++]] ^ g[b[M++]] ^ w[b[M++]] ^ x[b[M++]] ^ _[b[M++]] ^ f[b[M++]] ^ l[b[M++]] ^ c[b[M++]] ^ r[b[M++]];
      for (S += 15; M < S; ) v = v >>> 8 ^ r[(v ^ b[M++]) & 255];
      return ~v;
    }
    function F(b, C) {
      for (var v = C ^ -1, S = 0, M = b.length, L = 0, Y = 0; S < M; )
        L = b.charCodeAt(S++), L < 128 ? v = v >>> 8 ^ r[(v ^ L) & 255] : L < 2048 ? (v = v >>> 8 ^ r[(v ^ (192 | L >> 6 & 31)) & 255], v = v >>> 8 ^ r[(v ^ (128 | L & 63)) & 255]) : L >= 55296 && L < 57344 ? (L = (L & 1023) + 64, Y = b.charCodeAt(S++) & 1023, v = v >>> 8 ^ r[(v ^ (240 | L >> 8 & 7)) & 255], v = v >>> 8 ^ r[(v ^ (128 | L >> 2 & 63)) & 255], v = v >>> 8 ^ r[(v ^ (128 | Y >> 6 & 15 | (L & 3) << 4)) & 255], v = v >>> 8 ^ r[(v ^ (128 | Y & 63)) & 255]) : (v = v >>> 8 ^ r[(v ^ (224 | L >> 12 & 15)) & 255], v = v >>> 8 ^ r[(v ^ (128 | L >> 6 & 63)) & 255], v = v >>> 8 ^ r[(v ^ (128 | L & 63)) & 255]);
      return ~v;
    }
    t.table = r, t.bstr = A, t.buf = R, t.str = F;
  });
})(Is);
var ai = {}, en = {};
en.byteLength = Ls;
en.toByteArray = Os;
en.fromByteArray = Ms;
var We = [], Ce = [], Ps = typeof Uint8Array < "u" ? Uint8Array : Array, on = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ct = 0, Ds = on.length; ct < Ds; ++ct)
  We[ct] = on[ct], Ce[on.charCodeAt(ct)] = ct;
Ce[45] = 62;
Ce[95] = 63;
function ci(n) {
  var t = n.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e = n.indexOf("=");
  e === -1 && (e = t);
  var r = e === t ? 0 : 4 - e % 4;
  return [e, r];
}
function Ls(n) {
  var t = ci(n), e = t[0], r = t[1];
  return (e + r) * 3 / 4 - r;
}
function Us(n, t, e) {
  return (t + e) * 3 / 4 - e;
}
function Os(n) {
  var t, e = ci(n), r = e[0], s = e[1], a = new Ps(Us(n, r, s)), c = 0, l = s > 0 ? r - 4 : r, f;
  for (f = 0; f < l; f += 4)
    t = Ce[n.charCodeAt(f)] << 18 | Ce[n.charCodeAt(f + 1)] << 12 | Ce[n.charCodeAt(f + 2)] << 6 | Ce[n.charCodeAt(f + 3)], a[c++] = t >> 16 & 255, a[c++] = t >> 8 & 255, a[c++] = t & 255;
  return s === 2 && (t = Ce[n.charCodeAt(f)] << 2 | Ce[n.charCodeAt(f + 1)] >> 4, a[c++] = t & 255), s === 1 && (t = Ce[n.charCodeAt(f)] << 10 | Ce[n.charCodeAt(f + 1)] << 4 | Ce[n.charCodeAt(f + 2)] >> 2, a[c++] = t >> 8 & 255, a[c++] = t & 255), a;
}
function Bs(n) {
  return We[n >> 18 & 63] + We[n >> 12 & 63] + We[n >> 6 & 63] + We[n & 63];
}
function Ws(n, t, e) {
  for (var r, s = [], a = t; a < e; a += 3)
    r = (n[a] << 16 & 16711680) + (n[a + 1] << 8 & 65280) + (n[a + 2] & 255), s.push(Bs(r));
  return s.join("");
}
function Ms(n) {
  for (var t, e = n.length, r = e % 3, s = [], a = 16383, c = 0, l = e - r; c < l; c += a)
    s.push(Ws(n, c, c + a > l ? l : c + a));
  return r === 1 ? (t = n[e - 1], s.push(
    We[t >> 2] + We[t << 4 & 63] + "=="
  )) : r === 2 && (t = (n[e - 2] << 8) + n[e - 1], s.push(
    We[t >> 10] + We[t >> 4 & 63] + We[t << 2 & 63] + "="
  )), s.join("");
}
var Un = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Un.read = function(n, t, e, r, s) {
  var a, c, l = s * 8 - r - 1, f = (1 << l) - 1, _ = f >> 1, x = -7, w = e ? s - 1 : 0, g = e ? -1 : 1, k = n[t + w];
  for (w += g, a = k & (1 << -x) - 1, k >>= -x, x += l; x > 0; a = a * 256 + n[t + w], w += g, x -= 8)
    ;
  for (c = a & (1 << -x) - 1, a >>= -x, x += r; x > 0; c = c * 256 + n[t + w], w += g, x -= 8)
    ;
  if (a === 0)
    a = 1 - _;
  else {
    if (a === f)
      return c ? NaN : (k ? -1 : 1) * (1 / 0);
    c = c + Math.pow(2, r), a = a - _;
  }
  return (k ? -1 : 1) * c * Math.pow(2, a - r);
};
Un.write = function(n, t, e, r, s, a) {
  var c, l, f, _ = a * 8 - s - 1, x = (1 << _) - 1, w = x >> 1, g = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k = r ? 0 : a - 1, P = r ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, c = x) : (c = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -c)) < 1 && (c--, f *= 2), c + w >= 1 ? t += g / f : t += g * Math.pow(2, 1 - w), t * f >= 2 && (c++, f /= 2), c + w >= x ? (l = 0, c = x) : c + w >= 1 ? (l = (t * f - 1) * Math.pow(2, s), c = c + w) : (l = t * Math.pow(2, w - 1) * Math.pow(2, s), c = 0)); s >= 8; n[e + k] = l & 255, k += P, l /= 256, s -= 8)
    ;
  for (c = c << s | l, _ += s; _ > 0; n[e + k] = c & 255, k += P, c /= 256, _ -= 8)
    ;
  n[e + k - P] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  var t = en, e = Un, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = l, n.SlowBuffer = y, n.INSPECT_MAX_BYTES = 50;
  var s = 2147483647;
  n.kMaxLength = s, l.TYPED_ARRAY_SUPPORT = a(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      var u = new Uint8Array(1), i = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(i, Uint8Array.prototype), Object.setPrototypeOf(u, i), u.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(l.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(u) {
    if (u > s)
      throw new RangeError('The value "' + u + '" is invalid for option "size"');
    var i = new Uint8Array(u);
    return Object.setPrototypeOf(i, l.prototype), i;
  }
  function l(u, i, o) {
    if (typeof u == "number") {
      if (typeof i == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return w(u);
    }
    return f(u, i, o);
  }
  l.poolSize = 8192;
  function f(u, i, o) {
    if (typeof u == "string")
      return g(u, i);
    if (ArrayBuffer.isView(u))
      return P(u);
    if (u == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof u
      );
    if (fe(u, ArrayBuffer) || u && fe(u.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (fe(u, SharedArrayBuffer) || u && fe(u.buffer, SharedArrayBuffer)))
      return m(u, i, o);
    if (typeof u == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var p = u.valueOf && u.valueOf();
    if (p != null && p !== u)
      return l.from(p, i, o);
    var E = d(u);
    if (E) return E;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof u[Symbol.toPrimitive] == "function")
      return l.from(
        u[Symbol.toPrimitive]("string"),
        i,
        o
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof u
    );
  }
  l.from = function(u, i, o) {
    return f(u, i, o);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
  function _(u) {
    if (typeof u != "number")
      throw new TypeError('"size" argument must be of type number');
    if (u < 0)
      throw new RangeError('The value "' + u + '" is invalid for option "size"');
  }
  function x(u, i, o) {
    return _(u), u <= 0 ? c(u) : i !== void 0 ? typeof o == "string" ? c(u).fill(i, o) : c(u).fill(i) : c(u);
  }
  l.alloc = function(u, i, o) {
    return x(u, i, o);
  };
  function w(u) {
    return _(u), c(u < 0 ? 0 : h(u) | 0);
  }
  l.allocUnsafe = function(u) {
    return w(u);
  }, l.allocUnsafeSlow = function(u) {
    return w(u);
  };
  function g(u, i) {
    if ((typeof i != "string" || i === "") && (i = "utf8"), !l.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
    var o = T(u, i) | 0, p = c(o), E = p.write(u, i);
    return E !== o && (p = p.slice(0, E)), p;
  }
  function k(u) {
    for (var i = u.length < 0 ? 0 : h(u.length) | 0, o = c(i), p = 0; p < i; p += 1)
      o[p] = u[p] & 255;
    return o;
  }
  function P(u) {
    if (fe(u, Uint8Array)) {
      var i = new Uint8Array(u);
      return m(i.buffer, i.byteOffset, i.byteLength);
    }
    return k(u);
  }
  function m(u, i, o) {
    if (i < 0 || u.byteLength < i)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (u.byteLength < i + (o || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var p;
    return i === void 0 && o === void 0 ? p = new Uint8Array(u) : o === void 0 ? p = new Uint8Array(u, i) : p = new Uint8Array(u, i, o), Object.setPrototypeOf(p, l.prototype), p;
  }
  function d(u) {
    if (l.isBuffer(u)) {
      var i = h(u.length) | 0, o = c(i);
      return o.length === 0 || u.copy(o, 0, 0, i), o;
    }
    if (u.length !== void 0)
      return typeof u.length != "number" || je(u.length) ? c(0) : k(u);
    if (u.type === "Buffer" && Array.isArray(u.data))
      return k(u.data);
  }
  function h(u) {
    if (u >= s)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return u | 0;
  }
  function y(u) {
    return +u != u && (u = 0), l.alloc(+u);
  }
  l.isBuffer = function(i) {
    return i != null && i._isBuffer === !0 && i !== l.prototype;
  }, l.compare = function(i, o) {
    if (fe(i, Uint8Array) && (i = l.from(i, i.offset, i.byteLength)), fe(o, Uint8Array) && (o = l.from(o, o.offset, o.byteLength)), !l.isBuffer(i) || !l.isBuffer(o))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (i === o) return 0;
    for (var p = i.length, E = o.length, U = 0, W = Math.min(p, E); U < W; ++U)
      if (i[U] !== o[U]) {
        p = i[U], E = o[U];
        break;
      }
    return p < E ? -1 : E < p ? 1 : 0;
  }, l.isEncoding = function(i) {
    switch (String(i).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, l.concat = function(i, o) {
    if (!Array.isArray(i))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (i.length === 0)
      return l.alloc(0);
    var p;
    if (o === void 0)
      for (o = 0, p = 0; p < i.length; ++p)
        o += i[p].length;
    var E = l.allocUnsafe(o), U = 0;
    for (p = 0; p < i.length; ++p) {
      var W = i[p];
      if (fe(W, Uint8Array))
        U + W.length > E.length ? l.from(W).copy(E, U) : Uint8Array.prototype.set.call(
          E,
          W,
          U
        );
      else if (l.isBuffer(W))
        W.copy(E, U);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      U += W.length;
    }
    return E;
  };
  function T(u, i) {
    if (l.isBuffer(u))
      return u.length;
    if (ArrayBuffer.isView(u) || fe(u, ArrayBuffer))
      return u.byteLength;
    if (typeof u != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof u
      );
    var o = u.length, p = arguments.length > 2 && arguments[2] === !0;
    if (!p && o === 0) return 0;
    for (var E = !1; ; )
      switch (i) {
        case "ascii":
        case "latin1":
        case "binary":
          return o;
        case "utf8":
        case "utf-8":
          return qe(u).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return o * 2;
        case "hex":
          return o >>> 1;
        case "base64":
          return tt(u).length;
        default:
          if (E)
            return p ? -1 : qe(u).length;
          i = ("" + i).toLowerCase(), E = !0;
      }
  }
  l.byteLength = T;
  function D(u, i, o) {
    var p = !1;
    if ((i === void 0 || i < 0) && (i = 0), i > this.length || ((o === void 0 || o > this.length) && (o = this.length), o <= 0) || (o >>>= 0, i >>>= 0, o <= i))
      return "";
    for (u || (u = "utf8"); ; )
      switch (u) {
        case "hex":
          return oe(this, i, o);
        case "utf8":
        case "utf-8":
          return Y(this, i, o);
        case "ascii":
          return K(this, i, o);
        case "latin1":
        case "binary":
          return V(this, i, o);
        case "base64":
          return L(this, i, o);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Z(this, i, o);
        default:
          if (p) throw new TypeError("Unknown encoding: " + u);
          u = (u + "").toLowerCase(), p = !0;
      }
  }
  l.prototype._isBuffer = !0;
  function A(u, i, o) {
    var p = u[i];
    u[i] = u[o], u[o] = p;
  }
  l.prototype.swap16 = function() {
    var i = this.length;
    if (i % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var o = 0; o < i; o += 2)
      A(this, o, o + 1);
    return this;
  }, l.prototype.swap32 = function() {
    var i = this.length;
    if (i % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var o = 0; o < i; o += 4)
      A(this, o, o + 3), A(this, o + 1, o + 2);
    return this;
  }, l.prototype.swap64 = function() {
    var i = this.length;
    if (i % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var o = 0; o < i; o += 8)
      A(this, o, o + 7), A(this, o + 1, o + 6), A(this, o + 2, o + 5), A(this, o + 3, o + 4);
    return this;
  }, l.prototype.toString = function() {
    var i = this.length;
    return i === 0 ? "" : arguments.length === 0 ? Y(this, 0, i) : D.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(i) {
    if (!l.isBuffer(i)) throw new TypeError("Argument must be a Buffer");
    return this === i ? !0 : l.compare(this, i) === 0;
  }, l.prototype.inspect = function() {
    var i = "", o = n.INSPECT_MAX_BYTES;
    return i = this.toString("hex", 0, o).replace(/(.{2})/g, "$1 ").trim(), this.length > o && (i += " ... "), "<Buffer " + i + ">";
  }, r && (l.prototype[r] = l.prototype.inspect), l.prototype.compare = function(i, o, p, E, U) {
    if (fe(i, Uint8Array) && (i = l.from(i, i.offset, i.byteLength)), !l.isBuffer(i))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof i
      );
    if (o === void 0 && (o = 0), p === void 0 && (p = i ? i.length : 0), E === void 0 && (E = 0), U === void 0 && (U = this.length), o < 0 || p > i.length || E < 0 || U > this.length)
      throw new RangeError("out of range index");
    if (E >= U && o >= p)
      return 0;
    if (E >= U)
      return -1;
    if (o >= p)
      return 1;
    if (o >>>= 0, p >>>= 0, E >>>= 0, U >>>= 0, this === i) return 0;
    for (var W = U - E, X = p - o, ne = Math.min(W, X), re = this.slice(E, U), pe = i.slice(o, p), te = 0; te < ne; ++te)
      if (re[te] !== pe[te]) {
        W = re[te], X = pe[te];
        break;
      }
    return W < X ? -1 : X < W ? 1 : 0;
  };
  function R(u, i, o, p, E) {
    if (u.length === 0) return -1;
    if (typeof o == "string" ? (p = o, o = 0) : o > 2147483647 ? o = 2147483647 : o < -2147483648 && (o = -2147483648), o = +o, je(o) && (o = E ? 0 : u.length - 1), o < 0 && (o = u.length + o), o >= u.length) {
      if (E) return -1;
      o = u.length - 1;
    } else if (o < 0)
      if (E) o = 0;
      else return -1;
    if (typeof i == "string" && (i = l.from(i, p)), l.isBuffer(i))
      return i.length === 0 ? -1 : F(u, i, o, p, E);
    if (typeof i == "number")
      return i = i & 255, typeof Uint8Array.prototype.indexOf == "function" ? E ? Uint8Array.prototype.indexOf.call(u, i, o) : Uint8Array.prototype.lastIndexOf.call(u, i, o) : F(u, [i], o, p, E);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(u, i, o, p, E) {
    var U = 1, W = u.length, X = i.length;
    if (p !== void 0 && (p = String(p).toLowerCase(), p === "ucs2" || p === "ucs-2" || p === "utf16le" || p === "utf-16le")) {
      if (u.length < 2 || i.length < 2)
        return -1;
      U = 2, W /= 2, X /= 2, o /= 2;
    }
    function ne(It, gt) {
      return U === 1 ? It[gt] : It.readUInt16BE(gt * U);
    }
    var re;
    if (E) {
      var pe = -1;
      for (re = o; re < W; re++)
        if (ne(u, re) === ne(i, pe === -1 ? 0 : re - pe)) {
          if (pe === -1 && (pe = re), re - pe + 1 === X) return pe * U;
        } else
          pe !== -1 && (re -= re - pe), pe = -1;
    } else
      for (o + X > W && (o = W - X), re = o; re >= 0; re--) {
        for (var te = !0, Ye = 0; Ye < X; Ye++)
          if (ne(u, re + Ye) !== ne(i, Ye)) {
            te = !1;
            break;
          }
        if (te) return re;
      }
    return -1;
  }
  l.prototype.includes = function(i, o, p) {
    return this.indexOf(i, o, p) !== -1;
  }, l.prototype.indexOf = function(i, o, p) {
    return R(this, i, o, p, !0);
  }, l.prototype.lastIndexOf = function(i, o, p) {
    return R(this, i, o, p, !1);
  };
  function b(u, i, o, p) {
    o = Number(o) || 0;
    var E = u.length - o;
    p ? (p = Number(p), p > E && (p = E)) : p = E;
    var U = i.length;
    p > U / 2 && (p = U / 2);
    for (var W = 0; W < p; ++W) {
      var X = parseInt(i.substr(W * 2, 2), 16);
      if (je(X)) return W;
      u[o + W] = X;
    }
    return W;
  }
  function C(u, i, o, p) {
    return ge(qe(i, u.length - o), u, o, p);
  }
  function v(u, i, o, p) {
    return ge(at(i), u, o, p);
  }
  function S(u, i, o, p) {
    return ge(tt(i), u, o, p);
  }
  function M(u, i, o, p) {
    return ge(et(i, u.length - o), u, o, p);
  }
  l.prototype.write = function(i, o, p, E) {
    if (o === void 0)
      E = "utf8", p = this.length, o = 0;
    else if (p === void 0 && typeof o == "string")
      E = o, p = this.length, o = 0;
    else if (isFinite(o))
      o = o >>> 0, isFinite(p) ? (p = p >>> 0, E === void 0 && (E = "utf8")) : (E = p, p = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var U = this.length - o;
    if ((p === void 0 || p > U) && (p = U), i.length > 0 && (p < 0 || o < 0) || o > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    E || (E = "utf8");
    for (var W = !1; ; )
      switch (E) {
        case "hex":
          return b(this, i, o, p);
        case "utf8":
        case "utf-8":
          return C(this, i, o, p);
        case "ascii":
        case "latin1":
        case "binary":
          return v(this, i, o, p);
        case "base64":
          return S(this, i, o, p);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, i, o, p);
        default:
          if (W) throw new TypeError("Unknown encoding: " + E);
          E = ("" + E).toLowerCase(), W = !0;
      }
  }, l.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function L(u, i, o) {
    return i === 0 && o === u.length ? t.fromByteArray(u) : t.fromByteArray(u.slice(i, o));
  }
  function Y(u, i, o) {
    o = Math.min(u.length, o);
    for (var p = [], E = i; E < o; ) {
      var U = u[E], W = null, X = U > 239 ? 4 : U > 223 ? 3 : U > 191 ? 2 : 1;
      if (E + X <= o) {
        var ne, re, pe, te;
        switch (X) {
          case 1:
            U < 128 && (W = U);
            break;
          case 2:
            ne = u[E + 1], (ne & 192) === 128 && (te = (U & 31) << 6 | ne & 63, te > 127 && (W = te));
            break;
          case 3:
            ne = u[E + 1], re = u[E + 2], (ne & 192) === 128 && (re & 192) === 128 && (te = (U & 15) << 12 | (ne & 63) << 6 | re & 63, te > 2047 && (te < 55296 || te > 57343) && (W = te));
            break;
          case 4:
            ne = u[E + 1], re = u[E + 2], pe = u[E + 3], (ne & 192) === 128 && (re & 192) === 128 && (pe & 192) === 128 && (te = (U & 15) << 18 | (ne & 63) << 12 | (re & 63) << 6 | pe & 63, te > 65535 && te < 1114112 && (W = te));
        }
      }
      W === null ? (W = 65533, X = 1) : W > 65535 && (W -= 65536, p.push(W >>> 10 & 1023 | 55296), W = 56320 | W & 1023), p.push(W), E += X;
    }
    return j(p);
  }
  var H = 4096;
  function j(u) {
    var i = u.length;
    if (i <= H)
      return String.fromCharCode.apply(String, u);
    for (var o = "", p = 0; p < i; )
      o += String.fromCharCode.apply(
        String,
        u.slice(p, p += H)
      );
    return o;
  }
  function K(u, i, o) {
    var p = "";
    o = Math.min(u.length, o);
    for (var E = i; E < o; ++E)
      p += String.fromCharCode(u[E] & 127);
    return p;
  }
  function V(u, i, o) {
    var p = "";
    o = Math.min(u.length, o);
    for (var E = i; E < o; ++E)
      p += String.fromCharCode(u[E]);
    return p;
  }
  function oe(u, i, o) {
    var p = u.length;
    (!i || i < 0) && (i = 0), (!o || o < 0 || o > p) && (o = p);
    for (var E = "", U = i; U < o; ++U)
      E += ue[u[U]];
    return E;
  }
  function Z(u, i, o) {
    for (var p = u.slice(i, o), E = "", U = 0; U < p.length - 1; U += 2)
      E += String.fromCharCode(p[U] + p[U + 1] * 256);
    return E;
  }
  l.prototype.slice = function(i, o) {
    var p = this.length;
    i = ~~i, o = o === void 0 ? p : ~~o, i < 0 ? (i += p, i < 0 && (i = 0)) : i > p && (i = p), o < 0 ? (o += p, o < 0 && (o = 0)) : o > p && (o = p), o < i && (o = i);
    var E = this.subarray(i, o);
    return Object.setPrototypeOf(E, l.prototype), E;
  };
  function J(u, i, o) {
    if (u % 1 !== 0 || u < 0) throw new RangeError("offset is not uint");
    if (u + i > o) throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(i, o, p) {
    i = i >>> 0, o = o >>> 0, p || J(i, o, this.length);
    for (var E = this[i], U = 1, W = 0; ++W < o && (U *= 256); )
      E += this[i + W] * U;
    return E;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(i, o, p) {
    i = i >>> 0, o = o >>> 0, p || J(i, o, this.length);
    for (var E = this[i + --o], U = 1; o > 0 && (U *= 256); )
      E += this[i + --o] * U;
    return E;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(i, o) {
    return i = i >>> 0, o || J(i, 1, this.length), this[i];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(i, o) {
    return i = i >>> 0, o || J(i, 2, this.length), this[i] | this[i + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(i, o) {
    return i = i >>> 0, o || J(i, 2, this.length), this[i] << 8 | this[i + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(i, o) {
    return i = i >>> 0, o || J(i, 4, this.length), (this[i] | this[i + 1] << 8 | this[i + 2] << 16) + this[i + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(i, o) {
    return i = i >>> 0, o || J(i, 4, this.length), this[i] * 16777216 + (this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3]);
  }, l.prototype.readIntLE = function(i, o, p) {
    i = i >>> 0, o = o >>> 0, p || J(i, o, this.length);
    for (var E = this[i], U = 1, W = 0; ++W < o && (U *= 256); )
      E += this[i + W] * U;
    return U *= 128, E >= U && (E -= Math.pow(2, 8 * o)), E;
  }, l.prototype.readIntBE = function(i, o, p) {
    i = i >>> 0, o = o >>> 0, p || J(i, o, this.length);
    for (var E = o, U = 1, W = this[i + --E]; E > 0 && (U *= 256); )
      W += this[i + --E] * U;
    return U *= 128, W >= U && (W -= Math.pow(2, 8 * o)), W;
  }, l.prototype.readInt8 = function(i, o) {
    return i = i >>> 0, o || J(i, 1, this.length), this[i] & 128 ? (255 - this[i] + 1) * -1 : this[i];
  }, l.prototype.readInt16LE = function(i, o) {
    i = i >>> 0, o || J(i, 2, this.length);
    var p = this[i] | this[i + 1] << 8;
    return p & 32768 ? p | 4294901760 : p;
  }, l.prototype.readInt16BE = function(i, o) {
    i = i >>> 0, o || J(i, 2, this.length);
    var p = this[i + 1] | this[i] << 8;
    return p & 32768 ? p | 4294901760 : p;
  }, l.prototype.readInt32LE = function(i, o) {
    return i = i >>> 0, o || J(i, 4, this.length), this[i] | this[i + 1] << 8 | this[i + 2] << 16 | this[i + 3] << 24;
  }, l.prototype.readInt32BE = function(i, o) {
    return i = i >>> 0, o || J(i, 4, this.length), this[i] << 24 | this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3];
  }, l.prototype.readFloatLE = function(i, o) {
    return i = i >>> 0, o || J(i, 4, this.length), e.read(this, i, !0, 23, 4);
  }, l.prototype.readFloatBE = function(i, o) {
    return i = i >>> 0, o || J(i, 4, this.length), e.read(this, i, !1, 23, 4);
  }, l.prototype.readDoubleLE = function(i, o) {
    return i = i >>> 0, o || J(i, 8, this.length), e.read(this, i, !0, 52, 8);
  }, l.prototype.readDoubleBE = function(i, o) {
    return i = i >>> 0, o || J(i, 8, this.length), e.read(this, i, !1, 52, 8);
  };
  function $(u, i, o, p, E, U) {
    if (!l.isBuffer(u)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (i > E || i < U) throw new RangeError('"value" argument is out of bounds');
    if (o + p > u.length) throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(i, o, p, E) {
    if (i = +i, o = o >>> 0, p = p >>> 0, !E) {
      var U = Math.pow(2, 8 * p) - 1;
      $(this, i, o, p, U, 0);
    }
    var W = 1, X = 0;
    for (this[o] = i & 255; ++X < p && (W *= 256); )
      this[o + X] = i / W & 255;
    return o + p;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(i, o, p, E) {
    if (i = +i, o = o >>> 0, p = p >>> 0, !E) {
      var U = Math.pow(2, 8 * p) - 1;
      $(this, i, o, p, U, 0);
    }
    var W = p - 1, X = 1;
    for (this[o + W] = i & 255; --W >= 0 && (X *= 256); )
      this[o + W] = i / X & 255;
    return o + p;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 1, 255, 0), this[o] = i & 255, o + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 2, 65535, 0), this[o] = i & 255, this[o + 1] = i >>> 8, o + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 2, 65535, 0), this[o] = i >>> 8, this[o + 1] = i & 255, o + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 4, 4294967295, 0), this[o + 3] = i >>> 24, this[o + 2] = i >>> 16, this[o + 1] = i >>> 8, this[o] = i & 255, o + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 4, 4294967295, 0), this[o] = i >>> 24, this[o + 1] = i >>> 16, this[o + 2] = i >>> 8, this[o + 3] = i & 255, o + 4;
  }, l.prototype.writeIntLE = function(i, o, p, E) {
    if (i = +i, o = o >>> 0, !E) {
      var U = Math.pow(2, 8 * p - 1);
      $(this, i, o, p, U - 1, -U);
    }
    var W = 0, X = 1, ne = 0;
    for (this[o] = i & 255; ++W < p && (X *= 256); )
      i < 0 && ne === 0 && this[o + W - 1] !== 0 && (ne = 1), this[o + W] = (i / X >> 0) - ne & 255;
    return o + p;
  }, l.prototype.writeIntBE = function(i, o, p, E) {
    if (i = +i, o = o >>> 0, !E) {
      var U = Math.pow(2, 8 * p - 1);
      $(this, i, o, p, U - 1, -U);
    }
    var W = p - 1, X = 1, ne = 0;
    for (this[o + W] = i & 255; --W >= 0 && (X *= 256); )
      i < 0 && ne === 0 && this[o + W + 1] !== 0 && (ne = 1), this[o + W] = (i / X >> 0) - ne & 255;
    return o + p;
  }, l.prototype.writeInt8 = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 1, 127, -128), i < 0 && (i = 255 + i + 1), this[o] = i & 255, o + 1;
  }, l.prototype.writeInt16LE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 2, 32767, -32768), this[o] = i & 255, this[o + 1] = i >>> 8, o + 2;
  }, l.prototype.writeInt16BE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 2, 32767, -32768), this[o] = i >>> 8, this[o + 1] = i & 255, o + 2;
  }, l.prototype.writeInt32LE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 4, 2147483647, -2147483648), this[o] = i & 255, this[o + 1] = i >>> 8, this[o + 2] = i >>> 16, this[o + 3] = i >>> 24, o + 4;
  }, l.prototype.writeInt32BE = function(i, o, p) {
    return i = +i, o = o >>> 0, p || $(this, i, o, 4, 2147483647, -2147483648), i < 0 && (i = 4294967295 + i + 1), this[o] = i >>> 24, this[o + 1] = i >>> 16, this[o + 2] = i >>> 8, this[o + 3] = i & 255, o + 4;
  };
  function ee(u, i, o, p, E, U) {
    if (o + p > u.length) throw new RangeError("Index out of range");
    if (o < 0) throw new RangeError("Index out of range");
  }
  function Pe(u, i, o, p, E) {
    return i = +i, o = o >>> 0, E || ee(u, i, o, 4), e.write(u, i, o, p, 23, 4), o + 4;
  }
  l.prototype.writeFloatLE = function(i, o, p) {
    return Pe(this, i, o, !0, p);
  }, l.prototype.writeFloatBE = function(i, o, p) {
    return Pe(this, i, o, !1, p);
  };
  function de(u, i, o, p, E) {
    return i = +i, o = o >>> 0, E || ee(u, i, o, 8), e.write(u, i, o, p, 52, 8), o + 8;
  }
  l.prototype.writeDoubleLE = function(i, o, p) {
    return de(this, i, o, !0, p);
  }, l.prototype.writeDoubleBE = function(i, o, p) {
    return de(this, i, o, !1, p);
  }, l.prototype.copy = function(i, o, p, E) {
    if (!l.isBuffer(i)) throw new TypeError("argument should be a Buffer");
    if (p || (p = 0), !E && E !== 0 && (E = this.length), o >= i.length && (o = i.length), o || (o = 0), E > 0 && E < p && (E = p), E === p || i.length === 0 || this.length === 0) return 0;
    if (o < 0)
      throw new RangeError("targetStart out of bounds");
    if (p < 0 || p >= this.length) throw new RangeError("Index out of range");
    if (E < 0) throw new RangeError("sourceEnd out of bounds");
    E > this.length && (E = this.length), i.length - o < E - p && (E = i.length - o + p);
    var U = E - p;
    return this === i && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(o, p, E) : Uint8Array.prototype.set.call(
      i,
      this.subarray(p, E),
      o
    ), U;
  }, l.prototype.fill = function(i, o, p, E) {
    if (typeof i == "string") {
      if (typeof o == "string" ? (E = o, o = 0, p = this.length) : typeof p == "string" && (E = p, p = this.length), E !== void 0 && typeof E != "string")
        throw new TypeError("encoding must be a string");
      if (typeof E == "string" && !l.isEncoding(E))
        throw new TypeError("Unknown encoding: " + E);
      if (i.length === 1) {
        var U = i.charCodeAt(0);
        (E === "utf8" && U < 128 || E === "latin1") && (i = U);
      }
    } else typeof i == "number" ? i = i & 255 : typeof i == "boolean" && (i = Number(i));
    if (o < 0 || this.length < o || this.length < p)
      throw new RangeError("Out of range index");
    if (p <= o)
      return this;
    o = o >>> 0, p = p === void 0 ? this.length : p >>> 0, i || (i = 0);
    var W;
    if (typeof i == "number")
      for (W = o; W < p; ++W)
        this[W] = i;
    else {
      var X = l.isBuffer(i) ? i : l.from(i, E), ne = X.length;
      if (ne === 0)
        throw new TypeError('The value "' + i + '" is invalid for argument "value"');
      for (W = 0; W < p - o; ++W)
        this[W + o] = X[W % ne];
    }
    return this;
  };
  var le = /[^+/0-9A-Za-z-_]/g;
  function wt(u) {
    if (u = u.split("=")[0], u = u.trim().replace(le, ""), u.length < 2) return "";
    for (; u.length % 4 !== 0; )
      u = u + "=";
    return u;
  }
  function qe(u, i) {
    i = i || 1 / 0;
    for (var o, p = u.length, E = null, U = [], W = 0; W < p; ++W) {
      if (o = u.charCodeAt(W), o > 55295 && o < 57344) {
        if (!E) {
          if (o > 56319) {
            (i -= 3) > -1 && U.push(239, 191, 189);
            continue;
          } else if (W + 1 === p) {
            (i -= 3) > -1 && U.push(239, 191, 189);
            continue;
          }
          E = o;
          continue;
        }
        if (o < 56320) {
          (i -= 3) > -1 && U.push(239, 191, 189), E = o;
          continue;
        }
        o = (E - 55296 << 10 | o - 56320) + 65536;
      } else E && (i -= 3) > -1 && U.push(239, 191, 189);
      if (E = null, o < 128) {
        if ((i -= 1) < 0) break;
        U.push(o);
      } else if (o < 2048) {
        if ((i -= 2) < 0) break;
        U.push(
          o >> 6 | 192,
          o & 63 | 128
        );
      } else if (o < 65536) {
        if ((i -= 3) < 0) break;
        U.push(
          o >> 12 | 224,
          o >> 6 & 63 | 128,
          o & 63 | 128
        );
      } else if (o < 1114112) {
        if ((i -= 4) < 0) break;
        U.push(
          o >> 18 | 240,
          o >> 12 & 63 | 128,
          o >> 6 & 63 | 128,
          o & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return U;
  }
  function at(u) {
    for (var i = [], o = 0; o < u.length; ++o)
      i.push(u.charCodeAt(o) & 255);
    return i;
  }
  function et(u, i) {
    for (var o, p, E, U = [], W = 0; W < u.length && !((i -= 2) < 0); ++W)
      o = u.charCodeAt(W), p = o >> 8, E = o % 256, U.push(E), U.push(p);
    return U;
  }
  function tt(u) {
    return t.toByteArray(wt(u));
  }
  function ge(u, i, o, p) {
    for (var E = 0; E < p && !(E + o >= i.length || E >= u.length); ++E)
      i[E + o] = u[E];
    return E;
  }
  function fe(u, i) {
    return u instanceof i || u != null && u.constructor != null && u.constructor.name != null && u.constructor.name === i.name;
  }
  function je(u) {
    return u !== u;
  }
  var ue = function() {
    for (var u = "0123456789abcdef", i = new Array(256), o = 0; o < 16; ++o)
      for (var p = o * 16, E = 0; E < 16; ++E)
        i[p + E] = u[o] + u[E];
    return i;
  }();
})(ai);
class On extends Ln {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(t, e, r, s) {
    super(
      `Object ${t} ${s ? `at ${s}` : ""}was anticipated to be a ${r} but it is a ${e}.`
    ), this.code = this.name = On.code, this.data = { oid: t, actual: e, expected: r, filepath: s };
  }
}
On.code = "ObjectTypeError";
typeof window < "u" && (window.Buffer = ai.Buffer);
const li = function() {
  return typeof process < "u" && process.release?.name === "node" ? "NODE" : typeof window < "u" ? "WEB" : (
    // @ts-ignore
    typeof WorkerGlobalScope < "u" && // @ts-ignore
    self instanceof WorkerGlobalScope ? "WORKER" : "NODE"
  );
}();
if (li === "NODE") {
  let n = function(e) {
    return new Promise(function(r, s) {
      e.onload = e.onerror = function(a) {
        e.onload = e.onerror = null, a.type === "load" ? r(e.result) : s(new Error("Failed to read the blob/file"));
      };
    });
  }, t = function() {
    const e = new Uint8Array([1, 2, 3, 4]), s = new File([e], "test").stream();
    try {
      return s.getReader({ mode: "byob" }), !0;
    } catch {
      return !1;
    }
  };
  if (typeof File > "u") {
    class e extends Blob {
      constructor(s, a, c) {
        super(s);
        let l;
        c?.lastModified && (l = /* @__PURE__ */ new Date()), (!l || isNaN(l.getFullYear())) && (l = /* @__PURE__ */ new Date()), this.lastModifiedDate = l, this.lastModified = l.getMilliseconds(), this.name = a || "";
      }
    }
    global.File = e;
  }
  typeof Blob.prototype.arrayBuffer > "u" && (Blob.prototype.arrayBuffer = function() {
    const r = new FileReader();
    return r.readAsArrayBuffer(this), n(r);
  }), typeof Blob.prototype.text > "u" && (Blob.prototype.text = function() {
    const r = new FileReader();
    return r.readAsText(this), n(r);
  }), (typeof Blob.prototype.stream > "u" || !t()) && (Blob.prototype.stream = function() {
    let e = 0;
    const r = this;
    return new ReadableStream({
      type: "bytes",
      // 0.5 MB seems like a reasonable chunk size, let's adjust
      // this if needed.
      autoAllocateChunkSize: 512 * 1024,
      async pull(s) {
        const a = s.byobRequest.view, l = await r.slice(
          e,
          e + a.byteLength
        ).arrayBuffer(), f = new Uint8Array(l);
        new Uint8Array(a.buffer).set(f);
        const _ = f.byteLength;
        s.byobRequest.respond(_), e += _, e >= r.size && s.close();
      }
    });
  });
}
if (li === "NODE" && typeof CustomEvent > "u") {
  class n extends Event {
    constructor(e, r = {}) {
      super(e, r), this.detail = r.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = n;
}
function Ns(...n) {
  const t = new Uint8Array(
    n.reduce((r, s) => r + s.length, 0)
  );
  let e = 0;
  for (const r of n)
    t.set(r, e), e += r.length;
  return t;
}
function qs(n) {
  {
    let t = new Uint8Array();
    return new TransformStream({
      transform(e) {
        t = Ns(t, e);
      },
      flush(e) {
        e.enqueue(t);
      }
    });
  }
}
async function js(n, t) {
  return await n.pipeThrough(qs()).getReader().read().then(({ value: e }) => e);
}
class Vt extends File {
  /**
   * Creates a new StreamedFile instance.
   *
   * @param readableStream The readable stream containing the file data.
   * @param name The name of the file.
   * @param options An object containing options such as the MIME type and file size.
   */
  constructor(t, e, r) {
    super([], e, { type: r?.type }), this.readableStream = t, this.filesize = r?.filesize;
  }
  /**
   * Overrides the slice() method of the File class.
   *
   * @returns A Blob representing a portion of the file.
   */
  slice() {
    throw new Error("slice() is not possible on a StreamedFile");
  }
  /**
   * Returns the readable stream associated with the file.
   *
   * @returns The readable stream.
   */
  stream() {
    return this.readableStream;
  }
  /**
   * Loads the file data into memory and then returns it as a string.
   *
   * @returns File data as text.
   */
  async text() {
    return new TextDecoder().decode(await this.arrayBuffer());
  }
  /**
   * Loads the file data into memory and then returns it as an ArrayBuffer.
   *
   * @returns File data as an ArrayBuffer.
   */
  async arrayBuffer() {
    return await js(this.stream());
  }
}
ReadableStream.prototype[Symbol.asyncIterator] || (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
  const n = this.getReader();
  try {
    for (; ; ) {
      const { done: t, value: e } = await n.read();
      if (t)
        return;
      yield e;
    }
  } finally {
    n.releaseLock();
  }
}, ReadableStream.prototype.iterate = // @ts-ignore
ReadableStream.prototype[Symbol.asyncIterator]);
new Dn({ concurrency: 10 });
const St = 15, kn = 30, Sn = 19, Hs = 29, Gt = 256, Bn = Gt + 1 + Hs, Xn = 2 * Bn + 1, _t = 256, $s = 7, zn = 16, Jn = 17, Qn = 18, an = 8 * 2, Kt = -1, Ys = 1, Pt = 2, Zs = 0, dt = 0, er = 1, Vs = 3, Se = 4, Ue = 0, fi = 1, Dt = 2, Oe = -2, Gs = -3, lt = -5;
function tn(n) {
  return nn(n.map(([t, e]) => new Array(t).fill(e, 0, t)));
}
function nn(n) {
  return n.reduce((t, e) => t.concat(Array.isArray(e) ? nn(e) : e), []);
}
const tr = [0, 1, 2, 3].concat(...tn([
  [2, 4],
  [2, 5],
  [4, 6],
  [4, 7],
  [8, 8],
  [8, 9],
  [16, 10],
  [16, 11],
  [32, 12],
  [32, 13],
  [64, 14],
  [64, 15],
  [2, 0],
  [1, 16],
  [1, 17],
  [2, 18],
  [2, 19],
  [4, 20],
  [4, 21],
  [8, 22],
  [8, 23],
  [16, 24],
  [16, 25],
  [32, 26],
  [32, 27],
  [64, 28],
  [64, 29]
]));
function ie() {
  const n = this;
  function t(s) {
    const a = n.dyn_tree, c = n.stat_desc.static_tree, l = n.stat_desc.extra_bits, f = n.stat_desc.extra_base, _ = n.stat_desc.max_length;
    let x, w, g, k, P, m, d = 0;
    for (k = 0; k <= St; k++)
      s.bl_count[k] = 0;
    for (a[s.heap[s.heap_max] * 2 + 1] = 0, x = s.heap_max + 1; x < Xn; x++)
      w = s.heap[x], k = a[a[w * 2 + 1] * 2 + 1] + 1, k > _ && (k = _, d++), a[w * 2 + 1] = k, !(w > n.max_code) && (s.bl_count[k]++, P = 0, w >= f && (P = l[w - f]), m = a[w * 2], s.opt_len += m * (k + P), c && (s.static_len += m * (c[w * 2 + 1] + P)));
    if (d !== 0) {
      do {
        for (k = _ - 1; s.bl_count[k] === 0; )
          k--;
        s.bl_count[k]--, s.bl_count[k + 1] += 2, s.bl_count[_]--, d -= 2;
      } while (d > 0);
      for (k = _; k !== 0; k--)
        for (w = s.bl_count[k]; w !== 0; )
          g = s.heap[--x], !(g > n.max_code) && (a[g * 2 + 1] != k && (s.opt_len += (k - a[g * 2 + 1]) * a[g * 2], a[g * 2 + 1] = k), w--);
    }
  }
  function e(s, a) {
    let c = 0;
    do
      c |= s & 1, s >>>= 1, c <<= 1;
    while (--a > 0);
    return c >>> 1;
  }
  function r(s, a, c) {
    const l = [];
    let f = 0, _, x, w;
    for (_ = 1; _ <= St; _++)
      l[_] = f = f + c[_ - 1] << 1;
    for (x = 0; x <= a; x++)
      w = s[x * 2 + 1], w !== 0 && (s[x * 2] = e(l[w]++, w));
  }
  n.build_tree = function(s) {
    const a = n.dyn_tree, c = n.stat_desc.static_tree, l = n.stat_desc.elems;
    let f, _, x = -1, w;
    for (s.heap_len = 0, s.heap_max = Xn, f = 0; f < l; f++)
      a[f * 2] !== 0 ? (s.heap[++s.heap_len] = x = f, s.depth[f] = 0) : a[f * 2 + 1] = 0;
    for (; s.heap_len < 2; )
      w = s.heap[++s.heap_len] = x < 2 ? ++x : 0, a[w * 2] = 1, s.depth[w] = 0, s.opt_len--, c && (s.static_len -= c[w * 2 + 1]);
    for (n.max_code = x, f = Math.floor(s.heap_len / 2); f >= 1; f--)
      s.pqdownheap(a, f);
    w = l;
    do
      f = s.heap[1], s.heap[1] = s.heap[s.heap_len--], s.pqdownheap(a, 1), _ = s.heap[1], s.heap[--s.heap_max] = f, s.heap[--s.heap_max] = _, a[w * 2] = a[f * 2] + a[_ * 2], s.depth[w] = Math.max(s.depth[f], s.depth[_]) + 1, a[f * 2 + 1] = a[_ * 2 + 1] = w, s.heap[1] = w++, s.pqdownheap(a, 1);
    while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1], t(s), r(a, n.max_code, s.bl_count);
  };
}
ie._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...tn([
  [2, 8],
  [2, 9],
  [2, 10],
  [2, 11],
  [4, 12],
  [4, 13],
  [4, 14],
  [4, 15],
  [8, 16],
  [8, 17],
  [8, 18],
  [8, 19],
  [16, 20],
  [16, 21],
  [16, 22],
  [16, 23],
  [32, 24],
  [32, 25],
  [32, 26],
  [31, 27],
  [1, 28]
]));
ie.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
ie.base_dist = [
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
];
ie.d_code = function(n) {
  return n < 256 ? tr[n] : tr[256 + (n >>> 7)];
};
ie.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
ie.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
ie.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
ie.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
function we(n, t, e, r, s) {
  const a = this;
  a.static_tree = n, a.extra_bits = t, a.extra_base = e, a.elems = r, a.max_length = s;
}
const Ks = [
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  19,
  275,
  147,
  403,
  83,
  339,
  211,
  467,
  51,
  307,
  179,
  435,
  115,
  371,
  243,
  499,
  11,
  267,
  139,
  395,
  75,
  331,
  203,
  459,
  43,
  299,
  171,
  427,
  107,
  363,
  235,
  491,
  27,
  283,
  155,
  411,
  91,
  347,
  219,
  475,
  59,
  315,
  187,
  443,
  123,
  379,
  251,
  507,
  7,
  263,
  135,
  391,
  71,
  327,
  199,
  455,
  39,
  295,
  167,
  423,
  103,
  359,
  231,
  487,
  23,
  279,
  151,
  407,
  87,
  343,
  215,
  471,
  55,
  311,
  183,
  439,
  119,
  375,
  247,
  503,
  15,
  271,
  143,
  399,
  79,
  335,
  207,
  463,
  47,
  303,
  175,
  431,
  111,
  367,
  239,
  495,
  31,
  287,
  159,
  415,
  95,
  351,
  223,
  479,
  63,
  319,
  191,
  447,
  127,
  383,
  255,
  511,
  0,
  64,
  32,
  96,
  16,
  80,
  48,
  112,
  8,
  72,
  40,
  104,
  24,
  88,
  56,
  120,
  4,
  68,
  36,
  100,
  20,
  84,
  52,
  116,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227
], Xs = tn([[144, 8], [112, 9], [24, 7], [8, 8]]);
we.static_ltree = nn(Ks.map((n, t) => [n, Xs[t]]));
const zs = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23], Js = tn([[30, 5]]);
we.static_dtree = nn(zs.map((n, t) => [n, Js[t]]));
we.static_l_desc = new we(we.static_ltree, ie.extra_lbits, Gt + 1, Bn, St);
we.static_d_desc = new we(we.static_dtree, ie.extra_dbits, 0, kn, St);
we.static_bl_desc = new we(null, ie.extra_blbits, 0, Sn, $s);
const Qs = 9, eo = 8;
function Be(n, t, e, r, s) {
  const a = this;
  a.good_length = n, a.max_lazy = t, a.nice_length = e, a.max_chain = r, a.func = s;
}
const ui = 0, jt = 1, rt = 2, Le = [
  new Be(0, 0, 0, 0, ui),
  new Be(4, 4, 8, 4, jt),
  new Be(4, 5, 16, 8, jt),
  new Be(4, 6, 32, 32, jt),
  new Be(4, 4, 16, 16, rt),
  new Be(8, 16, 32, 32, rt),
  new Be(8, 16, 128, 128, rt),
  new Be(8, 32, 128, 256, rt),
  new Be(32, 128, 258, 1024, rt),
  new Be(32, 258, 258, 4096, rt)
], Lt = [
  "need dictionary",
  // Z_NEED_DICT
  // 2
  "stream end",
  // Z_STREAM_END 1
  "",
  // Z_OK 0
  "",
  // Z_ERRNO (-1)
  "stream error",
  // Z_STREAM_ERROR (-2)
  "data error",
  // Z_DATA_ERROR (-3)
  "",
  // Z_MEM_ERROR (-4)
  "buffer error",
  // Z_BUF_ERROR (-5)
  "",
  // Z_VERSION_ERROR (-6)
  ""
], Fe = 0, Ut = 1, yt = 2, Ot = 3, to = 32, cn = 42, Bt = 113, bt = 666, ln = 8, no = 0, fn = 1, ro = 2, ae = 3, Ht = 258, Te = Ht + ae + 1;
function nr(n, t, e, r) {
  const s = n[t * 2], a = n[e * 2];
  return s < a || s == a && r[t] <= r[e];
}
function io() {
  const n = this;
  let t, e, r, s, a, c, l, f, _, x, w, g, k, P, m, d, h, y, T, D, A, R, F, b, C, v, S, M, L, Y, H, j, K;
  const V = new ie(), oe = new ie(), Z = new ie();
  n.depth = [];
  let J, $, ee, Pe, de, le;
  n.bl_count = [], n.heap = [], H = [], j = [], K = [];
  function wt() {
    _ = 2 * a, w[k - 1] = 0;
    for (let I = 0; I < k - 1; I++)
      w[I] = 0;
    v = Le[S].max_lazy, L = Le[S].good_length, Y = Le[S].nice_length, C = Le[S].max_chain, A = 0, h = 0, F = 0, y = b = ae - 1, D = 0, g = 0;
  }
  function qe() {
    let I;
    for (I = 0; I < Bn; I++)
      H[I * 2] = 0;
    for (I = 0; I < kn; I++)
      j[I * 2] = 0;
    for (I = 0; I < Sn; I++)
      K[I * 2] = 0;
    H[_t * 2] = 1, n.opt_len = n.static_len = 0, $ = ee = 0;
  }
  function at() {
    V.dyn_tree = H, V.stat_desc = we.static_l_desc, oe.dyn_tree = j, oe.stat_desc = we.static_d_desc, Z.dyn_tree = K, Z.stat_desc = we.static_bl_desc, de = 0, le = 0, Pe = 8, qe();
  }
  n.pqdownheap = function(I, B) {
    const O = n.heap, N = O[B];
    let q = B << 1;
    for (; q <= n.heap_len && (q < n.heap_len && nr(I, O[q + 1], O[q], n.depth) && q++, !nr(I, N, O[q], n.depth)); )
      O[B] = O[q], B = q, q <<= 1;
    O[B] = N;
  };
  function et(I, B) {
    let O = -1, N, q = I[0 * 2 + 1], G = 0, z = 7, be = 4;
    q === 0 && (z = 138, be = 3), I[(B + 1) * 2 + 1] = 65535;
    for (let De = 0; De <= B; De++)
      N = q, q = I[(De + 1) * 2 + 1], !(++G < z && N == q) && (G < be ? K[N * 2] += G : N !== 0 ? (N != O && K[N * 2]++, K[zn * 2]++) : G <= 10 ? K[Jn * 2]++ : K[Qn * 2]++, G = 0, O = N, q === 0 ? (z = 138, be = 3) : N == q ? (z = 6, be = 3) : (z = 7, be = 4));
  }
  function tt() {
    let I;
    for (et(H, V.max_code), et(j, oe.max_code), Z.build_tree(n), I = Sn - 1; I >= 3 && K[ie.bl_order[I] * 2 + 1] === 0; I--)
      ;
    return n.opt_len += 3 * (I + 1) + 5 + 5 + 4, I;
  }
  function ge(I) {
    n.pending_buf[n.pending++] = I;
  }
  function fe(I) {
    ge(I & 255), ge(I >>> 8 & 255);
  }
  function je(I) {
    ge(I >> 8 & 255), ge(I & 255 & 255);
  }
  function ue(I, B) {
    let O;
    const N = B;
    le > an - N ? (O = I, de |= O << le & 65535, fe(de), de = O >>> an - le, le += N - an) : (de |= I << le & 65535, le += N);
  }
  function u(I, B) {
    const O = I * 2;
    ue(B[O] & 65535, B[O + 1] & 65535);
  }
  function i(I, B) {
    let O, N = -1, q, G = I[0 * 2 + 1], z = 0, be = 7, De = 4;
    for (G === 0 && (be = 138, De = 3), O = 0; O <= B; O++)
      if (q = G, G = I[(O + 1) * 2 + 1], !(++z < be && q == G)) {
        if (z < De)
          do
            u(q, K);
          while (--z !== 0);
        else q !== 0 ? (q != N && (u(q, K), z--), u(zn, K), ue(z - 3, 2)) : z <= 10 ? (u(Jn, K), ue(z - 3, 3)) : (u(Qn, K), ue(z - 11, 7));
        z = 0, N = q, G === 0 ? (be = 138, De = 3) : q == G ? (be = 6, De = 3) : (be = 7, De = 4);
      }
  }
  function o(I, B, O) {
    let N;
    for (ue(I - 257, 5), ue(B - 1, 5), ue(O - 4, 4), N = 0; N < O; N++)
      ue(K[ie.bl_order[N] * 2 + 1], 3);
    i(H, I - 1), i(j, B - 1);
  }
  function p() {
    le == 16 ? (fe(de), de = 0, le = 0) : le >= 8 && (ge(de & 255), de >>>= 8, le -= 8);
  }
  function E() {
    ue(fn << 1, 3), u(_t, we.static_ltree), p(), 1 + Pe + 10 - le < 9 && (ue(fn << 1, 3), u(_t, we.static_ltree), p()), Pe = 7;
  }
  function U(I, B) {
    let O, N, q;
    if (n.dist_buf[$] = I, n.lc_buf[$] = B & 255, $++, I === 0 ? H[B * 2]++ : (ee++, I--, H[(ie._length_code[B] + Gt + 1) * 2]++, j[ie.d_code(I) * 2]++), !($ & 8191) && S > 2) {
      for (O = $ * 8, N = A - h, q = 0; q < kn; q++)
        O += j[q * 2] * (5 + ie.extra_dbits[q]);
      if (O >>>= 3, ee < Math.floor($ / 2) && O < Math.floor(N / 2))
        return !0;
    }
    return $ == J - 1;
  }
  function W(I, B) {
    let O, N, q = 0, G, z;
    if ($ !== 0)
      do
        O = n.dist_buf[q], N = n.lc_buf[q], q++, O === 0 ? u(N, I) : (G = ie._length_code[N], u(G + Gt + 1, I), z = ie.extra_lbits[G], z !== 0 && (N -= ie.base_length[G], ue(N, z)), O--, G = ie.d_code(O), u(G, B), z = ie.extra_dbits[G], z !== 0 && (O -= ie.base_dist[G], ue(O, z)));
      while (q < $);
    u(_t, I), Pe = I[_t * 2 + 1];
  }
  function X() {
    le > 8 ? fe(de) : le > 0 && ge(de & 255), de = 0, le = 0;
  }
  function ne(I, B, O) {
    X(), Pe = 8, fe(B), fe(~B), n.pending_buf.set(f.subarray(I, I + B), n.pending), n.pending += B;
  }
  function re(I, B, O) {
    ue((no << 1) + (O ? 1 : 0), 3), ne(I, B);
  }
  function pe(I, B, O) {
    let N, q, G = 0;
    S > 0 ? (V.build_tree(n), oe.build_tree(n), G = tt(), N = n.opt_len + 3 + 7 >>> 3, q = n.static_len + 3 + 7 >>> 3, q <= N && (N = q)) : N = q = B + 5, B + 4 <= N && I != -1 ? re(I, B, O) : q == N ? (ue((fn << 1) + (O ? 1 : 0), 3), W(we.static_ltree, we.static_dtree)) : (ue((ro << 1) + (O ? 1 : 0), 3), o(V.max_code + 1, oe.max_code + 1, G + 1), W(H, j)), qe(), O && X();
  }
  function te(I) {
    pe(h >= 0 ? h : -1, A - h, I), h = A, t.flush_pending();
  }
  function Ye() {
    let I, B, O, N;
    do {
      if (N = _ - F - A, N === 0 && A === 0 && F === 0)
        N = a;
      else if (N == -1)
        N--;
      else if (A >= a + a - Te) {
        f.set(f.subarray(a, a + a), 0), R -= a, A -= a, h -= a, I = k, O = I;
        do
          B = w[--O] & 65535, w[O] = B >= a ? B - a : 0;
        while (--I !== 0);
        I = a, O = I;
        do
          B = x[--O] & 65535, x[O] = B >= a ? B - a : 0;
        while (--I !== 0);
        N += a;
      }
      if (t.avail_in === 0)
        return;
      I = t.read_buf(f, A + F, N), F += I, F >= ae && (g = f[A] & 255, g = (g << d ^ f[A + 1] & 255) & m);
    } while (F < Te && t.avail_in !== 0);
  }
  function It(I) {
    let B = 65535, O;
    for (B > r - 5 && (B = r - 5); ; ) {
      if (F <= 1) {
        if (Ye(), F === 0 && I == dt)
          return Fe;
        if (F === 0)
          break;
      }
      if (A += F, F = 0, O = h + B, (A === 0 || A >= O) && (F = A - O, A = O, te(!1), t.avail_out === 0) || A - h >= a - Te && (te(!1), t.avail_out === 0))
        return Fe;
    }
    return te(I == Se), t.avail_out === 0 ? I == Se ? yt : Fe : I == Se ? Ot : Ut;
  }
  function gt(I) {
    let B = C, O = A, N, q, G = b;
    const z = A > a - Te ? A - (a - Te) : 0;
    let be = Y;
    const De = l, sn = A + Ht;
    let Hn = f[O + G - 1], $n = f[O + G];
    b >= L && (B >>= 2), be > F && (be = F);
    do
      if (N = I, !(f[N + G] != $n || f[N + G - 1] != Hn || f[N] != f[O] || f[++N] != f[O + 1])) {
        O += 2, N++;
        do
          ;
        while (f[++O] == f[++N] && f[++O] == f[++N] && f[++O] == f[++N] && f[++O] == f[++N] && f[++O] == f[++N] && f[++O] == f[++N] && f[++O] == f[++N] && f[++O] == f[++N] && O < sn);
        if (q = Ht - (sn - O), O = sn - Ht, q > G) {
          if (R = I, G = q, q >= be)
            break;
          Hn = f[O + G - 1], $n = f[O + G];
        }
      }
    while ((I = x[I & De] & 65535) > z && --B !== 0);
    return G <= F ? G : F;
  }
  function Qi(I) {
    let B = 0, O;
    for (; ; ) {
      if (F < Te) {
        if (Ye(), F < Te && I == dt)
          return Fe;
        if (F === 0)
          break;
      }
      if (F >= ae && (g = (g << d ^ f[A + (ae - 1)] & 255) & m, B = w[g] & 65535, x[A & l] = w[g], w[g] = A), B !== 0 && (A - B & 65535) <= a - Te && M != Pt && (y = gt(B)), y >= ae)
        if (O = U(A - R, y - ae), F -= y, y <= v && F >= ae) {
          y--;
          do
            A++, g = (g << d ^ f[A + (ae - 1)] & 255) & m, B = w[g] & 65535, x[A & l] = w[g], w[g] = A;
          while (--y !== 0);
          A++;
        } else
          A += y, y = 0, g = f[A] & 255, g = (g << d ^ f[A + 1] & 255) & m;
      else
        O = U(0, f[A] & 255), F--, A++;
      if (O && (te(!1), t.avail_out === 0))
        return Fe;
    }
    return te(I == Se), t.avail_out === 0 ? I == Se ? yt : Fe : I == Se ? Ot : Ut;
  }
  function es(I) {
    let B = 0, O, N;
    for (; ; ) {
      if (F < Te) {
        if (Ye(), F < Te && I == dt)
          return Fe;
        if (F === 0)
          break;
      }
      if (F >= ae && (g = (g << d ^ f[A + (ae - 1)] & 255) & m, B = w[g] & 65535, x[A & l] = w[g], w[g] = A), b = y, T = R, y = ae - 1, B !== 0 && b < v && (A - B & 65535) <= a - Te && (M != Pt && (y = gt(B)), y <= 5 && (M == Ys || y == ae && A - R > 4096) && (y = ae - 1)), b >= ae && y <= b) {
        N = A + F - ae, O = U(A - 1 - T, b - ae), F -= b - 1, b -= 2;
        do
          ++A <= N && (g = (g << d ^ f[A + (ae - 1)] & 255) & m, B = w[g] & 65535, x[A & l] = w[g], w[g] = A);
        while (--b !== 0);
        if (D = 0, y = ae - 1, A++, O && (te(!1), t.avail_out === 0))
          return Fe;
      } else if (D !== 0) {
        if (O = U(0, f[A - 1] & 255), O && te(!1), A++, F--, t.avail_out === 0)
          return Fe;
      } else
        D = 1, A++, F--;
    }
    return D !== 0 && (O = U(0, f[A - 1] & 255), D = 0), te(I == Se), t.avail_out === 0 ? I == Se ? yt : Fe : I == Se ? Ot : Ut;
  }
  function ts(I) {
    return I.total_in = I.total_out = 0, I.msg = null, n.pending = 0, n.pending_out = 0, e = Bt, s = dt, at(), wt(), Ue;
  }
  n.deflateInit = function(I, B, O, N, q, G) {
    return N || (N = ln), q || (q = eo), G || (G = Zs), I.msg = null, B == Kt && (B = 6), q < 1 || q > Qs || N != ln || O < 9 || O > 15 || B < 0 || B > 9 || G < 0 || G > Pt ? Oe : (I.dstate = n, c = O, a = 1 << c, l = a - 1, P = q + 7, k = 1 << P, m = k - 1, d = Math.floor((P + ae - 1) / ae), f = new Uint8Array(a * 2), x = [], w = [], J = 1 << q + 6, n.pending_buf = new Uint8Array(J * 4), r = J * 4, n.dist_buf = new Uint16Array(J), n.lc_buf = new Uint8Array(J), S = B, M = G, ts(I));
  }, n.deflateEnd = function() {
    return e != cn && e != Bt && e != bt ? Oe : (n.lc_buf = null, n.dist_buf = null, n.pending_buf = null, w = null, x = null, f = null, n.dstate = null, e == Bt ? Gs : Ue);
  }, n.deflateParams = function(I, B, O) {
    let N = Ue;
    return B == Kt && (B = 6), B < 0 || B > 9 || O < 0 || O > Pt ? Oe : (Le[S].func != Le[B].func && I.total_in !== 0 && (N = I.deflate(er)), S != B && (S = B, v = Le[S].max_lazy, L = Le[S].good_length, Y = Le[S].nice_length, C = Le[S].max_chain), M = O, N);
  }, n.deflateSetDictionary = function(I, B, O) {
    let N = O, q, G = 0;
    if (!B || e != cn)
      return Oe;
    if (N < ae)
      return Ue;
    for (N > a - Te && (N = a - Te, G = O - N), f.set(B.subarray(G, G + N), 0), A = N, h = N, g = f[0] & 255, g = (g << d ^ f[1] & 255) & m, q = 0; q <= N - ae; q++)
      g = (g << d ^ f[q + (ae - 1)] & 255) & m, x[q & l] = w[g], w[g] = q;
    return Ue;
  }, n.deflate = function(I, B) {
    let O, N, q, G, z;
    if (B > Se || B < 0)
      return Oe;
    if (!I.next_out || !I.next_in && I.avail_in !== 0 || e == bt && B != Se)
      return I.msg = Lt[Dt - Oe], Oe;
    if (I.avail_out === 0)
      return I.msg = Lt[Dt - lt], lt;
    if (t = I, G = s, s = B, e == cn && (N = ln + (c - 8 << 4) << 8, q = (S - 1 & 255) >> 1, q > 3 && (q = 3), N |= q << 6, A !== 0 && (N |= to), N += 31 - N % 31, e = Bt, je(N)), n.pending !== 0) {
      if (t.flush_pending(), t.avail_out === 0)
        return s = -1, Ue;
    } else if (t.avail_in === 0 && B <= G && B != Se)
      return t.msg = Lt[Dt - lt], lt;
    if (e == bt && t.avail_in !== 0)
      return I.msg = Lt[Dt - lt], lt;
    if (t.avail_in !== 0 || F !== 0 || B != dt && e != bt) {
      switch (z = -1, Le[S].func) {
        case ui:
          z = It(B);
          break;
        case jt:
          z = Qi(B);
          break;
        case rt:
          z = es(B);
          break;
      }
      if ((z == yt || z == Ot) && (e = bt), z == Fe || z == yt)
        return t.avail_out === 0 && (s = -1), Ue;
      if (z == Ut) {
        if (B == er)
          E();
        else if (re(0, 0, !1), B == Vs)
          for (O = 0; O < k; O++)
            w[O] = 0;
        if (t.flush_pending(), t.avail_out === 0)
          return s = -1, Ue;
      }
    }
    return B != Se ? Ue : fi;
  };
}
function di() {
  const n = this;
  n.next_in_index = 0, n.next_out_index = 0, n.avail_in = 0, n.total_in = 0, n.avail_out = 0, n.total_out = 0;
}
di.prototype = {
  deflateInit(n, t) {
    const e = this;
    return e.dstate = new io(), t || (t = St), e.dstate.deflateInit(e, n, t);
  },
  deflate(n) {
    const t = this;
    return t.dstate ? t.dstate.deflate(t, n) : Oe;
  },
  deflateEnd() {
    const n = this;
    if (!n.dstate)
      return Oe;
    const t = n.dstate.deflateEnd();
    return n.dstate = null, t;
  },
  deflateParams(n, t) {
    const e = this;
    return e.dstate ? e.dstate.deflateParams(e, n, t) : Oe;
  },
  deflateSetDictionary(n, t) {
    const e = this;
    return e.dstate ? e.dstate.deflateSetDictionary(e, n, t) : Oe;
  },
  // Read a new buffer from the current input stream, update the
  // total number of bytes read. All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  read_buf(n, t, e) {
    const r = this;
    let s = r.avail_in;
    return s > e && (s = e), s === 0 ? 0 : (r.avail_in -= s, n.set(r.next_in.subarray(r.next_in_index, r.next_in_index + s), t), r.next_in_index += s, r.total_in += s, s);
  },
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  flush_pending() {
    const n = this;
    let t = n.dstate.pending;
    t > n.avail_out && (t = n.avail_out), t !== 0 && (n.next_out.set(n.dstate.pending_buf.subarray(n.dstate.pending_out, n.dstate.pending_out + t), n.next_out_index), n.next_out_index += t, n.dstate.pending_out += t, n.total_out += t, n.avail_out -= t, n.dstate.pending -= t, n.dstate.pending === 0 && (n.dstate.pending_out = 0));
  }
};
function so(n) {
  const t = this, e = new di(), r = oo(n && n.chunkSize ? n.chunkSize : 64 * 1024), s = dt, a = new Uint8Array(r);
  let c = n ? n.level : Kt;
  typeof c > "u" && (c = Kt), e.deflateInit(c), e.next_out = a, t.append = function(l, f) {
    let _, x, w = 0, g = 0, k = 0;
    const P = [];
    if (l.length) {
      e.next_in_index = 0, e.next_in = l, e.avail_in = l.length;
      do {
        if (e.next_out_index = 0, e.avail_out = r, _ = e.deflate(s), _ != Ue)
          throw new Error("deflating: " + e.msg);
        e.next_out_index && (e.next_out_index == r ? P.push(new Uint8Array(a)) : P.push(a.subarray(0, e.next_out_index))), k += e.next_out_index, f && e.next_in_index > 0 && e.next_in_index != w && (f(e.next_in_index), w = e.next_in_index);
      } while (e.avail_in > 0 || e.avail_out === 0);
      return P.length > 1 ? (x = new Uint8Array(k), P.forEach(function(m) {
        x.set(m, g), g += m.length;
      })) : x = P[0] ? new Uint8Array(P[0]) : new Uint8Array(), x;
    }
  }, t.flush = function() {
    let l, f, _ = 0, x = 0;
    const w = [];
    do {
      if (e.next_out_index = 0, e.avail_out = r, l = e.deflate(Se), l != fi && l != Ue)
        throw new Error("deflating: " + e.msg);
      r - e.avail_out > 0 && w.push(a.slice(0, e.next_out_index)), x += e.next_out_index;
    } while (e.avail_in > 0 || e.avail_out === 0);
    return e.deflateEnd(), f = new Uint8Array(x), w.forEach(function(g) {
      f.set(g, _), _ += g.length;
    }), f;
  };
}
function oo(n) {
  return n + 5 * (Math.floor(n / 16383) + 1);
}
const ao = 15, Q = 0, He = 1, co = 2, Ae = -2, se = -3, rr = -4, $e = -5, Re = [
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
], pi = 1440, lo = 0, fo = 4, uo = 9, po = 5, mo = [
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  192,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  160,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  224,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  144,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  208,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  176,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  240,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  200,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  168,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  232,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  152,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  216,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  184,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  248,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  196,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  164,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  228,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  148,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  212,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  180,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  244,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  204,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  172,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  236,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  156,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  220,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  188,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  252,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  194,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  162,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  226,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  146,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  210,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  178,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  242,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  202,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  170,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  234,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  154,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  218,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  186,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  250,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  198,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  166,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  230,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  150,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  214,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  182,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  246,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  206,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  174,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  238,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  158,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  222,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  190,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  254,
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  193,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  161,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  225,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  145,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  209,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  177,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  241,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  201,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  169,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  233,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  153,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  217,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  185,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  249,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  197,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  165,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  229,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  149,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  213,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  181,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  245,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  205,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  173,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  237,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  157,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  221,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  189,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  253,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  195,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  163,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  227,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  147,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  211,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  179,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  243,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  203,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  171,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  235,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  155,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  219,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  187,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  251,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  199,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  167,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  231,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  151,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  215,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  183,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  247,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  207,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  175,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  239,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  159,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  223,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  191,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  255
], ho = [
  80,
  5,
  1,
  87,
  5,
  257,
  83,
  5,
  17,
  91,
  5,
  4097,
  81,
  5,
  5,
  89,
  5,
  1025,
  85,
  5,
  65,
  93,
  5,
  16385,
  80,
  5,
  3,
  88,
  5,
  513,
  84,
  5,
  33,
  92,
  5,
  8193,
  82,
  5,
  9,
  90,
  5,
  2049,
  86,
  5,
  129,
  192,
  5,
  24577,
  80,
  5,
  2,
  87,
  5,
  385,
  83,
  5,
  25,
  91,
  5,
  6145,
  81,
  5,
  7,
  89,
  5,
  1537,
  85,
  5,
  97,
  93,
  5,
  24577,
  80,
  5,
  4,
  88,
  5,
  769,
  84,
  5,
  49,
  92,
  5,
  12289,
  82,
  5,
  13,
  90,
  5,
  3073,
  86,
  5,
  193,
  192,
  5,
  24577
], xo = [
  // Copy lengths for literal codes 257..285
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
], wo = [
  // Extra bits for literal codes 257..285
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112
  // 112==invalid
], go = [
  // Copy offsets for distance codes 0..29
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
], _o = [
  // Extra bits for distance codes
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
], Ze = 15;
function An() {
  const n = this;
  let t, e, r, s, a, c;
  function l(_, x, w, g, k, P, m, d, h, y, T) {
    let D, A, R, F, b, C, v, S, M, L, Y, H, j, K, V;
    L = 0, b = w;
    do
      r[_[x + L]]++, L++, b--;
    while (b !== 0);
    if (r[0] == w)
      return m[0] = -1, d[0] = 0, Q;
    for (S = d[0], C = 1; C <= Ze && r[C] === 0; C++)
      ;
    for (v = C, S < C && (S = C), b = Ze; b !== 0 && r[b] === 0; b--)
      ;
    for (R = b, S > b && (S = b), d[0] = S, K = 1 << C; C < b; C++, K <<= 1)
      if ((K -= r[C]) < 0)
        return se;
    if ((K -= r[b]) < 0)
      return se;
    for (r[b] += K, c[1] = C = 0, L = 1, j = 2; --b !== 0; )
      c[j] = C += r[L], j++, L++;
    b = 0, L = 0;
    do
      (C = _[x + L]) !== 0 && (T[c[C]++] = b), L++;
    while (++b < w);
    for (w = c[R], c[0] = b = 0, L = 0, F = -1, H = -S, a[0] = 0, Y = 0, V = 0; v <= R; v++)
      for (D = r[v]; D-- !== 0; ) {
        for (; v > H + S; ) {
          if (F++, H += S, V = R - H, V = V > S ? S : V, (A = 1 << (C = v - H)) > D + 1 && (A -= D + 1, j = v, C < V))
            for (; ++C < V && !((A <<= 1) <= r[++j]); )
              A -= r[j];
          if (V = 1 << C, y[0] + V > pi)
            return se;
          a[F] = Y = /* hp+ */
          y[0], y[0] += V, F !== 0 ? (c[F] = b, s[0] = /* (byte) */
          C, s[1] = /* (byte) */
          S, C = b >>> H - S, s[2] = /* (int) */
          Y - a[F - 1] - C, h.set(s, (a[F - 1] + C) * 3)) : m[0] = Y;
        }
        for (s[1] = /* (byte) */
        v - H, L >= w ? s[0] = 192 : T[L] < g ? (s[0] = /* (byte) */
        T[L] < 256 ? 0 : 96, s[2] = T[L++]) : (s[0] = /* (byte) */
        P[T[L] - g] + 16 + 64, s[2] = k[T[L++] - g]), A = 1 << v - H, C = b >>> H; C < V; C += A)
          h.set(s, (Y + C) * 3);
        for (C = 1 << v - 1; b & C; C >>>= 1)
          b ^= C;
        for (b ^= C, M = (1 << H) - 1; (b & M) != c[F]; )
          F--, H -= S, M = (1 << H) - 1;
      }
    return K !== 0 && R != 1 ? $e : Q;
  }
  function f(_) {
    let x;
    for (t || (t = [], e = [], r = new Int32Array(Ze + 1), s = [], a = new Int32Array(Ze), c = new Int32Array(Ze + 1)), e.length < _ && (e = []), x = 0; x < _; x++)
      e[x] = 0;
    for (x = 0; x < Ze + 1; x++)
      r[x] = 0;
    for (x = 0; x < 3; x++)
      s[x] = 0;
    a.set(r.subarray(0, Ze), 0), c.set(r.subarray(0, Ze + 1), 0);
  }
  n.inflate_trees_bits = function(_, x, w, g, k) {
    let P;
    return f(19), t[0] = 0, P = l(_, 0, 19, 19, null, null, w, x, g, t, e), P == se ? k.msg = "oversubscribed dynamic bit lengths tree" : (P == $e || x[0] === 0) && (k.msg = "incomplete dynamic bit lengths tree", P = se), P;
  }, n.inflate_trees_dynamic = function(_, x, w, g, k, P, m, d, h) {
    let y;
    return f(288), t[0] = 0, y = l(w, 0, _, 257, xo, wo, P, g, d, t, e), y != Q || g[0] === 0 ? (y == se ? h.msg = "oversubscribed literal/length tree" : y != rr && (h.msg = "incomplete literal/length tree", y = se), y) : (f(288), y = l(w, _, x, 0, go, _o, m, k, d, t, e), y != Q || k[0] === 0 && _ > 257 ? (y == se ? h.msg = "oversubscribed distance tree" : y == $e ? (h.msg = "incomplete distance tree", y = se) : y != rr && (h.msg = "empty distance tree with lengths", y = se), y) : Q);
  };
}
An.inflate_trees_fixed = function(n, t, e, r) {
  return n[0] = uo, t[0] = po, e[0] = mo, r[0] = ho, Q;
};
const Wt = 0, ir = 1, sr = 2, or = 3, ar = 4, cr = 5, lr = 6, un = 7, fr = 8, Mt = 9;
function yo() {
  const n = this;
  let t, e = 0, r, s = 0, a = 0, c = 0, l = 0, f = 0, _ = 0, x = 0, w, g = 0, k, P = 0;
  function m(d, h, y, T, D, A, R, F) {
    let b, C, v, S, M, L, Y, H, j, K, V, oe, Z, J, $, ee;
    Y = F.next_in_index, H = F.avail_in, M = R.bitb, L = R.bitk, j = R.write, K = j < R.read ? R.read - j - 1 : R.end - j, V = Re[d], oe = Re[h];
    do {
      for (; L < 20; )
        H--, M |= (F.read_byte(Y++) & 255) << L, L += 8;
      if (b = M & V, C = y, v = T, ee = (v + b) * 3, (S = C[ee]) === 0) {
        M >>= C[ee + 1], L -= C[ee + 1], R.win[j++] = /* (byte) */
        C[ee + 2], K--;
        continue;
      }
      do {
        if (M >>= C[ee + 1], L -= C[ee + 1], S & 16) {
          for (S &= 15, Z = C[ee + 2] + /* (int) */
          (M & Re[S]), M >>= S, L -= S; L < 15; )
            H--, M |= (F.read_byte(Y++) & 255) << L, L += 8;
          b = M & oe, C = D, v = A, ee = (v + b) * 3, S = C[ee];
          do
            if (M >>= C[ee + 1], L -= C[ee + 1], S & 16) {
              for (S &= 15; L < S; )
                H--, M |= (F.read_byte(Y++) & 255) << L, L += 8;
              if (J = C[ee + 2] + (M & Re[S]), M >>= S, L -= S, K -= Z, j >= J)
                $ = j - J, j - $ > 0 && 2 > j - $ ? (R.win[j++] = R.win[$++], R.win[j++] = R.win[$++], Z -= 2) : (R.win.set(R.win.subarray($, $ + 2), j), j += 2, $ += 2, Z -= 2);
              else {
                $ = j - J;
                do
                  $ += R.end;
                while ($ < 0);
                if (S = R.end - $, Z > S) {
                  if (Z -= S, j - $ > 0 && S > j - $)
                    do
                      R.win[j++] = R.win[$++];
                    while (--S !== 0);
                  else
                    R.win.set(R.win.subarray($, $ + S), j), j += S, $ += S, S = 0;
                  $ = 0;
                }
              }
              if (j - $ > 0 && Z > j - $)
                do
                  R.win[j++] = R.win[$++];
                while (--Z !== 0);
              else
                R.win.set(R.win.subarray($, $ + Z), j), j += Z, $ += Z, Z = 0;
              break;
            } else if (!(S & 64))
              b += C[ee + 2], b += M & Re[S], ee = (v + b) * 3, S = C[ee];
            else
              return F.msg = "invalid distance code", Z = F.avail_in - H, Z = L >> 3 < Z ? L >> 3 : Z, H += Z, Y -= Z, L -= Z << 3, R.bitb = M, R.bitk = L, F.avail_in = H, F.total_in += Y - F.next_in_index, F.next_in_index = Y, R.write = j, se;
          while (!0);
          break;
        }
        if (S & 64)
          return S & 32 ? (Z = F.avail_in - H, Z = L >> 3 < Z ? L >> 3 : Z, H += Z, Y -= Z, L -= Z << 3, R.bitb = M, R.bitk = L, F.avail_in = H, F.total_in += Y - F.next_in_index, F.next_in_index = Y, R.write = j, He) : (F.msg = "invalid literal/length code", Z = F.avail_in - H, Z = L >> 3 < Z ? L >> 3 : Z, H += Z, Y -= Z, L -= Z << 3, R.bitb = M, R.bitk = L, F.avail_in = H, F.total_in += Y - F.next_in_index, F.next_in_index = Y, R.write = j, se);
        if (b += C[ee + 2], b += M & Re[S], ee = (v + b) * 3, (S = C[ee]) === 0) {
          M >>= C[ee + 1], L -= C[ee + 1], R.win[j++] = /* (byte) */
          C[ee + 2], K--;
          break;
        }
      } while (!0);
    } while (K >= 258 && H >= 10);
    return Z = F.avail_in - H, Z = L >> 3 < Z ? L >> 3 : Z, H += Z, Y -= Z, L -= Z << 3, R.bitb = M, R.bitk = L, F.avail_in = H, F.total_in += Y - F.next_in_index, F.next_in_index = Y, R.write = j, Q;
  }
  n.init = function(d, h, y, T, D, A) {
    t = Wt, _ = /* (byte) */
    d, x = /* (byte) */
    h, w = y, g = T, k = D, P = A, r = null;
  }, n.proc = function(d, h, y) {
    let T, D, A, R = 0, F = 0, b = 0, C, v, S, M;
    for (b = h.next_in_index, C = h.avail_in, R = d.bitb, F = d.bitk, v = d.write, S = v < d.read ? d.read - v - 1 : d.end - v; ; )
      switch (t) {
        case Wt:
          if (S >= 258 && C >= 10 && (d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, y = m(_, x, w, g, k, P, d, h), b = h.next_in_index, C = h.avail_in, R = d.bitb, F = d.bitk, v = d.write, S = v < d.read ? d.read - v - 1 : d.end - v, y != Q)) {
            t = y == He ? un : Mt;
            break;
          }
          a = _, r = w, s = g, t = ir;
        case ir:
          for (T = a; F < T; ) {
            if (C !== 0)
              y = Q;
            else
              return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
            C--, R |= (h.read_byte(b++) & 255) << F, F += 8;
          }
          if (D = (s + (R & Re[T])) * 3, R >>>= r[D + 1], F -= r[D + 1], A = r[D], A === 0) {
            c = r[D + 2], t = lr;
            break;
          }
          if (A & 16) {
            l = A & 15, e = r[D + 2], t = sr;
            break;
          }
          if (!(A & 64)) {
            a = A, s = D / 3 + r[D + 2];
            break;
          }
          if (A & 32) {
            t = un;
            break;
          }
          return t = Mt, h.msg = "invalid literal/length code", y = se, d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
        case sr:
          for (T = l; F < T; ) {
            if (C !== 0)
              y = Q;
            else
              return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
            C--, R |= (h.read_byte(b++) & 255) << F, F += 8;
          }
          e += R & Re[T], R >>= T, F -= T, a = x, r = k, s = P, t = or;
        case or:
          for (T = a; F < T; ) {
            if (C !== 0)
              y = Q;
            else
              return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
            C--, R |= (h.read_byte(b++) & 255) << F, F += 8;
          }
          if (D = (s + (R & Re[T])) * 3, R >>= r[D + 1], F -= r[D + 1], A = r[D], A & 16) {
            l = A & 15, f = r[D + 2], t = ar;
            break;
          }
          if (!(A & 64)) {
            a = A, s = D / 3 + r[D + 2];
            break;
          }
          return t = Mt, h.msg = "invalid distance code", y = se, d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
        case ar:
          for (T = l; F < T; ) {
            if (C !== 0)
              y = Q;
            else
              return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
            C--, R |= (h.read_byte(b++) & 255) << F, F += 8;
          }
          f += R & Re[T], R >>= T, F -= T, t = cr;
        case cr:
          for (M = v - f; M < 0; )
            M += d.end;
          for (; e !== 0; ) {
            if (S === 0 && (v == d.end && d.read !== 0 && (v = 0, S = v < d.read ? d.read - v - 1 : d.end - v), S === 0 && (d.write = v, y = d.inflate_flush(h, y), v = d.write, S = v < d.read ? d.read - v - 1 : d.end - v, v == d.end && d.read !== 0 && (v = 0, S = v < d.read ? d.read - v - 1 : d.end - v), S === 0)))
              return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
            d.win[v++] = d.win[M++], S--, M == d.end && (M = 0), e--;
          }
          t = Wt;
          break;
        case lr:
          if (S === 0 && (v == d.end && d.read !== 0 && (v = 0, S = v < d.read ? d.read - v - 1 : d.end - v), S === 0 && (d.write = v, y = d.inflate_flush(h, y), v = d.write, S = v < d.read ? d.read - v - 1 : d.end - v, v == d.end && d.read !== 0 && (v = 0, S = v < d.read ? d.read - v - 1 : d.end - v), S === 0)))
            return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
          y = Q, d.win[v++] = /* (byte) */
          c, S--, t = Wt;
          break;
        case un:
          if (F > 7 && (F -= 8, C++, b--), d.write = v, y = d.inflate_flush(h, y), v = d.write, S = v < d.read ? d.read - v - 1 : d.end - v, d.read != d.write)
            return d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
          t = fr;
        case fr:
          return y = He, d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
        case Mt:
          return y = se, d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
        default:
          return y = Ae, d.bitb = R, d.bitk = F, h.avail_in = C, h.total_in += b - h.next_in_index, h.next_in_index = b, d.write = v, d.inflate_flush(h, y);
      }
  }, n.free = function() {
  };
}
const ur = [
  // Order of the bit length code lengths
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
], ft = 0, dn = 1, dr = 2, pr = 3, mr = 4, hr = 5, Nt = 6, qt = 7, xr = 8, nt = 9;
function bo(n, t) {
  const e = this;
  let r = ft, s = 0, a = 0, c = 0, l;
  const f = [0], _ = [0], x = new yo();
  let w = 0, g = new Int32Array(pi * 3);
  const k = 0, P = new An();
  e.bitk = 0, e.bitb = 0, e.win = new Uint8Array(t), e.end = t, e.read = 0, e.write = 0, e.reset = function(m, d) {
    d && (d[0] = k), r == Nt && x.free(m), r = ft, e.bitk = 0, e.bitb = 0, e.read = e.write = 0;
  }, e.reset(n, null), e.inflate_flush = function(m, d) {
    let h, y, T;
    return y = m.next_out_index, T = e.read, h = /* (int) */
    (T <= e.write ? e.write : e.end) - T, h > m.avail_out && (h = m.avail_out), h !== 0 && d == $e && (d = Q), m.avail_out -= h, m.total_out += h, m.next_out.set(e.win.subarray(T, T + h), y), y += h, T += h, T == e.end && (T = 0, e.write == e.end && (e.write = 0), h = e.write - T, h > m.avail_out && (h = m.avail_out), h !== 0 && d == $e && (d = Q), m.avail_out -= h, m.total_out += h, m.next_out.set(e.win.subarray(T, T + h), y), y += h, T += h), m.next_out_index = y, e.read = T, d;
  }, e.proc = function(m, d) {
    let h, y, T, D, A, R, F, b;
    for (D = m.next_in_index, A = m.avail_in, y = e.bitb, T = e.bitk, R = e.write, F = /* (int) */
    R < e.read ? e.read - R - 1 : e.end - R; ; ) {
      let C, v, S, M, L, Y, H, j;
      switch (r) {
        case ft:
          for (; T < 3; ) {
            if (A !== 0)
              d = Q;
            else
              return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
            A--, y |= (m.read_byte(D++) & 255) << T, T += 8;
          }
          switch (h = /* (int) */
          y & 7, w = h & 1, h >>> 1) {
            case 0:
              y >>>= 3, T -= 3, h = T & 7, y >>>= h, T -= h, r = dn;
              break;
            case 1:
              C = [], v = [], S = [[]], M = [[]], An.inflate_trees_fixed(C, v, S, M), x.init(C[0], v[0], S[0], 0, M[0], 0), y >>>= 3, T -= 3, r = Nt;
              break;
            case 2:
              y >>>= 3, T -= 3, r = pr;
              break;
            case 3:
              return y >>>= 3, T -= 3, r = nt, m.msg = "invalid block type", d = se, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          }
          break;
        case dn:
          for (; T < 32; ) {
            if (A !== 0)
              d = Q;
            else
              return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
            A--, y |= (m.read_byte(D++) & 255) << T, T += 8;
          }
          if ((~y >>> 16 & 65535) != (y & 65535))
            return r = nt, m.msg = "invalid stored block lengths", d = se, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          s = y & 65535, y = T = 0, r = s !== 0 ? dr : w !== 0 ? qt : ft;
          break;
        case dr:
          if (A === 0 || F === 0 && (R == e.end && e.read !== 0 && (R = 0, F = /* (int) */
          R < e.read ? e.read - R - 1 : e.end - R), F === 0 && (e.write = R, d = e.inflate_flush(m, d), R = e.write, F = /* (int) */
          R < e.read ? e.read - R - 1 : e.end - R, R == e.end && e.read !== 0 && (R = 0, F = /* (int) */
          R < e.read ? e.read - R - 1 : e.end - R), F === 0)))
            return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          if (d = Q, h = s, h > A && (h = A), h > F && (h = F), e.win.set(m.read_buf(D, h), R), D += h, A -= h, R += h, F -= h, (s -= h) !== 0)
            break;
          r = w !== 0 ? qt : ft;
          break;
        case pr:
          for (; T < 14; ) {
            if (A !== 0)
              d = Q;
            else
              return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
            A--, y |= (m.read_byte(D++) & 255) << T, T += 8;
          }
          if (a = h = y & 16383, (h & 31) > 29 || (h >> 5 & 31) > 29)
            return r = nt, m.msg = "too many length or distance symbols", d = se, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          if (h = 258 + (h & 31) + (h >> 5 & 31), !l || l.length < h)
            l = [];
          else
            for (b = 0; b < h; b++)
              l[b] = 0;
          y >>>= 14, T -= 14, c = 0, r = mr;
        case mr:
          for (; c < 4 + (a >>> 10); ) {
            for (; T < 3; ) {
              if (A !== 0)
                d = Q;
              else
                return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
              A--, y |= (m.read_byte(D++) & 255) << T, T += 8;
            }
            l[ur[c++]] = y & 7, y >>>= 3, T -= 3;
          }
          for (; c < 19; )
            l[ur[c++]] = 0;
          if (f[0] = 7, h = P.inflate_trees_bits(l, f, _, g, m), h != Q)
            return d = h, d == se && (l = null, r = nt), e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          c = 0, r = hr;
        case hr:
          for (; h = a, !(c >= 258 + (h & 31) + (h >> 5 & 31)); ) {
            let K, V;
            for (h = f[0]; T < h; ) {
              if (A !== 0)
                d = Q;
              else
                return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
              A--, y |= (m.read_byte(D++) & 255) << T, T += 8;
            }
            if (h = g[(_[0] + (y & Re[h])) * 3 + 1], V = g[(_[0] + (y & Re[h])) * 3 + 2], V < 16)
              y >>>= h, T -= h, l[c++] = V;
            else {
              for (b = V == 18 ? 7 : V - 14, K = V == 18 ? 11 : 3; T < h + b; ) {
                if (A !== 0)
                  d = Q;
                else
                  return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
                A--, y |= (m.read_byte(D++) & 255) << T, T += 8;
              }
              if (y >>>= h, T -= h, K += y & Re[b], y >>>= b, T -= b, b = c, h = a, b + K > 258 + (h & 31) + (h >> 5 & 31) || V == 16 && b < 1)
                return l = null, r = nt, m.msg = "invalid bit length repeat", d = se, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
              V = V == 16 ? l[b - 1] : 0;
              do
                l[b++] = V;
              while (--K !== 0);
              c = b;
            }
          }
          if (_[0] = -1, L = [], Y = [], H = [], j = [], L[0] = 9, Y[0] = 6, h = a, h = P.inflate_trees_dynamic(257 + (h & 31), 1 + (h >> 5 & 31), l, L, Y, H, j, g, m), h != Q)
            return h == se && (l = null, r = nt), d = h, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          x.init(L[0], Y[0], g, H[0], g, j[0]), r = Nt;
        case Nt:
          if (e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, (d = x.proc(e, m, d)) != He)
            return e.inflate_flush(m, d);
          if (d = Q, x.free(m), D = m.next_in_index, A = m.avail_in, y = e.bitb, T = e.bitk, R = e.write, F = /* (int) */
          R < e.read ? e.read - R - 1 : e.end - R, w === 0) {
            r = ft;
            break;
          }
          r = qt;
        case qt:
          if (e.write = R, d = e.inflate_flush(m, d), R = e.write, F = /* (int) */
          R < e.read ? e.read - R - 1 : e.end - R, e.read != e.write)
            return e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
          r = xr;
        case xr:
          return d = He, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
        case nt:
          return d = se, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
        default:
          return d = Ae, e.bitb = y, e.bitk = T, m.avail_in = A, m.total_in += D - m.next_in_index, m.next_in_index = D, e.write = R, e.inflate_flush(m, d);
      }
    }
  }, e.free = function(m) {
    e.reset(m, null), e.win = null, g = null;
  }, e.set_dictionary = function(m, d, h) {
    e.win.set(m.subarray(d, d + h), 0), e.read = e.write = h;
  }, e.sync_point = function() {
    return r == dn ? 1 : 0;
  };
}
const vo = 32, Eo = 8, ko = 0, wr = 1, gr = 2, _r = 3, yr = 4, br = 5, pn = 6, vt = 7, vr = 12, Ve = 13, So = [0, 0, 255, 255];
function Ao() {
  const n = this;
  n.mode = 0, n.method = 0, n.was = [0], n.need = 0, n.marker = 0, n.wbits = 0;
  function t(e) {
    return !e || !e.istate ? Ae : (e.total_in = e.total_out = 0, e.msg = null, e.istate.mode = vt, e.istate.blocks.reset(e, null), Q);
  }
  n.inflateEnd = function(e) {
    return n.blocks && n.blocks.free(e), n.blocks = null, Q;
  }, n.inflateInit = function(e, r) {
    return e.msg = null, n.blocks = null, r < 8 || r > 15 ? (n.inflateEnd(e), Ae) : (n.wbits = r, e.istate.blocks = new bo(e, 1 << r), t(e), Q);
  }, n.inflate = function(e, r) {
    let s, a;
    if (!e || !e.istate || !e.next_in)
      return Ae;
    const c = e.istate;
    for (r = r == fo ? $e : Q, s = $e; ; )
      switch (c.mode) {
        case ko:
          if (e.avail_in === 0)
            return s;
          if (s = r, e.avail_in--, e.total_in++, ((c.method = e.read_byte(e.next_in_index++)) & 15) != Eo) {
            c.mode = Ve, e.msg = "unknown compression method", c.marker = 5;
            break;
          }
          if ((c.method >> 4) + 8 > c.wbits) {
            c.mode = Ve, e.msg = "invalid win size", c.marker = 5;
            break;
          }
          c.mode = wr;
        case wr:
          if (e.avail_in === 0)
            return s;
          if (s = r, e.avail_in--, e.total_in++, a = e.read_byte(e.next_in_index++) & 255, ((c.method << 8) + a) % 31 !== 0) {
            c.mode = Ve, e.msg = "incorrect header check", c.marker = 5;
            break;
          }
          if (!(a & vo)) {
            c.mode = vt;
            break;
          }
          c.mode = gr;
        case gr:
          if (e.avail_in === 0)
            return s;
          s = r, e.avail_in--, e.total_in++, c.need = (e.read_byte(e.next_in_index++) & 255) << 24 & 4278190080, c.mode = _r;
        case _r:
          if (e.avail_in === 0)
            return s;
          s = r, e.avail_in--, e.total_in++, c.need += (e.read_byte(e.next_in_index++) & 255) << 16 & 16711680, c.mode = yr;
        case yr:
          if (e.avail_in === 0)
            return s;
          s = r, e.avail_in--, e.total_in++, c.need += (e.read_byte(e.next_in_index++) & 255) << 8 & 65280, c.mode = br;
        case br:
          return e.avail_in === 0 ? s : (s = r, e.avail_in--, e.total_in++, c.need += e.read_byte(e.next_in_index++) & 255, c.mode = pn, co);
        case pn:
          return c.mode = Ve, e.msg = "need dictionary", c.marker = 0, Ae;
        case vt:
          if (s = c.blocks.proc(e, s), s == se) {
            c.mode = Ve, c.marker = 0;
            break;
          }
          if (s == Q && (s = r), s != He)
            return s;
          s = r, c.blocks.reset(e, c.was), c.mode = vr;
        case vr:
          return e.avail_in = 0, He;
        case Ve:
          return se;
        default:
          return Ae;
      }
  }, n.inflateSetDictionary = function(e, r, s) {
    let a = 0, c = s;
    if (!e || !e.istate || e.istate.mode != pn)
      return Ae;
    const l = e.istate;
    return c >= 1 << l.wbits && (c = (1 << l.wbits) - 1, a = s - c), l.blocks.set_dictionary(r, a, c), l.mode = vt, Q;
  }, n.inflateSync = function(e) {
    let r, s, a, c, l;
    if (!e || !e.istate)
      return Ae;
    const f = e.istate;
    if (f.mode != Ve && (f.mode = Ve, f.marker = 0), (r = e.avail_in) === 0)
      return $e;
    for (s = e.next_in_index, a = f.marker; r !== 0 && a < 4; )
      e.read_byte(s) == So[a] ? a++ : e.read_byte(s) !== 0 ? a = 0 : a = 4 - a, s++, r--;
    return e.total_in += s - e.next_in_index, e.next_in_index = s, e.avail_in = r, f.marker = a, a != 4 ? se : (c = e.total_in, l = e.total_out, t(e), e.total_in = c, e.total_out = l, f.mode = vt, Q);
  }, n.inflateSyncPoint = function(e) {
    return !e || !e.istate || !e.istate.blocks ? Ae : e.istate.blocks.sync_point();
  };
}
function mi() {
}
mi.prototype = {
  inflateInit(n) {
    const t = this;
    return t.istate = new Ao(), n || (n = ao), t.istate.inflateInit(t, n);
  },
  inflate(n) {
    const t = this;
    return t.istate ? t.istate.inflate(t, n) : Ae;
  },
  inflateEnd() {
    const n = this;
    if (!n.istate)
      return Ae;
    const t = n.istate.inflateEnd(n);
    return n.istate = null, t;
  },
  inflateSync() {
    const n = this;
    return n.istate ? n.istate.inflateSync(n) : Ae;
  },
  inflateSetDictionary(n, t) {
    const e = this;
    return e.istate ? e.istate.inflateSetDictionary(e, n, t) : Ae;
  },
  read_byte(n) {
    return this.next_in[n];
  },
  read_buf(n, t) {
    return this.next_in.subarray(n, n + t);
  }
};
function To(n) {
  const t = this, e = new mi(), r = n && n.chunkSize ? Math.floor(n.chunkSize * 2) : 128 * 1024, s = lo, a = new Uint8Array(r);
  let c = !1;
  e.inflateInit(), e.next_out = a, t.append = function(l, f) {
    const _ = [];
    let x, w, g = 0, k = 0, P = 0;
    if (l.length !== 0) {
      e.next_in_index = 0, e.next_in = l, e.avail_in = l.length;
      do {
        if (e.next_out_index = 0, e.avail_out = r, e.avail_in === 0 && !c && (e.next_in_index = 0, c = !0), x = e.inflate(s), c && x === $e) {
          if (e.avail_in !== 0)
            throw new Error("inflating: bad input");
        } else if (x !== Q && x !== He)
          throw new Error("inflating: " + e.msg);
        if ((c || x === He) && e.avail_in === l.length)
          throw new Error("inflating: bad input");
        e.next_out_index && (e.next_out_index === r ? _.push(new Uint8Array(a)) : _.push(a.subarray(0, e.next_out_index))), P += e.next_out_index, f && e.next_in_index > 0 && e.next_in_index != g && (f(e.next_in_index), g = e.next_in_index);
      } while (e.avail_in > 0 || e.avail_out === 0);
      return _.length > 1 ? (w = new Uint8Array(P), _.forEach(function(m) {
        w.set(m, k), k += m.length;
      })) : w = _[0] ? new Uint8Array(_[0]) : new Uint8Array(), w;
    }
  }, t.flush = function() {
    e.inflateEnd();
  };
}
const st = 4294967295, Xe = 65535, Ro = 8, Fo = 0, Co = 99, Io = 67324752, Po = 134695760, Er = 33639248, Do = 101010256, kr = 101075792, Lo = 117853008, ut = 22, mn = 20, hn = 56, Uo = 1, Oo = 39169, Bo = 10, Wo = 1, Mo = 21589, No = 28789, qo = 25461, jo = 6534, Sr = 1, Ho = 6, Ar = 8, Tr = 2048, Rr = 16, Fr = 16384, Cr = 73, Ir = "/", ke = void 0, Qe = "undefined", Ft = "function";
class Pr {
  constructor(t) {
    return class extends TransformStream {
      constructor(e, r) {
        const s = new t(r);
        super({
          transform(a, c) {
            c.enqueue(s.append(a));
          },
          flush(a) {
            const c = s.flush();
            c && a.enqueue(c);
          }
        });
      }
    };
  }
}
const $o = 64;
let hi = 2;
try {
  typeof navigator != Qe && navigator.hardwareConcurrency && (hi = navigator.hardwareConcurrency);
} catch {
}
const Yo = {
  chunkSize: 512 * 1024,
  maxWorkers: hi,
  terminateWorkerTimeout: 5e3,
  useWebWorkers: !0,
  useCompressionStream: !0,
  workerScripts: ke,
  CompressionStreamNative: typeof CompressionStream != Qe && CompressionStream,
  DecompressionStreamNative: typeof DecompressionStream != Qe && DecompressionStream
}, ze = Object.assign({}, Yo);
function Zo() {
  return ze;
}
function Vo(n) {
  return Math.max(n.chunkSize, $o);
}
function Wn(n) {
  const {
    baseURL: t,
    chunkSize: e,
    maxWorkers: r,
    terminateWorkerTimeout: s,
    useCompressionStream: a,
    useWebWorkers: c,
    Deflate: l,
    Inflate: f,
    CompressionStream: _,
    DecompressionStream: x,
    workerScripts: w
  } = n;
  if (Ge("baseURL", t), Ge("chunkSize", e), Ge("maxWorkers", r), Ge("terminateWorkerTimeout", s), Ge("useCompressionStream", a), Ge("useWebWorkers", c), l && (ze.CompressionStream = new Pr(l)), f && (ze.DecompressionStream = new Pr(f)), Ge("CompressionStream", _), Ge("DecompressionStream", x), w !== ke) {
    const { deflate: g, inflate: k } = w;
    if ((g || k) && (ze.workerScripts || (ze.workerScripts = {})), g) {
      if (!Array.isArray(g))
        throw new Error("workerScripts.deflate must be an array");
      ze.workerScripts.deflate = g;
    }
    if (k) {
      if (!Array.isArray(k))
        throw new Error("workerScripts.inflate must be an array");
      ze.workerScripts.inflate = k;
    }
  }
}
function Ge(n, t) {
  t !== ke && (ze[n] = t);
}
const xn = {
  application: {
    "andrew-inset": "ez",
    annodex: "anx",
    "atom+xml": "atom",
    "atomcat+xml": "atomcat",
    "atomserv+xml": "atomsrv",
    bbolin: "lin",
    "cu-seeme": "cu",
    "davmount+xml": "davmount",
    dsptype: "tsp",
    ecmascript: [
      "es",
      "ecma"
    ],
    futuresplash: "spl",
    hta: "hta",
    "java-archive": "jar",
    "java-serialized-object": "ser",
    "java-vm": "class",
    m3g: "m3g",
    "mac-binhex40": "hqx",
    mathematica: [
      "nb",
      "ma",
      "mb"
    ],
    msaccess: "mdb",
    msword: [
      "doc",
      "dot",
      "wiz"
    ],
    mxf: "mxf",
    oda: "oda",
    ogg: "ogx",
    pdf: "pdf",
    "pgp-keys": "key",
    "pgp-signature": [
      "asc",
      "sig"
    ],
    "pics-rules": "prf",
    postscript: [
      "ps",
      "ai",
      "eps",
      "epsi",
      "epsf",
      "eps2",
      "eps3"
    ],
    rar: "rar",
    "rdf+xml": "rdf",
    "rss+xml": "rss",
    rtf: "rtf",
    "xhtml+xml": [
      "xhtml",
      "xht"
    ],
    xml: [
      "xml",
      "xsl",
      "xsd",
      "xpdl"
    ],
    "xspf+xml": "xspf",
    zip: "zip",
    "vnd.android.package-archive": "apk",
    "vnd.cinderella": "cdy",
    "vnd.google-earth.kml+xml": "kml",
    "vnd.google-earth.kmz": "kmz",
    "vnd.mozilla.xul+xml": "xul",
    "vnd.ms-excel": [
      "xls",
      "xlb",
      "xlt",
      "xlm",
      "xla",
      "xlc",
      "xlw"
    ],
    "vnd.ms-pki.seccat": "cat",
    "vnd.ms-pki.stl": "stl",
    "vnd.ms-powerpoint": [
      "ppt",
      "pps",
      "pot",
      "ppa",
      "pwz"
    ],
    "vnd.oasis.opendocument.chart": "odc",
    "vnd.oasis.opendocument.database": "odb",
    "vnd.oasis.opendocument.formula": "odf",
    "vnd.oasis.opendocument.graphics": "odg",
    "vnd.oasis.opendocument.graphics-template": "otg",
    "vnd.oasis.opendocument.image": "odi",
    "vnd.oasis.opendocument.presentation": "odp",
    "vnd.oasis.opendocument.presentation-template": "otp",
    "vnd.oasis.opendocument.spreadsheet": "ods",
    "vnd.oasis.opendocument.spreadsheet-template": "ots",
    "vnd.oasis.opendocument.text": "odt",
    "vnd.oasis.opendocument.text-master": [
      "odm",
      "otm"
    ],
    "vnd.oasis.opendocument.text-template": "ott",
    "vnd.oasis.opendocument.text-web": "oth",
    "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
    "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
    "vnd.openxmlformats-officedocument.presentationml.template": "potx",
    "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
    "vnd.smaf": "mmf",
    "vnd.stardivision.calc": "sdc",
    "vnd.stardivision.chart": "sds",
    "vnd.stardivision.draw": "sda",
    "vnd.stardivision.impress": "sdd",
    "vnd.stardivision.math": [
      "sdf",
      "smf"
    ],
    "vnd.stardivision.writer": [
      "sdw",
      "vor"
    ],
    "vnd.stardivision.writer-global": "sgl",
    "vnd.sun.xml.calc": "sxc",
    "vnd.sun.xml.calc.template": "stc",
    "vnd.sun.xml.draw": "sxd",
    "vnd.sun.xml.draw.template": "std",
    "vnd.sun.xml.impress": "sxi",
    "vnd.sun.xml.impress.template": "sti",
    "vnd.sun.xml.math": "sxm",
    "vnd.sun.xml.writer": "sxw",
    "vnd.sun.xml.writer.global": "sxg",
    "vnd.sun.xml.writer.template": "stw",
    "vnd.symbian.install": [
      "sis",
      "sisx"
    ],
    "vnd.visio": [
      "vsd",
      "vst",
      "vss",
      "vsw",
      "vsdx",
      "vssx",
      "vstx",
      "vssm",
      "vstm"
    ],
    "vnd.wap.wbxml": "wbxml",
    "vnd.wap.wmlc": "wmlc",
    "vnd.wap.wmlscriptc": "wmlsc",
    "vnd.wordperfect": "wpd",
    "vnd.wordperfect5.1": "wp5",
    "x-123": "wk",
    "x-7z-compressed": "7z",
    "x-abiword": "abw",
    "x-apple-diskimage": "dmg",
    "x-bcpio": "bcpio",
    "x-bittorrent": "torrent",
    "x-cbr": [
      "cbr",
      "cba",
      "cbt",
      "cb7"
    ],
    "x-cbz": "cbz",
    "x-cdf": [
      "cdf",
      "cda"
    ],
    "x-cdlink": "vcd",
    "x-chess-pgn": "pgn",
    "x-cpio": "cpio",
    "x-csh": "csh",
    "x-director": [
      "dir",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ],
    "x-dms": "dms",
    "x-doom": "wad",
    "x-dvi": "dvi",
    "x-httpd-eruby": "rhtml",
    "x-font": "pcf.Z",
    "x-freemind": "mm",
    "x-gnumeric": "gnumeric",
    "x-go-sgf": "sgf",
    "x-graphing-calculator": "gcf",
    "x-gtar": [
      "gtar",
      "taz"
    ],
    "x-hdf": "hdf",
    "x-httpd-php": [
      "phtml",
      "pht",
      "php"
    ],
    "x-httpd-php-source": "phps",
    "x-httpd-php3": "php3",
    "x-httpd-php3-preprocessed": "php3p",
    "x-httpd-php4": "php4",
    "x-httpd-php5": "php5",
    "x-ica": "ica",
    "x-info": "info",
    "x-internet-signup": [
      "ins",
      "isp"
    ],
    "x-iphone": "iii",
    "x-iso9660-image": "iso",
    "x-java-jnlp-file": "jnlp",
    "x-jmol": "jmz",
    "x-killustrator": "kil",
    "x-latex": "latex",
    "x-lyx": "lyx",
    "x-lzx": "lzx",
    "x-maker": [
      "frm",
      "fb",
      "fbdoc"
    ],
    "x-ms-wmd": "wmd",
    "x-msdos-program": [
      "com",
      "exe",
      "bat",
      "dll"
    ],
    "x-netcdf": [
      "nc"
    ],
    "x-ns-proxy-autoconfig": [
      "pac",
      "dat"
    ],
    "x-nwc": "nwc",
    "x-object": "o",
    "x-oz-application": "oza",
    "x-pkcs7-certreqresp": "p7r",
    "x-python-code": [
      "pyc",
      "pyo"
    ],
    "x-qgis": [
      "qgs",
      "shp",
      "shx"
    ],
    "x-quicktimeplayer": "qtl",
    "x-redhat-package-manager": [
      "rpm",
      "rpa"
    ],
    "x-ruby": "rb",
    "x-sh": "sh",
    "x-shar": "shar",
    "x-shockwave-flash": [
      "swf",
      "swfl"
    ],
    "x-silverlight": "scr",
    "x-stuffit": "sit",
    "x-sv4cpio": "sv4cpio",
    "x-sv4crc": "sv4crc",
    "x-tar": "tar",
    "x-tex-gf": "gf",
    "x-tex-pk": "pk",
    "x-texinfo": [
      "texinfo",
      "texi"
    ],
    "x-trash": [
      "~",
      "%",
      "bak",
      "old",
      "sik"
    ],
    "x-ustar": "ustar",
    "x-wais-source": "src",
    "x-wingz": "wz",
    "x-x509-ca-cert": [
      "crt",
      "der",
      "cer"
    ],
    "x-xcf": "xcf",
    "x-xfig": "fig",
    "x-xpinstall": "xpi",
    applixware: "aw",
    "atomsvc+xml": "atomsvc",
    "ccxml+xml": "ccxml",
    "cdmi-capability": "cdmia",
    "cdmi-container": "cdmic",
    "cdmi-domain": "cdmid",
    "cdmi-object": "cdmio",
    "cdmi-queue": "cdmiq",
    "docbook+xml": "dbk",
    "dssc+der": "dssc",
    "dssc+xml": "xdssc",
    "emma+xml": "emma",
    "epub+zip": "epub",
    exi: "exi",
    "font-tdpfr": "pfr",
    "gml+xml": "gml",
    "gpx+xml": "gpx",
    gxf: "gxf",
    hyperstudio: "stk",
    "inkml+xml": [
      "ink",
      "inkml"
    ],
    ipfix: "ipfix",
    "jsonml+json": "jsonml",
    "lost+xml": "lostxml",
    "mads+xml": "mads",
    marc: "mrc",
    "marcxml+xml": "mrcx",
    "mathml+xml": [
      "mathml",
      "mml"
    ],
    mbox: "mbox",
    "mediaservercontrol+xml": "mscml",
    "metalink+xml": "metalink",
    "metalink4+xml": "meta4",
    "mets+xml": "mets",
    "mods+xml": "mods",
    mp21: [
      "m21",
      "mp21"
    ],
    mp4: "mp4s",
    "oebps-package+xml": "opf",
    "omdoc+xml": "omdoc",
    onenote: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ],
    oxps: "oxps",
    "patch-ops-error+xml": "xer",
    "pgp-encrypted": "pgp",
    pkcs10: "p10",
    "pkcs7-mime": [
      "p7m",
      "p7c"
    ],
    "pkcs7-signature": "p7s",
    pkcs8: "p8",
    "pkix-attr-cert": "ac",
    "pkix-crl": "crl",
    "pkix-pkipath": "pkipath",
    pkixcmp: "pki",
    "pls+xml": "pls",
    "prs.cww": "cww",
    "pskc+xml": "pskcxml",
    "reginfo+xml": "rif",
    "relax-ng-compact-syntax": "rnc",
    "resource-lists+xml": "rl",
    "resource-lists-diff+xml": "rld",
    "rls-services+xml": "rs",
    "rpki-ghostbusters": "gbr",
    "rpki-manifest": "mft",
    "rpki-roa": "roa",
    "rsd+xml": "rsd",
    "sbml+xml": "sbml",
    "scvp-cv-request": "scq",
    "scvp-cv-response": "scs",
    "scvp-vp-request": "spq",
    "scvp-vp-response": "spp",
    sdp: "sdp",
    "set-payment-initiation": "setpay",
    "set-registration-initiation": "setreg",
    "shf+xml": "shf",
    "sparql-query": "rq",
    "sparql-results+xml": "srx",
    srgs: "gram",
    "srgs+xml": "grxml",
    "sru+xml": "sru",
    "ssdl+xml": "ssdl",
    "ssml+xml": "ssml",
    "tei+xml": [
      "tei",
      "teicorpus"
    ],
    "thraud+xml": "tfi",
    "timestamped-data": "tsd",
    "vnd.3gpp.pic-bw-large": "plb",
    "vnd.3gpp.pic-bw-small": "psb",
    "vnd.3gpp.pic-bw-var": "pvb",
    "vnd.3gpp2.tcap": "tcap",
    "vnd.3m.post-it-notes": "pwn",
    "vnd.accpac.simply.aso": "aso",
    "vnd.accpac.simply.imp": "imp",
    "vnd.acucobol": "acu",
    "vnd.acucorp": [
      "atc",
      "acutc"
    ],
    "vnd.adobe.air-application-installer-package+zip": "air",
    "vnd.adobe.formscentral.fcdt": "fcdt",
    "vnd.adobe.fxp": [
      "fxp",
      "fxpl"
    ],
    "vnd.adobe.xdp+xml": "xdp",
    "vnd.adobe.xfdf": "xfdf",
    "vnd.ahead.space": "ahead",
    "vnd.airzip.filesecure.azf": "azf",
    "vnd.airzip.filesecure.azs": "azs",
    "vnd.amazon.ebook": "azw",
    "vnd.americandynamics.acc": "acc",
    "vnd.amiga.ami": "ami",
    "vnd.anser-web-certificate-issue-initiation": "cii",
    "vnd.anser-web-funds-transfer-initiation": "fti",
    "vnd.antix.game-component": "atx",
    "vnd.apple.installer+xml": "mpkg",
    "vnd.apple.mpegurl": "m3u8",
    "vnd.aristanetworks.swi": "swi",
    "vnd.astraea-software.iota": "iota",
    "vnd.audiograph": "aep",
    "vnd.blueice.multipass": "mpm",
    "vnd.bmi": "bmi",
    "vnd.businessobjects": "rep",
    "vnd.chemdraw+xml": "cdxml",
    "vnd.chipnuts.karaoke-mmd": "mmd",
    "vnd.claymore": "cla",
    "vnd.cloanto.rp9": "rp9",
    "vnd.clonk.c4group": [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ],
    "vnd.cluetrust.cartomobile-config": "c11amc",
    "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
    "vnd.commonspace": "csp",
    "vnd.contact.cmsg": "cdbcmsg",
    "vnd.cosmocaller": "cmc",
    "vnd.crick.clicker": "clkx",
    "vnd.crick.clicker.keyboard": "clkk",
    "vnd.crick.clicker.palette": "clkp",
    "vnd.crick.clicker.template": "clkt",
    "vnd.crick.clicker.wordbank": "clkw",
    "vnd.criticaltools.wbs+xml": "wbs",
    "vnd.ctc-posml": "pml",
    "vnd.cups-ppd": "ppd",
    "vnd.curl.car": "car",
    "vnd.curl.pcurl": "pcurl",
    "vnd.dart": "dart",
    "vnd.data-vision.rdz": "rdz",
    "vnd.dece.data": [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ],
    "vnd.dece.ttml+xml": [
      "uvt",
      "uvvt"
    ],
    "vnd.dece.unspecified": [
      "uvx",
      "uvvx"
    ],
    "vnd.dece.zip": [
      "uvz",
      "uvvz"
    ],
    "vnd.denovo.fcselayout-link": "fe_launch",
    "vnd.dna": "dna",
    "vnd.dolby.mlp": "mlp",
    "vnd.dpgraph": "dpg",
    "vnd.dreamfactory": "dfac",
    "vnd.ds-keypoint": "kpxx",
    "vnd.dvb.ait": "ait",
    "vnd.dvb.service": "svc",
    "vnd.dynageo": "geo",
    "vnd.ecowin.chart": "mag",
    "vnd.enliven": "nml",
    "vnd.epson.esf": "esf",
    "vnd.epson.msf": "msf",
    "vnd.epson.quickanime": "qam",
    "vnd.epson.salt": "slt",
    "vnd.epson.ssf": "ssf",
    "vnd.eszigno3+xml": [
      "es3",
      "et3"
    ],
    "vnd.ezpix-album": "ez2",
    "vnd.ezpix-package": "ez3",
    "vnd.fdf": "fdf",
    "vnd.fdsn.mseed": "mseed",
    "vnd.fdsn.seed": [
      "seed",
      "dataless"
    ],
    "vnd.flographit": "gph",
    "vnd.fluxtime.clip": "ftc",
    "vnd.framemaker": [
      "fm",
      "frame",
      "maker",
      "book"
    ],
    "vnd.frogans.fnc": "fnc",
    "vnd.frogans.ltf": "ltf",
    "vnd.fsc.weblaunch": "fsc",
    "vnd.fujitsu.oasys": "oas",
    "vnd.fujitsu.oasys2": "oa2",
    "vnd.fujitsu.oasys3": "oa3",
    "vnd.fujitsu.oasysgp": "fg5",
    "vnd.fujitsu.oasysprs": "bh2",
    "vnd.fujixerox.ddd": "ddd",
    "vnd.fujixerox.docuworks": "xdw",
    "vnd.fujixerox.docuworks.binder": "xbd",
    "vnd.fuzzysheet": "fzs",
    "vnd.genomatix.tuxedo": "txd",
    "vnd.geogebra.file": "ggb",
    "vnd.geogebra.tool": "ggt",
    "vnd.geometry-explorer": [
      "gex",
      "gre"
    ],
    "vnd.geonext": "gxt",
    "vnd.geoplan": "g2w",
    "vnd.geospace": "g3w",
    "vnd.gmx": "gmx",
    "vnd.grafeq": [
      "gqf",
      "gqs"
    ],
    "vnd.groove-account": "gac",
    "vnd.groove-help": "ghf",
    "vnd.groove-identity-message": "gim",
    "vnd.groove-injector": "grv",
    "vnd.groove-tool-message": "gtm",
    "vnd.groove-tool-template": "tpl",
    "vnd.groove-vcard": "vcg",
    "vnd.hal+xml": "hal",
    "vnd.handheld-entertainment+xml": "zmm",
    "vnd.hbci": "hbci",
    "vnd.hhe.lesson-player": "les",
    "vnd.hp-hpgl": "hpgl",
    "vnd.hp-hpid": "hpid",
    "vnd.hp-hps": "hps",
    "vnd.hp-jlyt": "jlt",
    "vnd.hp-pcl": "pcl",
    "vnd.hp-pclxl": "pclxl",
    "vnd.hydrostatix.sof-data": "sfd-hdstx",
    "vnd.ibm.minipay": "mpy",
    "vnd.ibm.modcap": [
      "afp",
      "listafp",
      "list3820"
    ],
    "vnd.ibm.rights-management": "irm",
    "vnd.ibm.secure-container": "sc",
    "vnd.iccprofile": [
      "icc",
      "icm"
    ],
    "vnd.igloader": "igl",
    "vnd.immervision-ivp": "ivp",
    "vnd.immervision-ivu": "ivu",
    "vnd.insors.igm": "igm",
    "vnd.intercon.formnet": [
      "xpw",
      "xpx"
    ],
    "vnd.intergeo": "i2g",
    "vnd.intu.qbo": "qbo",
    "vnd.intu.qfx": "qfx",
    "vnd.ipunplugged.rcprofile": "rcprofile",
    "vnd.irepository.package+xml": "irp",
    "vnd.is-xpr": "xpr",
    "vnd.isac.fcs": "fcs",
    "vnd.jam": "jam",
    "vnd.jcp.javame.midlet-rms": "rms",
    "vnd.jisp": "jisp",
    "vnd.joost.joda-archive": "joda",
    "vnd.kahootz": [
      "ktz",
      "ktr"
    ],
    "vnd.kde.karbon": "karbon",
    "vnd.kde.kchart": "chrt",
    "vnd.kde.kformula": "kfo",
    "vnd.kde.kivio": "flw",
    "vnd.kde.kontour": "kon",
    "vnd.kde.kpresenter": [
      "kpr",
      "kpt"
    ],
    "vnd.kde.kspread": "ksp",
    "vnd.kde.kword": [
      "kwd",
      "kwt"
    ],
    "vnd.kenameaapp": "htke",
    "vnd.kidspiration": "kia",
    "vnd.kinar": [
      "kne",
      "knp"
    ],
    "vnd.koan": [
      "skp",
      "skd",
      "skt",
      "skm"
    ],
    "vnd.kodak-descriptor": "sse",
    "vnd.las.las+xml": "lasxml",
    "vnd.llamagraphics.life-balance.desktop": "lbd",
    "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
    "vnd.lotus-1-2-3": "123",
    "vnd.lotus-approach": "apr",
    "vnd.lotus-freelance": "pre",
    "vnd.lotus-notes": "nsf",
    "vnd.lotus-organizer": "org",
    "vnd.lotus-screencam": "scm",
    "vnd.lotus-wordpro": "lwp",
    "vnd.macports.portpkg": "portpkg",
    "vnd.mcd": "mcd",
    "vnd.medcalcdata": "mc1",
    "vnd.mediastation.cdkey": "cdkey",
    "vnd.mfer": "mwf",
    "vnd.mfmp": "mfm",
    "vnd.micrografx.flo": "flo",
    "vnd.micrografx.igx": "igx",
    "vnd.mif": "mif",
    "vnd.mobius.daf": "daf",
    "vnd.mobius.dis": "dis",
    "vnd.mobius.mbk": "mbk",
    "vnd.mobius.mqy": "mqy",
    "vnd.mobius.msl": "msl",
    "vnd.mobius.plc": "plc",
    "vnd.mobius.txf": "txf",
    "vnd.mophun.application": "mpn",
    "vnd.mophun.certificate": "mpc",
    "vnd.ms-artgalry": "cil",
    "vnd.ms-cab-compressed": "cab",
    "vnd.ms-excel.addin.macroenabled.12": "xlam",
    "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
    "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
    "vnd.ms-excel.template.macroenabled.12": "xltm",
    "vnd.ms-fontobject": "eot",
    "vnd.ms-htmlhelp": "chm",
    "vnd.ms-ims": "ims",
    "vnd.ms-lrm": "lrm",
    "vnd.ms-officetheme": "thmx",
    "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
    "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
    "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
    "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
    "vnd.ms-powerpoint.template.macroenabled.12": "potm",
    "vnd.ms-project": [
      "mpp",
      "mpt"
    ],
    "vnd.ms-word.document.macroenabled.12": "docm",
    "vnd.ms-word.template.macroenabled.12": "dotm",
    "vnd.ms-works": [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ],
    "vnd.ms-wpl": "wpl",
    "vnd.ms-xpsdocument": "xps",
    "vnd.mseq": "mseq",
    "vnd.musician": "mus",
    "vnd.muvee.style": "msty",
    "vnd.mynfc": "taglet",
    "vnd.neurolanguage.nlu": "nlu",
    "vnd.nitf": [
      "ntf",
      "nitf"
    ],
    "vnd.noblenet-directory": "nnd",
    "vnd.noblenet-sealer": "nns",
    "vnd.noblenet-web": "nnw",
    "vnd.nokia.n-gage.data": "ngdat",
    "vnd.nokia.n-gage.symbian.install": "n-gage",
    "vnd.nokia.radio-preset": "rpst",
    "vnd.nokia.radio-presets": "rpss",
    "vnd.novadigm.edm": "edm",
    "vnd.novadigm.edx": "edx",
    "vnd.novadigm.ext": "ext",
    "vnd.oasis.opendocument.chart-template": "otc",
    "vnd.oasis.opendocument.formula-template": "odft",
    "vnd.oasis.opendocument.image-template": "oti",
    "vnd.olpc-sugar": "xo",
    "vnd.oma.dd2+xml": "dd2",
    "vnd.openofficeorg.extension": "oxt",
    "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
    "vnd.osgeo.mapguide.package": "mgp",
    "vnd.osgi.dp": "dp",
    "vnd.osgi.subsystem": "esa",
    "vnd.palm": [
      "pdb",
      "pqa",
      "oprc"
    ],
    "vnd.pawaafile": "paw",
    "vnd.pg.format": "str",
    "vnd.pg.osasli": "ei6",
    "vnd.picsel": "efif",
    "vnd.pmi.widget": "wg",
    "vnd.pocketlearn": "plf",
    "vnd.powerbuilder6": "pbd",
    "vnd.previewsystems.box": "box",
    "vnd.proteus.magazine": "mgz",
    "vnd.publishare-delta-tree": "qps",
    "vnd.pvi.ptid1": "ptid",
    "vnd.quark.quarkxpress": [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ],
    "vnd.realvnc.bed": "bed",
    "vnd.recordare.musicxml": "mxl",
    "vnd.recordare.musicxml+xml": "musicxml",
    "vnd.rig.cryptonote": "cryptonote",
    "vnd.rn-realmedia": "rm",
    "vnd.rn-realmedia-vbr": "rmvb",
    "vnd.route66.link66+xml": "link66",
    "vnd.sailingtracker.track": "st",
    "vnd.seemail": "see",
    "vnd.sema": "sema",
    "vnd.semd": "semd",
    "vnd.semf": "semf",
    "vnd.shana.informed.formdata": "ifm",
    "vnd.shana.informed.formtemplate": "itp",
    "vnd.shana.informed.interchange": "iif",
    "vnd.shana.informed.package": "ipk",
    "vnd.simtech-mindmapper": [
      "twd",
      "twds"
    ],
    "vnd.smart.teacher": "teacher",
    "vnd.solent.sdkm+xml": [
      "sdkm",
      "sdkd"
    ],
    "vnd.spotfire.dxp": "dxp",
    "vnd.spotfire.sfs": "sfs",
    "vnd.stepmania.package": "smzip",
    "vnd.stepmania.stepchart": "sm",
    "vnd.sus-calendar": [
      "sus",
      "susp"
    ],
    "vnd.svd": "svd",
    "vnd.syncml+xml": "xsm",
    "vnd.syncml.dm+wbxml": "bdm",
    "vnd.syncml.dm+xml": "xdm",
    "vnd.tao.intent-module-archive": "tao",
    "vnd.tcpdump.pcap": [
      "pcap",
      "cap",
      "dmp"
    ],
    "vnd.tmobile-livetv": "tmo",
    "vnd.trid.tpt": "tpt",
    "vnd.triscape.mxs": "mxs",
    "vnd.trueapp": "tra",
    "vnd.ufdl": [
      "ufd",
      "ufdl"
    ],
    "vnd.uiq.theme": "utz",
    "vnd.umajin": "umj",
    "vnd.unity": "unityweb",
    "vnd.uoml+xml": "uoml",
    "vnd.vcx": "vcx",
    "vnd.visionary": "vis",
    "vnd.vsf": "vsf",
    "vnd.webturbo": "wtb",
    "vnd.wolfram.player": "nbp",
    "vnd.wqd": "wqd",
    "vnd.wt.stf": "stf",
    "vnd.xara": "xar",
    "vnd.xfdl": "xfdl",
    "vnd.yamaha.hv-dic": "hvd",
    "vnd.yamaha.hv-script": "hvs",
    "vnd.yamaha.hv-voice": "hvp",
    "vnd.yamaha.openscoreformat": "osf",
    "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
    "vnd.yamaha.smaf-audio": "saf",
    "vnd.yamaha.smaf-phrase": "spf",
    "vnd.yellowriver-custom-menu": "cmp",
    "vnd.zul": [
      "zir",
      "zirz"
    ],
    "vnd.zzazz.deck+xml": "zaz",
    "voicexml+xml": "vxml",
    widget: "wgt",
    winhlp: "hlp",
    "wsdl+xml": "wsdl",
    "wspolicy+xml": "wspolicy",
    "x-ace-compressed": "ace",
    "x-authorware-bin": [
      "aab",
      "x32",
      "u32",
      "vox"
    ],
    "x-authorware-map": "aam",
    "x-authorware-seg": "aas",
    "x-blorb": [
      "blb",
      "blorb"
    ],
    "x-bzip": "bz",
    "x-bzip2": [
      "bz2",
      "boz"
    ],
    "x-cfs-compressed": "cfs",
    "x-chat": "chat",
    "x-conference": "nsc",
    "x-dgc-compressed": "dgc",
    "x-dtbncx+xml": "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-eva": "eva",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": [
      "ttf",
      "ttc"
    ],
    "x-font-type1": [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ],
    "x-freearc": "arc",
    "x-gca-compressed": "gca",
    "x-glulx": "ulx",
    "x-gramps-xml": "gramps",
    "x-install-instructions": "install",
    "x-lzh-compressed": [
      "lzh",
      "lha"
    ],
    "x-mie": "mie",
    "x-mobipocket-ebook": [
      "prc",
      "mobi"
    ],
    "x-ms-application": "application",
    "x-ms-shortcut": "lnk",
    "x-ms-xbap": "xbap",
    "x-msbinder": "obd",
    "x-mscardfile": "crd",
    "x-msclip": "clp",
    "application/x-ms-installer": "msi",
    "x-msmediaview": [
      "mvb",
      "m13",
      "m14"
    ],
    "x-msmetafile": [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ],
    "x-msmoney": "mny",
    "x-mspublisher": "pub",
    "x-msschedule": "scd",
    "x-msterminal": "trm",
    "x-mswrite": "wri",
    "x-nzb": "nzb",
    "x-pkcs12": [
      "p12",
      "pfx"
    ],
    "x-pkcs7-certificates": [
      "p7b",
      "spc"
    ],
    "x-research-info-systems": "ris",
    "x-silverlight-app": "xap",
    "x-sql": "sql",
    "x-stuffitx": "sitx",
    "x-subrip": "srt",
    "x-t3vm-image": "t3",
    "x-tex-tfm": "tfm",
    "x-tgif": "obj",
    "x-xliff+xml": "xlf",
    "x-xz": "xz",
    "x-zmachine": [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ],
    "xaml+xml": "xaml",
    "xcap-diff+xml": "xdf",
    "xenc+xml": "xenc",
    "xml-dtd": "dtd",
    "xop+xml": "xop",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "xv+xml": [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ],
    yang: "yang",
    "yin+xml": "yin",
    envoy: "evy",
    fractals: "fif",
    "internet-property-stream": "acx",
    olescript: "axs",
    "vnd.ms-outlook": "msg",
    "vnd.ms-pkicertstore": "sst",
    "x-compress": "z",
    "x-perfmon": [
      "pma",
      "pmc",
      "pmr",
      "pmw"
    ],
    "ynd.ms-pkipko": "pko",
    gzip: [
      "gz",
      "tgz"
    ],
    "smil+xml": [
      "smi",
      "smil"
    ],
    "vnd.debian.binary-package": [
      "deb",
      "udeb"
    ],
    "vnd.hzn-3d-crossword": "x3d",
    "vnd.sqlite3": [
      "db",
      "sqlite",
      "sqlite3",
      "db-wal",
      "sqlite-wal",
      "db-shm",
      "sqlite-shm"
    ],
    "vnd.wap.sic": "sic",
    "vnd.wap.slc": "slc",
    "x-krita": [
      "kra",
      "krz"
    ],
    "x-perl": [
      "pm",
      "pl"
    ],
    yaml: [
      "yaml",
      "yml"
    ]
  },
  audio: {
    amr: "amr",
    "amr-wb": "awb",
    annodex: "axa",
    basic: [
      "au",
      "snd"
    ],
    flac: "flac",
    midi: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ],
    mpeg: [
      "mpga",
      "mpega",
      "mp3",
      "m4a",
      "mp2a",
      "m2a",
      "m3a"
    ],
    mpegurl: "m3u",
    ogg: [
      "oga",
      "ogg",
      "spx"
    ],
    "prs.sid": "sid",
    "x-aiff": "aifc",
    "x-gsm": "gsm",
    "x-ms-wma": "wma",
    "x-ms-wax": "wax",
    "x-pn-realaudio": "ram",
    "x-realaudio": "ra",
    "x-sd2": "sd2",
    adpcm: "adp",
    mp4: "mp4a",
    s3m: "s3m",
    silk: "sil",
    "vnd.dece.audio": [
      "uva",
      "uvva"
    ],
    "vnd.digital-winds": "eol",
    "vnd.dra": "dra",
    "vnd.dts": "dts",
    "vnd.dts.hd": "dtshd",
    "vnd.lucent.voice": "lvp",
    "vnd.ms-playready.media.pya": "pya",
    "vnd.nuera.ecelp4800": "ecelp4800",
    "vnd.nuera.ecelp7470": "ecelp7470",
    "vnd.nuera.ecelp9600": "ecelp9600",
    "vnd.rip": "rip",
    webm: "weba",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    xm: "xm",
    aac: "aac",
    aiff: [
      "aiff",
      "aif",
      "aff"
    ],
    opus: "opus",
    wav: "wav"
  },
  chemical: {
    "x-alchemy": "alc",
    "x-cache": [
      "cac",
      "cache"
    ],
    "x-cache-csf": "csf",
    "x-cactvs-binary": [
      "cbin",
      "cascii",
      "ctab"
    ],
    "x-cdx": "cdx",
    "x-chem3d": "c3d",
    "x-cif": "cif",
    "x-cmdf": "cmdf",
    "x-cml": "cml",
    "x-compass": "cpa",
    "x-crossfire": "bsd",
    "x-csml": [
      "csml",
      "csm"
    ],
    "x-ctx": "ctx",
    "x-cxf": [
      "cxf",
      "cef"
    ],
    "x-embl-dl-nucleotide": [
      "emb",
      "embl"
    ],
    "x-gamess-input": [
      "inp",
      "gam",
      "gamin"
    ],
    "x-gaussian-checkpoint": [
      "fch",
      "fchk"
    ],
    "x-gaussian-cube": "cub",
    "x-gaussian-input": [
      "gau",
      "gjc",
      "gjf"
    ],
    "x-gaussian-log": "gal",
    "x-gcg8-sequence": "gcg",
    "x-genbank": "gen",
    "x-hin": "hin",
    "x-isostar": [
      "istr",
      "ist"
    ],
    "x-jcamp-dx": [
      "jdx",
      "dx"
    ],
    "x-kinemage": "kin",
    "x-macmolecule": "mcm",
    "x-macromodel-input": "mmod",
    "x-mdl-molfile": "mol",
    "x-mdl-rdfile": "rd",
    "x-mdl-rxnfile": "rxn",
    "x-mdl-sdfile": "sd",
    "x-mdl-tgf": "tgf",
    "x-mmcif": "mcif",
    "x-mol2": "mol2",
    "x-molconn-Z": "b",
    "x-mopac-graph": "gpt",
    "x-mopac-input": [
      "mop",
      "mopcrt",
      "zmt"
    ],
    "x-mopac-out": "moo",
    "x-ncbi-asn1": "asn",
    "x-ncbi-asn1-ascii": [
      "prt",
      "ent"
    ],
    "x-ncbi-asn1-binary": "val",
    "x-rosdal": "ros",
    "x-swissprot": "sw",
    "x-vamas-iso14976": "vms",
    "x-vmd": "vmd",
    "x-xtel": "xtel",
    "x-xyz": "xyz"
  },
  font: {
    otf: "otf",
    woff: "woff",
    woff2: "woff2"
  },
  image: {
    gif: "gif",
    ief: "ief",
    jpeg: [
      "jpeg",
      "jpg",
      "jpe",
      "jfif",
      "jfif-tbnl",
      "jif"
    ],
    pcx: "pcx",
    png: "png",
    "svg+xml": [
      "svg",
      "svgz"
    ],
    tiff: [
      "tiff",
      "tif"
    ],
    "vnd.djvu": [
      "djvu",
      "djv"
    ],
    "vnd.wap.wbmp": "wbmp",
    "x-canon-cr2": "cr2",
    "x-canon-crw": "crw",
    "x-cmu-raster": "ras",
    "x-coreldraw": "cdr",
    "x-coreldrawpattern": "pat",
    "x-coreldrawtemplate": "cdt",
    "x-corelphotopaint": "cpt",
    "x-epson-erf": "erf",
    "x-icon": "ico",
    "x-jg": "art",
    "x-jng": "jng",
    "x-nikon-nef": "nef",
    "x-olympus-orf": "orf",
    "x-portable-anymap": "pnm",
    "x-portable-bitmap": "pbm",
    "x-portable-graymap": "pgm",
    "x-portable-pixmap": "ppm",
    "x-rgb": "rgb",
    "x-xbitmap": "xbm",
    "x-xpixmap": "xpm",
    "x-xwindowdump": "xwd",
    bmp: "bmp",
    cgm: "cgm",
    g3fax: "g3",
    ktx: "ktx",
    "prs.btif": "btif",
    sgi: "sgi",
    "vnd.dece.graphic": [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ],
    "vnd.dwg": "dwg",
    "vnd.dxf": "dxf",
    "vnd.fastbidsheet": "fbs",
    "vnd.fpx": "fpx",
    "vnd.fst": "fst",
    "vnd.fujixerox.edmics-mmr": "mmr",
    "vnd.fujixerox.edmics-rlc": "rlc",
    "vnd.ms-modi": "mdi",
    "vnd.ms-photo": "wdp",
    "vnd.net-fpx": "npx",
    "vnd.xiff": "xif",
    webp: "webp",
    "x-3ds": "3ds",
    "x-cmx": "cmx",
    "x-freehand": [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ],
    "x-pict": [
      "pic",
      "pct"
    ],
    "x-tga": "tga",
    "cis-cod": "cod",
    avif: "avifs",
    heic: [
      "heif",
      "heic"
    ],
    pjpeg: [
      "pjpg"
    ],
    "vnd.adobe.photoshop": "psd",
    "x-adobe-dng": "dng",
    "x-fuji-raf": "raf",
    "x-icns": "icns",
    "x-kodak-dcr": "dcr",
    "x-kodak-k25": "k25",
    "x-kodak-kdc": "kdc",
    "x-minolta-mrw": "mrw",
    "x-panasonic-raw": [
      "raw",
      "rw2",
      "rwl"
    ],
    "x-pentax-pef": [
      "pef",
      "ptx"
    ],
    "x-sigma-x3f": "x3f",
    "x-sony-arw": "arw",
    "x-sony-sr2": "sr2",
    "x-sony-srf": "srf"
  },
  message: {
    rfc822: [
      "eml",
      "mime",
      "mht",
      "mhtml",
      "nws"
    ]
  },
  model: {
    iges: [
      "igs",
      "iges"
    ],
    mesh: [
      "msh",
      "mesh",
      "silo"
    ],
    vrml: [
      "wrl",
      "vrml"
    ],
    "x3d+vrml": [
      "x3dv",
      "x3dvz"
    ],
    "x3d+xml": "x3dz",
    "x3d+binary": [
      "x3db",
      "x3dbz"
    ],
    "vnd.collada+xml": "dae",
    "vnd.dwf": "dwf",
    "vnd.gdl": "gdl",
    "vnd.gtw": "gtw",
    "vnd.mts": "mts",
    "vnd.usdz+zip": "usdz",
    "vnd.vtu": "vtu"
  },
  text: {
    "cache-manifest": [
      "manifest",
      "appcache"
    ],
    calendar: [
      "ics",
      "icz",
      "ifb"
    ],
    css: "css",
    csv: "csv",
    h323: "323",
    html: [
      "html",
      "htm",
      "shtml",
      "stm"
    ],
    iuls: "uls",
    plain: [
      "txt",
      "text",
      "brf",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "bas",
      "diff",
      "ksh"
    ],
    richtext: "rtx",
    scriptlet: [
      "sct",
      "wsc"
    ],
    texmacs: "tm",
    "tab-separated-values": "tsv",
    "vnd.sun.j2me.app-descriptor": "jad",
    "vnd.wap.wml": "wml",
    "vnd.wap.wmlscript": "wmls",
    "x-bibtex": "bib",
    "x-boo": "boo",
    "x-c++hdr": [
      "h++",
      "hpp",
      "hxx",
      "hh"
    ],
    "x-c++src": [
      "c++",
      "cpp",
      "cxx",
      "cc"
    ],
    "x-component": "htc",
    "x-dsrc": "d",
    "x-diff": "patch",
    "x-haskell": "hs",
    "x-java": "java",
    "x-literate-haskell": "lhs",
    "x-moc": "moc",
    "x-pascal": [
      "p",
      "pas",
      "pp",
      "inc"
    ],
    "x-pcs-gcd": "gcd",
    "x-python": "py",
    "x-scala": "scala",
    "x-setext": "etx",
    "x-tcl": [
      "tcl",
      "tk"
    ],
    "x-tex": [
      "tex",
      "ltx",
      "sty",
      "cls"
    ],
    "x-vcalendar": "vcs",
    "x-vcard": "vcf",
    n3: "n3",
    "prs.lines.tag": "dsc",
    sgml: [
      "sgml",
      "sgm"
    ],
    troff: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ],
    turtle: "ttl",
    "uri-list": [
      "uri",
      "uris",
      "urls"
    ],
    vcard: "vcard",
    "vnd.curl": "curl",
    "vnd.curl.dcurl": "dcurl",
    "vnd.curl.scurl": "scurl",
    "vnd.curl.mcurl": "mcurl",
    "vnd.dvb.subtitle": "sub",
    "vnd.fly": "fly",
    "vnd.fmi.flexstor": "flx",
    "vnd.graphviz": "gv",
    "vnd.in3d.3dml": "3dml",
    "vnd.in3d.spot": "spot",
    "x-asm": [
      "s",
      "asm"
    ],
    "x-c": [
      "c",
      "h",
      "dic"
    ],
    "x-fortran": [
      "f",
      "for",
      "f77",
      "f90"
    ],
    "x-opml": "opml",
    "x-nfo": "nfo",
    "x-sfv": "sfv",
    "x-uuencode": "uu",
    webviewhtml: "htt",
    javascript: "js",
    json: "json",
    markdown: [
      "md",
      "markdown",
      "mdown",
      "markdn"
    ],
    "vnd.wap.si": "si",
    "vnd.wap.sl": "sl"
  },
  video: {
    avif: "avif",
    "3gpp": "3gp",
    annodex: "axv",
    dl: "dl",
    dv: [
      "dif",
      "dv"
    ],
    fli: "fli",
    gl: "gl",
    mpeg: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v",
      "mp2",
      "mpa",
      "mpv2"
    ],
    mp4: [
      "mp4",
      "mp4v",
      "mpg4"
    ],
    quicktime: [
      "qt",
      "mov"
    ],
    ogg: "ogv",
    "vnd.mpegurl": [
      "mxu",
      "m4u"
    ],
    "x-flv": "flv",
    "x-la-asf": [
      "lsf",
      "lsx"
    ],
    "x-mng": "mng",
    "x-ms-asf": [
      "asf",
      "asx",
      "asr"
    ],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": [
      "mpv",
      "mkv",
      "mk3d",
      "mks"
    ],
    "3gpp2": "3g2",
    h261: "h261",
    h263: "h263",
    h264: "h264",
    jpeg: "jpgv",
    jpm: [
      "jpm",
      "jpgm"
    ],
    mj2: [
      "mj2",
      "mjp2"
    ],
    "vnd.dece.hd": [
      "uvh",
      "uvvh"
    ],
    "vnd.dece.mobile": [
      "uvm",
      "uvvm"
    ],
    "vnd.dece.pd": [
      "uvp",
      "uvvp"
    ],
    "vnd.dece.sd": [
      "uvs",
      "uvvs"
    ],
    "vnd.dece.video": [
      "uvv",
      "uvvv"
    ],
    "vnd.dvb.file": "dvb",
    "vnd.fvt": "fvt",
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": [
      "uvu",
      "uvvu"
    ],
    "vnd.vivo": "viv",
    webm: "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv",
    mp2t: "ts"
  },
  "x-conference": {
    "x-cooltalk": "ice"
  },
  "x-world": {
    "x-vrml": [
      "vrm",
      "flr",
      "wrz",
      "xaf",
      "xof"
    ]
  }
};
(() => {
  const n = {};
  for (const t of Object.keys(xn))
    for (const e of Object.keys(xn[t])) {
      const r = xn[t][e];
      if (typeof r == "string")
        n[r] = t + "/" + e;
      else
        for (let s = 0; s < r.length; s++)
          n[r[s]] = t + "/" + e;
    }
  return n;
})();
const xi = [];
for (let n = 0; n < 256; n++) {
  let t = n;
  for (let e = 0; e < 8; e++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t = t >>> 1;
  xi[n] = t;
}
class Xt {
  constructor(t) {
    this.crc = t || -1;
  }
  append(t) {
    let e = this.crc | 0;
    for (let r = 0, s = t.length | 0; r < s; r++)
      e = e >>> 8 ^ xi[(e ^ t[r]) & 255];
    this.crc = e;
  }
  get() {
    return ~this.crc;
  }
}
class wi extends TransformStream {
  constructor() {
    let t;
    const e = new Xt();
    super({
      transform(r, s) {
        e.append(r), s.enqueue(r);
      },
      flush() {
        const r = new Uint8Array(4);
        new DataView(r.buffer).setUint32(0, e.get()), t.value = r;
      }
    }), t = this;
  }
}
function Go(n) {
  if (typeof TextEncoder == Qe) {
    n = unescape(encodeURIComponent(n));
    const t = new Uint8Array(n.length);
    for (let e = 0; e < t.length; e++)
      t[e] = n.charCodeAt(e);
    return t;
  } else
    return new TextEncoder().encode(n);
}
const Ee = {
  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat(n, t) {
    if (n.length === 0 || t.length === 0)
      return n.concat(t);
    const e = n[n.length - 1], r = Ee.getPartial(e);
    return r === 32 ? n.concat(t) : Ee._shiftRight(t, r, e | 0, n.slice(0, n.length - 1));
  },
  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength(n) {
    const t = n.length;
    if (t === 0)
      return 0;
    const e = n[t - 1];
    return (t - 1) * 32 + Ee.getPartial(e);
  },
  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp(n, t) {
    if (n.length * 32 < t)
      return n;
    n = n.slice(0, Math.ceil(t / 32));
    const e = n.length;
    return t = t & 31, e > 0 && t && (n[e - 1] = Ee.partial(t, n[e - 1] & 2147483648 >> t - 1, 1)), n;
  },
  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial(n, t, e) {
    return n === 32 ? t : (e ? t | 0 : t << 32 - n) + n * 1099511627776;
  },
  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial(n) {
    return Math.round(n / 1099511627776) || 32;
  },
  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight(n, t, e, r) {
    for (r === void 0 && (r = []); t >= 32; t -= 32)
      r.push(e), e = 0;
    if (t === 0)
      return r.concat(n);
    for (let c = 0; c < n.length; c++)
      r.push(e | n[c] >>> t), e = n[c] << 32 - t;
    const s = n.length ? n[n.length - 1] : 0, a = Ee.getPartial(s);
    return r.push(Ee.partial(t + a & 31, t + a > 32 ? e : r.pop(), 1)), r;
  }
}, zt = {
  bytes: {
    /** Convert from a bitArray to an array of bytes. */
    fromBits(n) {
      const e = Ee.bitLength(n) / 8, r = new Uint8Array(e);
      let s;
      for (let a = 0; a < e; a++)
        a & 3 || (s = n[a / 4]), r[a] = s >>> 24, s <<= 8;
      return r;
    },
    /** Convert from an array of bytes to a bitArray. */
    toBits(n) {
      const t = [];
      let e, r = 0;
      for (e = 0; e < n.length; e++)
        r = r << 8 | n[e], (e & 3) === 3 && (t.push(r), r = 0);
      return e & 3 && t.push(Ee.partial(8 * (e & 3), r)), t;
    }
  }
}, gi = {};
gi.sha1 = class {
  constructor(n) {
    const t = this;
    t.blockSize = 512, t._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], t._key = [1518500249, 1859775393, 2400959708, 3395469782], n ? (t._h = n._h.slice(0), t._buffer = n._buffer.slice(0), t._length = n._length) : t.reset();
  }
  /**
   * Reset the hash state.
   * @return this
   */
  reset() {
    const n = this;
    return n._h = n._init.slice(0), n._buffer = [], n._length = 0, n;
  }
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update(n) {
    const t = this;
    typeof n == "string" && (n = zt.utf8String.toBits(n));
    const e = t._buffer = Ee.concat(t._buffer, n), r = t._length, s = t._length = r + Ee.bitLength(n);
    if (s > 9007199254740991)
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    const a = new Uint32Array(e);
    let c = 0;
    for (let l = t.blockSize + r - (t.blockSize + r & t.blockSize - 1); l <= s; l += t.blockSize)
      t._block(a.subarray(16 * c, 16 * (c + 1))), c += 1;
    return e.splice(0, 16 * c), t;
  }
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
   */
  finalize() {
    const n = this;
    let t = n._buffer;
    const e = n._h;
    t = Ee.concat(t, [Ee.partial(1, 1)]);
    for (let r = t.length + 2; r & 15; r++)
      t.push(0);
    for (t.push(Math.floor(n._length / 4294967296)), t.push(n._length | 0); t.length; )
      n._block(t.splice(0, 16));
    return n.reset(), e;
  }
  /**
   * The SHA-1 logical functions f(0), f(1), ..., f(79).
   * @private
   */
  _f(n, t, e, r) {
    if (n <= 19)
      return t & e | ~t & r;
    if (n <= 39)
      return t ^ e ^ r;
    if (n <= 59)
      return t & e | t & r | e & r;
    if (n <= 79)
      return t ^ e ^ r;
  }
  /**
   * Circular left-shift operator.
   * @private
   */
  _S(n, t) {
    return t << n | t >>> 32 - n;
  }
  /**
   * Perform one cycle of SHA-1.
   * @param {Uint32Array|bitArray} words one block of words.
   * @private
   */
  _block(n) {
    const t = this, e = t._h, r = Array(80);
    for (let _ = 0; _ < 16; _++)
      r[_] = n[_];
    let s = e[0], a = e[1], c = e[2], l = e[3], f = e[4];
    for (let _ = 0; _ <= 79; _++) {
      _ >= 16 && (r[_] = t._S(1, r[_ - 3] ^ r[_ - 8] ^ r[_ - 14] ^ r[_ - 16]));
      const x = t._S(5, s) + t._f(_, a, c, l) + f + r[_] + t._key[Math.floor(_ / 20)] | 0;
      f = l, l = c, c = t._S(30, a), a = s, s = x;
    }
    e[0] = e[0] + s | 0, e[1] = e[1] + a | 0, e[2] = e[2] + c | 0, e[3] = e[3] + l | 0, e[4] = e[4] + f | 0;
  }
};
const _i = {};
_i.aes = class {
  constructor(n) {
    const t = this;
    t._tables = [[[], [], [], [], []], [[], [], [], [], []]], t._tables[0][0][0] || t._precompute();
    const e = t._tables[0][4], r = t._tables[1], s = n.length;
    let a, c, l, f = 1;
    if (s !== 4 && s !== 6 && s !== 8)
      throw new Error("invalid aes key size");
    for (t._key = [c = n.slice(0), l = []], a = s; a < 4 * s + 28; a++) {
      let _ = c[a - 1];
      (a % s === 0 || s === 8 && a % s === 4) && (_ = e[_ >>> 24] << 24 ^ e[_ >> 16 & 255] << 16 ^ e[_ >> 8 & 255] << 8 ^ e[_ & 255], a % s === 0 && (_ = _ << 8 ^ _ >>> 24 ^ f << 24, f = f << 1 ^ (f >> 7) * 283)), c[a] = c[a - s] ^ _;
    }
    for (let _ = 0; a; _++, a--) {
      const x = c[_ & 3 ? a : a - 4];
      a <= 4 || _ < 4 ? l[_] = x : l[_] = r[0][e[x >>> 24]] ^ r[1][e[x >> 16 & 255]] ^ r[2][e[x >> 8 & 255]] ^ r[3][e[x & 255]];
    }
  }
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt(n) {
    return this._crypt(n, 0);
  }
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt(n) {
    return this._crypt(n, 1);
  }
  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute() {
    const n = this._tables[0], t = this._tables[1], e = n[4], r = t[4], s = [], a = [];
    let c, l, f, _;
    for (let x = 0; x < 256; x++)
      a[(s[x] = x << 1 ^ (x >> 7) * 283) ^ x] = x;
    for (let x = c = 0; !e[x]; x ^= l || 1, c = a[c] || 1) {
      let w = c ^ c << 1 ^ c << 2 ^ c << 3 ^ c << 4;
      w = w >> 8 ^ w & 255 ^ 99, e[x] = w, r[w] = x, _ = s[f = s[l = s[x]]];
      let g = _ * 16843009 ^ f * 65537 ^ l * 257 ^ x * 16843008, k = s[w] * 257 ^ w * 16843008;
      for (let P = 0; P < 4; P++)
        n[P][x] = k = k << 24 ^ k >>> 8, t[P][w] = g = g << 24 ^ g >>> 8;
    }
    for (let x = 0; x < 5; x++)
      n[x] = n[x].slice(0), t[x] = t[x].slice(0);
  }
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt(n, t) {
    if (n.length !== 4)
      throw new Error("invalid aes block size");
    const e = this._key[t], r = e.length / 4 - 2, s = [0, 0, 0, 0], a = this._tables[t], c = a[0], l = a[1], f = a[2], _ = a[3], x = a[4];
    let w = n[0] ^ e[0], g = n[t ? 3 : 1] ^ e[1], k = n[2] ^ e[2], P = n[t ? 1 : 3] ^ e[3], m = 4, d, h, y;
    for (let T = 0; T < r; T++)
      d = c[w >>> 24] ^ l[g >> 16 & 255] ^ f[k >> 8 & 255] ^ _[P & 255] ^ e[m], h = c[g >>> 24] ^ l[k >> 16 & 255] ^ f[P >> 8 & 255] ^ _[w & 255] ^ e[m + 1], y = c[k >>> 24] ^ l[P >> 16 & 255] ^ f[w >> 8 & 255] ^ _[g & 255] ^ e[m + 2], P = c[P >>> 24] ^ l[w >> 16 & 255] ^ f[g >> 8 & 255] ^ _[k & 255] ^ e[m + 3], m += 4, w = d, g = h, k = y;
    for (let T = 0; T < 4; T++)
      s[t ? 3 & -T : T] = x[w >>> 24] << 24 ^ x[g >> 16 & 255] << 16 ^ x[k >> 8 & 255] << 8 ^ x[P & 255] ^ e[m++], d = w, w = g, g = k, k = P, P = d;
    return s;
  }
};
const Ko = {
  /** 
   * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
   * @param {TypedArray} typedArray The array to fill.
   * @return {TypedArray} The random values.
   */
  getRandomValues(n) {
    const t = new Uint32Array(n.buffer), e = (r) => {
      let s = 987654321;
      const a = 4294967295;
      return function() {
        return s = 36969 * (s & 65535) + (s >> 16) & a, r = 18e3 * (r & 65535) + (r >> 16) & a, (((s << 16) + r & a) / 4294967296 + 0.5) * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let r = 0, s; r < n.length; r += 4) {
      const a = e((s || Math.random()) * 4294967296);
      s = a() * 987654071, t[r / 4] = a() * 4294967296 | 0;
    }
    return n;
  }
}, yi = {};
yi.ctrGladman = class {
  constructor(n, t) {
    this._prf = n, this._initIv = t, this._iv = t;
  }
  reset() {
    this._iv = this._initIv;
  }
  /** Input some data to calculate.
   * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
   */
  update(n) {
    return this.calculate(this._prf, n, this._iv);
  }
  incWord(n) {
    if ((n >> 24 & 255) === 255) {
      let t = n >> 16 & 255, e = n >> 8 & 255, r = n & 255;
      t === 255 ? (t = 0, e === 255 ? (e = 0, r === 255 ? r = 0 : ++r) : ++e) : ++t, n = 0, n += t << 16, n += e << 8, n += r;
    } else
      n += 1 << 24;
    return n;
  }
  incCounter(n) {
    (n[0] = this.incWord(n[0])) === 0 && (n[1] = this.incWord(n[1]));
  }
  calculate(n, t, e) {
    let r;
    if (!(r = t.length))
      return [];
    const s = Ee.bitLength(t);
    for (let a = 0; a < r; a += 4) {
      this.incCounter(e);
      const c = n.encrypt(e);
      t[a] ^= c[0], t[a + 1] ^= c[1], t[a + 2] ^= c[2], t[a + 3] ^= c[3];
    }
    return Ee.clamp(t, s);
  }
};
const ot = {
  importKey(n) {
    return new ot.hmacSha1(zt.bytes.toBits(n));
  },
  pbkdf2(n, t, e, r) {
    if (e = e || 1e4, r < 0 || e < 0)
      throw new Error("invalid params to pbkdf2");
    const s = (r >> 5) + 1 << 2;
    let a, c, l, f, _;
    const x = new ArrayBuffer(s), w = new DataView(x);
    let g = 0;
    const k = Ee;
    for (t = zt.bytes.toBits(t), _ = 1; g < (s || 1); _++) {
      for (a = c = n.encrypt(k.concat(t, [_])), l = 1; l < e; l++)
        for (c = n.encrypt(c), f = 0; f < c.length; f++)
          a[f] ^= c[f];
      for (l = 0; g < (s || 1) && l < a.length; l++)
        w.setInt32(g, a[l]), g += 4;
    }
    return x.slice(0, r / 8);
  }
};
ot.hmacSha1 = class {
  constructor(n) {
    const t = this, e = t._hash = gi.sha1, r = [[], []];
    t._baseHash = [new e(), new e()];
    const s = t._baseHash[0].blockSize / 32;
    n.length > s && (n = new e().update(n).finalize());
    for (let a = 0; a < s; a++)
      r[0][a] = n[a] ^ 909522486, r[1][a] = n[a] ^ 1549556828;
    t._baseHash[0].update(r[0]), t._baseHash[1].update(r[1]), t._resultHash = new e(t._baseHash[0]);
  }
  reset() {
    const n = this;
    n._resultHash = new n._hash(n._baseHash[0]), n._updated = !1;
  }
  update(n) {
    const t = this;
    t._updated = !0, t._resultHash.update(n);
  }
  digest() {
    const n = this, t = n._resultHash.finalize(), e = new n._hash(n._baseHash[1]).update(t).finalize();
    return n.reset(), e;
  }
  encrypt(n) {
    if (this._updated)
      throw new Error("encrypt on already updated hmac called!");
    return this.update(n), this.digest(n);
  }
};
const Xo = typeof crypto != Qe && typeof crypto.getRandomValues == Ft, bi = "Invalid password", vi = "Invalid signature", Mn = "zipjs-abort-check-password";
function Ei(n) {
  return Xo ? crypto.getRandomValues(n) : Ko.getRandomValues(n);
}
const pt = 16, zo = "raw", ki = { name: "PBKDF2" }, Jo = { name: "HMAC" }, Qo = "SHA-1", ea = Object.assign({ hash: Jo }, ki), Tn = Object.assign({ iterations: 1e3, hash: { name: Qo } }, ki), ta = ["deriveBits"], At = [8, 12, 16], Et = [16, 24, 32], Ke = 10, na = [0, 0, 0, 0], rn = typeof crypto != Qe, Ct = rn && crypto.subtle, Si = rn && typeof Ct != Qe, Me = zt.bytes, ra = _i.aes, ia = yi.ctrGladman, sa = ot.hmacSha1;
let Dr = rn && Si && typeof Ct.importKey == Ft, Lr = rn && Si && typeof Ct.deriveBits == Ft;
class oa extends TransformStream {
  constructor({ password: t, rawPassword: e, signed: r, encryptionStrength: s, checkPasswordOnly: a }) {
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((c) => this.resolveReady = c),
          password: Ri(t, e),
          signed: r,
          strength: s - 1,
          pending: new Uint8Array()
        });
      },
      async transform(c, l) {
        const f = this, {
          password: _,
          strength: x,
          resolveReady: w,
          ready: g
        } = f;
        _ ? (await ca(f, x, _, Ie(c, 0, At[x] + 2)), c = Ie(c, At[x] + 2), a ? l.error(new Error(Mn)) : w()) : await g;
        const k = new Uint8Array(c.length - Ke - (c.length - Ke) % pt);
        l.enqueue(Ai(f, c, k, 0, Ke, !0));
      },
      async flush(c) {
        const {
          signed: l,
          ctr: f,
          hmac: _,
          pending: x,
          ready: w
        } = this;
        if (_ && f) {
          await w;
          const g = Ie(x, 0, x.length - Ke), k = Ie(x, x.length - Ke);
          let P = new Uint8Array();
          if (g.length) {
            const m = Rt(Me, g);
            _.update(m);
            const d = f.update(m);
            P = Tt(Me, d);
          }
          if (l) {
            const m = Ie(Tt(Me, _.digest()), 0, Ke);
            for (let d = 0; d < Ke; d++)
              if (m[d] != k[d])
                throw new Error(vi);
          }
          c.enqueue(P);
        }
      }
    });
  }
}
class aa extends TransformStream {
  constructor({ password: t, rawPassword: e, encryptionStrength: r }) {
    let s;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((a) => this.resolveReady = a),
          password: Ri(t, e),
          strength: r - 1,
          pending: new Uint8Array()
        });
      },
      async transform(a, c) {
        const l = this, {
          password: f,
          strength: _,
          resolveReady: x,
          ready: w
        } = l;
        let g = new Uint8Array();
        f ? (g = await la(l, _, f), x()) : await w;
        const k = new Uint8Array(g.length + a.length - a.length % pt);
        k.set(g, 0), c.enqueue(Ai(l, a, k, g.length, 0));
      },
      async flush(a) {
        const {
          ctr: c,
          hmac: l,
          pending: f,
          ready: _
        } = this;
        if (l && c) {
          await _;
          let x = new Uint8Array();
          if (f.length) {
            const w = c.update(Rt(Me, f));
            l.update(w), x = Tt(Me, w);
          }
          s.signature = Tt(Me, l.digest()).slice(0, Ke), a.enqueue(Nn(x, s.signature));
        }
      }
    }), s = this;
  }
}
function Ai(n, t, e, r, s, a) {
  const {
    ctr: c,
    hmac: l,
    pending: f
  } = n, _ = t.length - s;
  f.length && (t = Nn(f, t), e = da(e, _ - _ % pt));
  let x;
  for (x = 0; x <= _ - pt; x += pt) {
    const w = Rt(Me, Ie(t, x, x + pt));
    a && l.update(w);
    const g = c.update(w);
    a || l.update(g), e.set(Tt(Me, g), x + r);
  }
  return n.pending = Ie(t, x), e;
}
async function ca(n, t, e, r) {
  const s = await Ti(n, t, e, Ie(r, 0, At[t])), a = Ie(r, At[t]);
  if (s[0] != a[0] || s[1] != a[1])
    throw new Error(bi);
}
async function la(n, t, e) {
  const r = Ei(new Uint8Array(At[t])), s = await Ti(n, t, e, r);
  return Nn(r, s);
}
async function Ti(n, t, e, r) {
  n.password = null;
  const s = await fa(zo, e, ea, !1, ta), a = await ua(Object.assign({ salt: r }, Tn), s, 8 * (Et[t] * 2 + 2)), c = new Uint8Array(a), l = Rt(Me, Ie(c, 0, Et[t])), f = Rt(Me, Ie(c, Et[t], Et[t] * 2)), _ = Ie(c, Et[t] * 2);
  return Object.assign(n, {
    keys: {
      key: l,
      authentication: f,
      passwordVerification: _
    },
    ctr: new ia(new ra(l), Array.from(na)),
    hmac: new sa(f)
  }), _;
}
async function fa(n, t, e, r, s) {
  if (Dr)
    try {
      return await Ct.importKey(n, t, e, r, s);
    } catch {
      return Dr = !1, ot.importKey(t);
    }
  else
    return ot.importKey(t);
}
async function ua(n, t, e) {
  if (Lr)
    try {
      return await Ct.deriveBits(n, t, e);
    } catch {
      return Lr = !1, ot.pbkdf2(t, n.salt, Tn.iterations, e);
    }
  else
    return ot.pbkdf2(t, n.salt, Tn.iterations, e);
}
function Ri(n, t) {
  return t === ke ? Go(n) : t;
}
function Nn(n, t) {
  let e = n;
  return n.length + t.length && (e = new Uint8Array(n.length + t.length), e.set(n, 0), e.set(t, n.length)), e;
}
function da(n, t) {
  if (t && t > n.length) {
    const e = n;
    n = new Uint8Array(t), n.set(e, 0);
  }
  return n;
}
function Ie(n, t, e) {
  return n.subarray(t, e);
}
function Tt(n, t) {
  return n.fromBits(t);
}
function Rt(n, t) {
  return n.toBits(t);
}
const ht = 12;
class pa extends TransformStream {
  constructor({ password: t, passwordVerification: e, checkPasswordOnly: r }) {
    super({
      start() {
        Object.assign(this, {
          password: t,
          passwordVerification: e
        }), Fi(this, t);
      },
      transform(s, a) {
        const c = this;
        if (c.password) {
          const l = Ur(c, s.subarray(0, ht));
          if (c.password = null, l[ht - 1] != c.passwordVerification)
            throw new Error(bi);
          s = s.subarray(ht);
        }
        r ? a.error(new Error(Mn)) : a.enqueue(Ur(c, s));
      }
    });
  }
}
class ma extends TransformStream {
  constructor({ password: t, passwordVerification: e }) {
    super({
      start() {
        Object.assign(this, {
          password: t,
          passwordVerification: e
        }), Fi(this, t);
      },
      transform(r, s) {
        const a = this;
        let c, l;
        if (a.password) {
          a.password = null;
          const f = Ei(new Uint8Array(ht));
          f[ht - 1] = a.passwordVerification, c = new Uint8Array(r.length + f.length), c.set(Or(a, f), 0), l = ht;
        } else
          c = new Uint8Array(r.length), l = 0;
        c.set(Or(a, r), l), s.enqueue(c);
      }
    });
  }
}
function Ur(n, t) {
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = Ci(n) ^ t[r], qn(n, e[r]);
  return e;
}
function Or(n, t) {
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = Ci(n) ^ t[r], qn(n, t[r]);
  return e;
}
function Fi(n, t) {
  const e = [305419896, 591751049, 878082192];
  Object.assign(n, {
    keys: e,
    crcKey0: new Xt(e[0]),
    crcKey2: new Xt(e[2])
  });
  for (let r = 0; r < t.length; r++)
    qn(n, t.charCodeAt(r));
}
function qn(n, t) {
  let [e, r, s] = n.keys;
  n.crcKey0.append([t]), e = ~n.crcKey0.get(), r = Br(Math.imul(Br(r + Ii(e)), 134775813) + 1), n.crcKey2.append([r >>> 24]), s = ~n.crcKey2.get(), n.keys = [e, r, s];
}
function Ci(n) {
  const t = n.keys[2] | 2;
  return Ii(Math.imul(t, t ^ 1) >>> 8);
}
function Ii(n) {
  return n & 255;
}
function Br(n) {
  return n & 4294967295;
}
const Wr = "deflate-raw";
class ha extends TransformStream {
  constructor(t, { chunkSize: e, CompressionStream: r, CompressionStreamNative: s }) {
    super({});
    const { compressed: a, encrypted: c, useCompressionStream: l, zipCrypto: f, signed: _, level: x } = t, w = this;
    let g, k, P = Pi(super.readable);
    (!c || f) && _ && (g = new wi(), P = Ne(P, g)), a && (P = Li(P, l, { level: x, chunkSize: e }, s, r)), c && (f ? P = Ne(P, new ma(t)) : (k = new aa(t), P = Ne(P, k))), Di(w, P, () => {
      let m;
      c && !f && (m = k.signature), (!c || f) && _ && (m = new DataView(g.value.buffer).getUint32(0)), w.signature = m;
    });
  }
}
class xa extends TransformStream {
  constructor(t, { chunkSize: e, DecompressionStream: r, DecompressionStreamNative: s }) {
    super({});
    const { zipCrypto: a, encrypted: c, signed: l, signature: f, compressed: _, useCompressionStream: x } = t;
    let w, g, k = Pi(super.readable);
    c && (a ? k = Ne(k, new pa(t)) : (g = new oa(t), k = Ne(k, g))), _ && (k = Li(k, x, { chunkSize: e }, s, r)), (!c || a) && l && (w = new wi(), k = Ne(k, w)), Di(this, k, () => {
      if ((!c || a) && l) {
        const P = new DataView(w.value.buffer);
        if (f != P.getUint32(0, !1))
          throw new Error(vi);
      }
    });
  }
}
function Pi(n) {
  return Ne(n, new TransformStream({
    transform(t, e) {
      t && t.length && e.enqueue(t);
    }
  }));
}
function Di(n, t, e) {
  t = Ne(t, new TransformStream({ flush: e })), Object.defineProperty(n, "readable", {
    get() {
      return t;
    }
  });
}
function Li(n, t, e, r, s) {
  try {
    const a = t && r ? r : s;
    n = Ne(n, new a(Wr, e));
  } catch {
    if (t)
      try {
        n = Ne(n, new s(Wr, e));
      } catch {
        return n;
      }
    else
      return n;
  }
  return n;
}
function Ne(n, t) {
  return n.pipeThrough(t);
}
const wa = "message", ga = "start", _a = "pull", Mr = "data", ya = "ack", Nr = "close", ba = "deflate", Ui = "inflate";
class va extends TransformStream {
  constructor(t, e) {
    super({});
    const r = this, { codecType: s } = t;
    let a;
    s.startsWith(ba) ? a = ha : s.startsWith(Ui) && (a = xa);
    let c = 0, l = 0;
    const f = new a(t, e), _ = super.readable, x = new TransformStream({
      transform(g, k) {
        g && g.length && (l += g.length, k.enqueue(g));
      },
      flush() {
        Object.assign(r, {
          inputSize: l
        });
      }
    }), w = new TransformStream({
      transform(g, k) {
        g && g.length && (c += g.length, k.enqueue(g));
      },
      flush() {
        const { signature: g } = f;
        Object.assign(r, {
          signature: g,
          outputSize: c,
          inputSize: l
        });
      }
    });
    Object.defineProperty(r, "readable", {
      get() {
        return _.pipeThrough(x).pipeThrough(f).pipeThrough(w);
      }
    });
  }
}
class Ea extends TransformStream {
  constructor(t) {
    let e;
    super({
      transform: r,
      flush(s) {
        e && e.length && s.enqueue(e);
      }
    });
    function r(s, a) {
      if (e) {
        const c = new Uint8Array(e.length + s.length);
        c.set(e), c.set(s, e.length), s = c, e = null;
      }
      s.length > t ? (a.enqueue(s.slice(0, t)), r(s.slice(t), a)) : e = s;
    }
  }
}
let Oi = typeof Worker != Qe;
class wn {
  constructor(t, { readable: e, writable: r }, { options: s, config: a, streamOptions: c, useWebWorkers: l, transferStreams: f, scripts: _ }, x) {
    const { signal: w } = c;
    return Object.assign(t, {
      busy: !0,
      readable: e.pipeThrough(new Ea(a.chunkSize)).pipeThrough(new ka(e, c), { signal: w }),
      writable: r,
      options: Object.assign({}, s),
      scripts: _,
      transferStreams: f,
      terminate() {
        return new Promise((g) => {
          const { worker: k, busy: P } = t;
          k ? (P ? t.resolveTerminated = g : (k.terminate(), g()), t.interface = null) : g();
        });
      },
      onTaskFinished() {
        const { resolveTerminated: g } = t;
        g && (t.resolveTerminated = null, t.terminated = !0, t.worker.terminate(), g()), t.busy = !1, x(t);
      }
    }), (l && Oi ? Sa : Bi)(t, a);
  }
}
class ka extends TransformStream {
  constructor(t, { onstart: e, onprogress: r, size: s, onend: a }) {
    let c = 0;
    super({
      async start() {
        e && await gn(e, s);
      },
      async transform(l, f) {
        c += l.length, r && await gn(r, c, s), f.enqueue(l);
      },
      async flush() {
        t.size = c, a && await gn(a, c);
      }
    });
  }
}
async function gn(n, ...t) {
  try {
    await n(...t);
  } catch {
  }
}
function Bi(n, t) {
  return {
    run: () => Aa(n, t)
  };
}
function Sa(n, t) {
  const { baseURL: e, chunkSize: r } = t;
  if (!n.interface) {
    let s;
    try {
      s = Fa(n.scripts[0], e, n);
    } catch {
      return Oi = !1, Bi(n, t);
    }
    Object.assign(n, {
      worker: s,
      interface: {
        run: () => Ta(n, { chunkSize: r })
      }
    });
  }
  return n.interface;
}
async function Aa({ options: n, readable: t, writable: e, onTaskFinished: r }, s) {
  try {
    const a = new va(n, s);
    await t.pipeThrough(a).pipeTo(e, { preventClose: !0, preventAbort: !0 });
    const {
      signature: c,
      inputSize: l,
      outputSize: f
    } = a;
    return {
      signature: c,
      inputSize: l,
      outputSize: f
    };
  } finally {
    r();
  }
}
async function Ta(n, t) {
  let e, r;
  const s = new Promise((g, k) => {
    e = g, r = k;
  });
  Object.assign(n, {
    reader: null,
    writer: null,
    resolveResult: e,
    rejectResult: r,
    result: s
  });
  const { readable: a, options: c, scripts: l } = n, { writable: f, closed: _ } = Ra(n.writable), x = $t({
    type: ga,
    scripts: l.slice(1),
    options: c,
    config: t,
    readable: a,
    writable: f
  }, n);
  x || Object.assign(n, {
    reader: a.getReader(),
    writer: f.getWriter()
  });
  const w = await s;
  return x || await f.getWriter().close(), await _, w;
}
function Ra(n) {
  let t;
  const e = new Promise((s) => t = s);
  return { writable: new WritableStream({
    async write(s) {
      const a = n.getWriter();
      await a.ready, await a.write(s), a.releaseLock();
    },
    close() {
      t();
    },
    abort(s) {
      return n.getWriter().abort(s);
    }
  }), closed: e };
}
let qr = !0, jr = !0;
function Fa(n, t, e) {
  const r = { type: "module" };
  let s, a;
  typeof n == Ft && (n = n());
  try {
    s = new URL(n, t);
  } catch {
    s = n;
  }
  if (qr)
    try {
      a = new Worker(s);
    } catch {
      qr = !1, a = new Worker(s, r);
    }
  else
    a = new Worker(s, r);
  return a.addEventListener(wa, (c) => Ca(c, e)), a;
}
function $t(n, { worker: t, writer: e, onTaskFinished: r, transferStreams: s }) {
  try {
    const { value: a, readable: c, writable: l } = n, f = [];
    if (a && (a.byteLength < a.buffer.byteLength ? n.value = a.buffer.slice(0, a.byteLength) : n.value = a.buffer, f.push(n.value)), s && jr ? (c && f.push(c), l && f.push(l)) : n.readable = n.writable = null, f.length)
      try {
        return t.postMessage(n, f), !0;
      } catch {
        jr = !1, n.readable = n.writable = null, t.postMessage(n);
      }
    else
      t.postMessage(n);
  } catch (a) {
    throw e && e.releaseLock(), r(), a;
  }
}
async function Ca({ data: n }, t) {
  const { type: e, value: r, messageId: s, result: a, error: c } = n, { reader: l, writer: f, resolveResult: _, rejectResult: x, onTaskFinished: w } = t;
  try {
    if (c) {
      const { message: k, stack: P, code: m, name: d } = c, h = new Error(k);
      Object.assign(h, { stack: P, code: m, name: d }), g(h);
    } else {
      if (e == _a) {
        const { value: k, done: P } = await l.read();
        $t({ type: Mr, value: k, done: P, messageId: s }, t);
      }
      e == Mr && (await f.ready, await f.write(new Uint8Array(r)), $t({ type: ya, messageId: s }, t)), e == Nr && g(null, a);
    }
  } catch (k) {
    $t({ type: Nr, messageId: s }, t), g(k);
  }
  function g(k, P) {
    k ? x(k) : _(P), f && f.releaseLock(), w();
  }
}
let it = [];
const _n = [];
let Hr = 0;
async function Ia(n, t) {
  const { options: e, config: r } = t, { transferStreams: s, useWebWorkers: a, useCompressionStream: c, codecType: l, compressed: f, signed: _, encrypted: x } = e, { workerScripts: w, maxWorkers: g } = r;
  t.transferStreams = s || s === ke;
  const k = !f && !_ && !x && !t.transferStreams;
  return t.useWebWorkers = !k && (a || a === ke && r.useWebWorkers), t.scripts = t.useWebWorkers && w ? w[l] : [], e.useCompressionStream = c || c === ke && r.useCompressionStream, (await P()).run();
  async function P() {
    const d = it.find((h) => !h.busy);
    if (d)
      return $r(d), new wn(d, n, t, m);
    if (it.length < g) {
      const h = { indexWorker: Hr };
      return Hr++, it.push(h), new wn(h, n, t, m);
    } else
      return new Promise((h) => _n.push({ resolve: h, stream: n, workerOptions: t }));
  }
  function m(d) {
    if (_n.length) {
      const [{ resolve: h, stream: y, workerOptions: T }] = _n.splice(0, 1);
      h(new wn(d, y, T, m));
    } else d.worker ? ($r(d), Pa(d, t)) : it = it.filter((h) => h != d);
  }
}
function Pa(n, t) {
  const { config: e } = t, { terminateWorkerTimeout: r } = e;
  Number.isFinite(r) && r >= 0 && (n.terminated ? n.terminated = !1 : n.terminateTimeout = setTimeout(async () => {
    it = it.filter((s) => s != n);
    try {
      await n.terminate();
    } catch {
    }
  }, r));
}
function $r(n) {
  const { terminateTimeout: t } = n;
  t && (clearTimeout(t), n.terminateTimeout = null);
}
function Da(n, t = {}) {
  const e = `const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={bytes:{p(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)3&s||(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},m(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3&~n||(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t.A=e.A):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e.A=0,e}update(e){const t=this;"string"==typeof e&&(e=I._.m(e));const n=t.C=_.concat(t.C,e),r=t.A,i=t.A=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}P(){const e=this;let t=e.C;const n=e.S;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e.A/4294967296)),t.push(0|e.A);t.length;)e.I(t.splice(0,16));return e.reset(),n}D(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}V(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.V(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.V(5,o)+n.D(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.V(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.R(I.bytes.m(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.bytes.m(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=P,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).P());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.P(),n=new e.M(e.U[1]).update(t).P();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.bytes,X=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255&~(e>>24))e+=1<<24;else{let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.R;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),signed:r,X:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:o,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.B(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.B(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,$:u,passwordVerification:w},Y:new Y(new X(l),e.from(F)),Z:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.p(t)}function ae(e,t){return e.m(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new x(r[0]),te:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Le(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}He.ge=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.Se=e=>256>e?je[e]:je[256+(e>>>7)],He.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He.Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le._e=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Ie=e,i.Pe=t,i.De=n,i.Ve=r,i.Re=s}Le.Be=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Ee=new Le(Le._e,He.ze,257,286,15),Le.Me=new Le(Le.Be,He.Ce,0,30,15),Le.Ue=new Le(null,He.xe,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ge[n]+256+1)]++,M[2*He.Se(t)]++),!(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=He.ge[s],Y(i+256+1,t),o=He.ze[i],0!==o&&(s-=He.ke[i],X(s,o)),r--,i=He.Se(r),Y(i,n),o=He.Ce[i],0!==o&&(r-=He.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*He.Ae[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le._e,Le.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He.Ae[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&$e(t,r[i+1],r[i],e.le)&&i++,!$e(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),D=S,V=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=Xe,c=0,K.re=E,K.ie=Le.Ee,N.re=M,N.ie=Le.Me,O.re=U,O.ie=Le.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==Xe?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Re!=Je[t].Re&&0!==e.qe&&(r=e.Ye(1)),D!=t&&(D=t,P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve),V=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.$e||!r.et&&0!==r.We||n==Ye&&4!=i)return r.Le=Qe[4],Oe;if(0===r.tt)return r.Le=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=Qe[7],-5;if(n==Ye&&0!==t.We)return r.Le=Qe[7],-5;if(0!==t.We||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.tt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le._e),$(),9>1+H+10-F&&(X(2,3),Y(256,Le._e),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={He(e,t){const n=this;return n.Fe=new et,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Oe},Qe(){const e=this;if(!e.Fe)return Oe;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Oe},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Oe},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;g&k;k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Le="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=st),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Le="oversubscribed distance tree":h==it?(w.Le="incomplete distance tree",h=st):-4!=h&&(w.Le="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(64&u)return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(64&u)return 32&u?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(16&k){a=15&k,i=n[g+2],t=2;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}if(32&k){t=7;break}return t=9,y.Le="invalid literal/length code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],16&k){a=15&k,l=n[g+2],t=4;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 9:return m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);default:return m=rt,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ht.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=rt,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):rt}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),rt):(e.zt=r,n.gt.kt=new yt(n,1<<r),t(n),0)),e.At=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return rt;const s=e.gt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=mt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=mt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Le="incorrect header check",s.marker=5;break}if(!(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=mt,e.Le="need dictionary",s.marker=0,rt;case 7:if(n=s.kt.ut(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case mt:return st;default:return rt}},e._t=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return rt;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return rt;const c=e.gt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.We))return it;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==bt[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?st:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Pt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t.At(0),c&&a===it){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}kt.prototype={xt(e){const t=this;return t.gt=new gt,e||(e=15),t.gt.xt(t,e)},At(e){const t=this;return t.gt?t.gt.At(t,e):rt},Ct(){const e=this;if(!e.gt)return rt;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):rt},_t(e,t){const n=this;return n.gt?n.gt._t(n,e,t):rt},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};
`, r = () => t.useDataURI ? "data:text/javascript," + encodeURIComponent(e) : URL.createObjectURL(new Blob([e], { type: "text/javascript" }));
  n({ workerScripts: { inflate: [r], deflate: [r] } });
}
const La = "Writer iterator completed too soon", Ua = "Content-Type", Oa = 64 * 1024, Wi = "writable";
class jn {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = !0;
  }
}
class Mi extends jn {
  get readable() {
    const t = this, { chunkSize: e = Oa } = t, r = new ReadableStream({
      start() {
        this.chunkOffset = 0;
      },
      async pull(s) {
        const { offset: a = 0, size: c, diskNumberStart: l } = r, { chunkOffset: f } = this;
        s.enqueue(await _e(t, a + f, Math.min(e, c - f), l)), f + e > c ? s.close() : this.chunkOffset += e;
      }
    });
    return r;
  }
}
class Rn extends Mi {
  constructor(t) {
    super(), Object.assign(this, {
      blob: t,
      size: t.size
    });
  }
  async readUint8Array(t, e) {
    const r = this, s = t + e;
    let c = await (t || s < r.size ? r.blob.slice(t, s) : r.blob).arrayBuffer();
    return c.byteLength > e && (c = c.slice(t, s)), new Uint8Array(c);
  }
}
class Ba extends jn {
  constructor(t) {
    super();
    const e = this, r = new TransformStream(), s = [];
    t && s.push([Ua, t]), Object.defineProperty(e, Wi, {
      get() {
        return r.writable;
      }
    }), e.blob = new Response(r.readable, { headers: s }).blob();
  }
  getData() {
    return this.blob;
  }
}
class Wa extends Mi {
  constructor(t) {
    super(), this.readers = t;
  }
  async init() {
    const t = this, { readers: e } = t;
    t.lastDiskNumber = 0, t.lastDiskOffset = 0, await Promise.all(e.map(async (r, s) => {
      await r.init(), s != e.length - 1 && (t.lastDiskOffset += r.size), t.size += r.size;
    })), super.init();
  }
  async readUint8Array(t, e, r = 0) {
    const s = this, { readers: a } = this;
    let c, l = r;
    l == -1 && (l = a.length - 1);
    let f = t;
    for (; f >= a[l].size; )
      f -= a[l].size, l++;
    const _ = a[l], x = _.size;
    if (f + e <= x)
      c = await _e(_, f, e);
    else {
      const w = x - f;
      c = new Uint8Array(e), c.set(await _e(_, f, w)), c.set(await s.readUint8Array(t + w, e - w, r), w);
    }
    return s.lastDiskNumber = Math.max(l, s.lastDiskNumber), c;
  }
}
class Yr extends jn {
  constructor(t, e = 4294967295) {
    super();
    const r = this;
    Object.assign(r, {
      diskNumber: 0,
      diskOffset: 0,
      size: 0,
      maxSize: e,
      availableSize: e
    });
    let s, a, c;
    const l = new WritableStream({
      async write(x) {
        const { availableSize: w } = r;
        if (c)
          x.length >= w ? (await f(x.slice(0, w)), await _(), r.diskOffset += s.size, r.diskNumber++, c = null, await this.write(x.slice(w))) : await f(x);
        else {
          const { value: g, done: k } = await t.next();
          if (k && !g)
            throw new Error(La);
          s = g, s.size = 0, s.maxSize && (r.maxSize = s.maxSize), r.availableSize = r.maxSize, await Jt(s), a = g.writable, c = a.getWriter(), await this.write(x);
        }
      },
      async close() {
        await c.ready, await _();
      }
    });
    Object.defineProperty(r, Wi, {
      get() {
        return l;
      }
    });
    async function f(x) {
      const w = x.length;
      w && (await c.ready, await c.write(x), s.size += w, r.size += w, r.availableSize -= w);
    }
    async function _() {
      a.size = s.size, await c.close();
    }
  }
}
async function Jt(n, t) {
  if (n.init && !n.initialized)
    await n.init(t);
  else
    return Promise.resolve();
}
function Ma(n) {
  return Array.isArray(n) && (n = new Wa(n)), n instanceof ReadableStream && (n = {
    readable: n
  }), n;
}
function Na(n) {
  n.writable === ke && typeof n.next == Ft && (n = new Yr(n)), n instanceof WritableStream && (n = {
    writable: n
  });
  const { writable: t } = n;
  return t.size === ke && (t.size = 0), n instanceof Yr || Object.assign(n, {
    diskNumber: 0,
    diskOffset: 0,
    availableSize: 1 / 0,
    maxSize: 1 / 0
  }), n;
}
function _e(n, t, e, r) {
  return n.readUint8Array(t, e, r);
}
const Ni = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split(""), qa = Ni.length == 256;
function ja(n) {
  if (qa) {
    let t = "";
    for (let e = 0; e < n.length; e++)
      t += Ni[n[e]];
    return t;
  } else
    return new TextDecoder().decode(n);
}
function Yt(n, t) {
  return t && t.trim().toLowerCase() == "cp437" ? ja(n) : new TextDecoder(t).decode(n);
}
const qi = "filename", ji = "rawFilename", Hi = "comment", $i = "rawComment", Yi = "uncompressedSize", Zi = "compressedSize", Vi = "offset", Fn = "diskNumberStart", Cn = "lastModDate", In = "rawLastModDate", Gi = "lastAccessDate", Ha = "rawLastAccessDate", Ki = "creationDate", $a = "rawCreationDate", Ya = "internalFileAttribute", Za = "internalFileAttributes", Va = "externalFileAttribute", Ga = "externalFileAttributes", Ka = "msDosCompatible", Xa = "zip64", za = "encrypted", Ja = "version", Qa = "versionMadeBy", ec = "zipCrypto", tc = "directory", nc = "executable", rc = [
  qi,
  ji,
  Zi,
  Yi,
  Cn,
  In,
  Hi,
  $i,
  Gi,
  Ki,
  Vi,
  Fn,
  Fn,
  Ya,
  Za,
  Va,
  Ga,
  Ka,
  Xa,
  za,
  Ja,
  Qa,
  ec,
  tc,
  nc,
  "bitFlag",
  "signature",
  "filenameUTF8",
  "commentUTF8",
  "compressionMethod",
  "extraField",
  "rawExtraField",
  "extraFieldZip64",
  "extraFieldUnicodePath",
  "extraFieldUnicodeComment",
  "extraFieldAES",
  "extraFieldNTFS",
  "extraFieldExtendedTimestamp"
];
class Zr {
  constructor(t) {
    rc.forEach((e) => this[e] = t[e]);
  }
}
const yn = "File format is not recognized", ic = "End of central directory not found", sc = "End of Zip64 central directory locator not found", oc = "Central directory header not found", ac = "Local file header not found", cc = "Zip64 extra field not found", lc = "File contains encrypted entry", fc = "Encryption method not supported", Vr = "Compression method not supported", Gr = "Split zip file", Kr = "utf-8", Xr = "cp437", uc = [
  [Yi, st],
  [Zi, st],
  [Vi, st],
  [Fn, Xe]
], dc = {
  [Xe]: {
    getValue: ce,
    bytes: 4
  },
  [st]: {
    getValue: Zt,
    bytes: 8
  }
};
class zr {
  constructor(t, e = {}) {
    Object.assign(this, {
      reader: Ma(t),
      options: e,
      config: Zo()
    });
  }
  async *getEntriesGenerator(t = {}) {
    const e = this;
    let { reader: r } = e;
    const { config: s } = e;
    if (await Jt(r), (r.size === ke || !r.readUint8Array) && (r = new Rn(await new Response(r.readable).blob()), await Jt(r)), r.size < ut)
      throw new Error(yn);
    r.chunkSize = Vo(s);
    const a = await gc(r, Do, r.size, ut, Xe * 16);
    if (!a) {
      const v = await _e(r, 0, 4), S = he(v);
      throw ce(S) == Po ? new Error(Gr) : new Error(ic);
    }
    const c = he(a);
    let l = ce(c, 12), f = ce(c, 16);
    const _ = a.offset, x = me(c, 20), w = _ + ut + x;
    let g = me(c, 4);
    const k = r.lastDiskNumber || 0;
    let P = me(c, 6), m = me(c, 8), d = 0, h = 0;
    if (f == st || l == st || m == Xe || P == Xe) {
      const v = await _e(r, a.offset - mn, mn), S = he(v);
      if (ce(S, 0) == Lo) {
        f = Zt(S, 8);
        let M = await _e(r, f, hn, -1), L = he(M);
        const Y = a.offset - mn - hn;
        if (ce(L, 0) != kr && f != Y) {
          const H = f;
          f = Y, d = f - H, M = await _e(r, f, hn, -1), L = he(M);
        }
        if (ce(L, 0) != kr)
          throw new Error(sc);
        g == Xe && (g = ce(L, 16)), P == Xe && (P = ce(L, 20)), m == Xe && (m = Zt(L, 32)), l == st && (l = Zt(L, 40)), f -= l;
      }
    }
    if (f >= r.size && (d = r.size - f - l - ut, f = r.size - l - ut), k != g)
      throw new Error(Gr);
    if (f < 0)
      throw new Error(yn);
    let y = 0, T = await _e(r, f, l, P), D = he(T);
    if (l) {
      const v = a.offset - l;
      if (ce(D, y) != Er && f != v) {
        const S = f;
        f = v, d += f - S, T = await _e(r, f, l, P), D = he(T);
      }
    }
    const A = a.offset - f - (r.lastDiskOffset || 0);
    if (l != A && A >= 0 && (l = A, T = await _e(r, f, l, P), D = he(T)), f < 0 || f >= r.size)
      throw new Error(yn);
    const R = ve(e, t, "filenameEncoding"), F = ve(e, t, "commentEncoding");
    for (let v = 0; v < m; v++) {
      const S = new pc(r, s, e.options);
      if (ce(D, y) != Er)
        throw new Error(oc);
      Xi(S, D, y + 6);
      const M = !!S.bitFlag.languageEncodingFlag, L = y + 46, Y = L + S.filenameLength, H = Y + S.extraFieldLength, j = me(D, y + 4), K = j >> 8 == 0, V = j >> 8 == 3, oe = T.subarray(L, Y), Z = me(D, y + 32), J = H + Z, $ = T.subarray(H, J), ee = M, Pe = M, de = ce(D, y + 38), le = K && (xt(D, y + 38) & Rr) == Rr || V && (de >> 16 & Fr) == Fr || oe.length && oe[oe.length - 1] == Ir.charCodeAt(0), wt = V && (de >> 16 & Cr) == Cr, qe = ce(D, y + 42) + d;
      Object.assign(S, {
        versionMadeBy: j,
        msDosCompatible: K,
        compressedSize: 0,
        uncompressedSize: 0,
        commentLength: Z,
        directory: le,
        offset: qe,
        diskNumberStart: me(D, y + 34),
        internalFileAttributes: me(D, y + 36),
        externalFileAttributes: de,
        rawFilename: oe,
        filenameUTF8: ee,
        commentUTF8: Pe,
        rawExtraField: T.subarray(Y, H),
        executable: wt
      }), S.internalFileAttribute = S.internalFileAttributes, S.externalFileAttribute = S.externalFileAttributes;
      const at = ve(e, t, "decodeText") || Yt, et = ee ? Kr : R || Xr, tt = Pe ? Kr : F || Xr;
      let ge = at(oe, et);
      ge === ke && (ge = Yt(oe, et));
      let fe = at($, tt);
      fe === ke && (fe = Yt($, tt)), Object.assign(S, {
        rawComment: $,
        filename: ge,
        comment: fe,
        directory: le || ge.endsWith(Ir)
      }), h = Math.max(qe, h), zi(S, S, D, y + 6), S.zipCrypto = S.encrypted && !S.extraFieldAES;
      const je = new Zr(S);
      je.getData = (u, i) => S.getData(u, je, i), y = J;
      const { onprogress: ue } = t;
      if (ue)
        try {
          await ue(v + 1, m, new Zr(S));
        } catch {
        }
      yield je;
    }
    const b = ve(e, t, "extractPrependedData"), C = ve(e, t, "extractAppendedData");
    return b && (e.prependedData = h > 0 ? await _e(r, 0, h) : new Uint8Array()), e.comment = x ? await _e(r, _ + ut, x) : new Uint8Array(), C && (e.appendedData = w < r.size ? await _e(r, w, r.size - w) : new Uint8Array()), !0;
  }
  async getEntries(t = {}) {
    const e = [];
    for await (const r of this.getEntriesGenerator(t))
      e.push(r);
    return e;
  }
  async close() {
  }
}
class pc {
  constructor(t, e, r) {
    Object.assign(this, {
      reader: t,
      config: e,
      options: r
    });
  }
  async getData(t, e, r = {}) {
    const s = this, {
      reader: a,
      offset: c,
      diskNumberStart: l,
      extraFieldAES: f,
      compressionMethod: _,
      config: x,
      bitFlag: w,
      signature: g,
      rawLastModDate: k,
      uncompressedSize: P,
      compressedSize: m
    } = s, d = e.localDirectory = {}, h = await _e(a, c, 30, l), y = he(h);
    let T = ve(s, r, "password"), D = ve(s, r, "rawPassword");
    const A = ve(s, r, "passThrough");
    if (T = T && T.length && T, D = D && D.length && D, f && f.originalCompressionMethod != Co)
      throw new Error(Vr);
    if (_ != Fo && _ != Ro && !A)
      throw new Error(Vr);
    if (ce(y, 0) != Io)
      throw new Error(ac);
    Xi(d, y, 4), d.rawExtraField = d.extraFieldLength ? await _e(a, c + 30 + d.filenameLength, d.extraFieldLength, l) : new Uint8Array(), zi(s, d, y, 4, !0), Object.assign(e, {
      lastAccessDate: d.lastAccessDate,
      creationDate: d.creationDate
    });
    const R = s.encrypted && d.encrypted && !A, F = R && !f;
    if (A || (e.zipCrypto = F), R) {
      if (!F && f.strength === ke)
        throw new Error(fc);
      if (!T && !D)
        throw new Error(lc);
    }
    const b = c + 30 + d.filenameLength + d.extraFieldLength, C = m, v = a.readable;
    Object.assign(v, {
      diskNumberStart: l,
      offset: b,
      size: C
    });
    const S = ve(s, r, "signal"), M = ve(s, r, "checkPasswordOnly");
    M && (t = new WritableStream()), t = Na(t), await Jt(t, A ? m : P);
    const { writable: L } = t, { onstart: Y, onprogress: H, onend: j } = r, K = {
      options: {
        codecType: Ui,
        password: T,
        rawPassword: D,
        zipCrypto: F,
        encryptionStrength: f && f.strength,
        signed: ve(s, r, "checkSignature") && !A,
        passwordVerification: F && (w.dataDescriptor ? k >>> 8 & 255 : g >>> 24 & 255),
        signature: g,
        compressed: _ != 0 && !A,
        encrypted: s.encrypted && !A,
        useWebWorkers: ve(s, r, "useWebWorkers"),
        useCompressionStream: ve(s, r, "useCompressionStream"),
        transferStreams: ve(s, r, "transferStreams"),
        checkPasswordOnly: M
      },
      config: x,
      streamOptions: { signal: S, size: C, onstart: Y, onprogress: H, onend: j }
    };
    let V = 0;
    try {
      ({ outputSize: V } = await Ia({ readable: v, writable: L }, K));
    } catch (oe) {
      if (!M || oe.message != Mn)
        throw oe;
    } finally {
      const oe = ve(s, r, "preventClose");
      L.size += V, !oe && !L.locked && await L.getWriter().close();
    }
    return M ? ke : t.getData ? t.getData() : L;
  }
}
function Xi(n, t, e) {
  const r = n.rawBitFlag = me(t, e + 2), s = (r & Sr) == Sr, a = ce(t, e + 6);
  Object.assign(n, {
    encrypted: s,
    version: me(t, e),
    bitFlag: {
      level: (r & Ho) >> 1,
      dataDescriptor: (r & Ar) == Ar,
      languageEncodingFlag: (r & Tr) == Tr
    },
    rawLastModDate: a,
    lastModDate: _c(a),
    filenameLength: me(t, e + 22),
    extraFieldLength: me(t, e + 24)
  });
}
function zi(n, t, e, r, s) {
  const { rawExtraField: a } = t, c = t.extraField = /* @__PURE__ */ new Map(), l = he(new Uint8Array(a));
  let f = 0;
  try {
    for (; f < a.length; ) {
      const h = me(l, f), y = me(l, f + 2);
      c.set(h, {
        type: h,
        data: a.slice(f + 4, f + 4 + y)
      }), f += 4 + y;
    }
  } catch {
  }
  const _ = me(e, r + 4);
  Object.assign(t, {
    signature: ce(e, r + 10),
    uncompressedSize: ce(e, r + 18),
    compressedSize: ce(e, r + 14)
  });
  const x = c.get(Uo);
  x && (mc(x, t), t.extraFieldZip64 = x);
  const w = c.get(No);
  w && (Jr(w, qi, ji, t, n), t.extraFieldUnicodePath = w);
  const g = c.get(qo);
  g && (Jr(g, Hi, $i, t, n), t.extraFieldUnicodeComment = g);
  const k = c.get(Oo);
  k ? (hc(k, t, _), t.extraFieldAES = k) : t.compressionMethod = _;
  const P = c.get(Bo);
  P && (xc(P, t), t.extraFieldNTFS = P);
  const m = c.get(Mo);
  m && (wc(m, t, s), t.extraFieldExtendedTimestamp = m);
  const d = c.get(jo);
  d && (t.extraFieldUSDZ = d);
}
function mc(n, t) {
  t.zip64 = !0;
  const e = he(n.data), r = uc.filter(([s, a]) => t[s] == a);
  for (let s = 0, a = 0; s < r.length; s++) {
    const [c, l] = r[s];
    if (t[c] == l) {
      const f = dc[l];
      t[c] = n[c] = f.getValue(e, a), a += f.bytes;
    } else if (n[c])
      throw new Error(cc);
  }
}
function Jr(n, t, e, r, s) {
  const a = he(n.data), c = new Xt();
  c.append(s[e]);
  const l = he(new Uint8Array(4));
  l.setUint32(0, c.get(), !0);
  const f = ce(a, 1);
  Object.assign(n, {
    version: xt(a, 0),
    [t]: Yt(n.data.subarray(5)),
    valid: !s.bitFlag.languageEncodingFlag && f == ce(l, 0)
  }), n.valid && (r[t] = n[t], r[t + "UTF8"] = !0);
}
function hc(n, t, e) {
  const r = he(n.data), s = xt(r, 4);
  Object.assign(n, {
    vendorVersion: xt(r, 0),
    vendorId: xt(r, 2),
    strength: s,
    originalCompressionMethod: e,
    compressionMethod: me(r, 5)
  }), t.compressionMethod = n.compressionMethod;
}
function xc(n, t) {
  const e = he(n.data);
  let r = 4, s;
  try {
    for (; r < n.data.length && !s; ) {
      const a = me(e, r), c = me(e, r + 2);
      a == Wo && (s = n.data.slice(r + 4, r + 4 + c)), r += 4 + c;
    }
  } catch {
  }
  try {
    if (s && s.length == 24) {
      const a = he(s), c = a.getBigUint64(0, !0), l = a.getBigUint64(8, !0), f = a.getBigUint64(16, !0);
      Object.assign(n, {
        rawLastModDate: c,
        rawLastAccessDate: l,
        rawCreationDate: f
      });
      const _ = bn(c), x = bn(l), w = bn(f), g = { lastModDate: _, lastAccessDate: x, creationDate: w };
      Object.assign(n, g), Object.assign(t, g);
    }
  } catch {
  }
}
function wc(n, t, e) {
  const r = he(n.data), s = xt(r, 0), a = [], c = [];
  e ? ((s & 1) == 1 && (a.push(Cn), c.push(In)), (s & 2) == 2 && (a.push(Gi), c.push(Ha)), (s & 4) == 4 && (a.push(Ki), c.push($a))) : n.data.length >= 5 && (a.push(Cn), c.push(In));
  let l = 1;
  a.forEach((f, _) => {
    if (n.data.length >= l + 4) {
      const x = ce(r, l);
      t[f] = n[f] = new Date(x * 1e3);
      const w = c[_];
      n[w] = x;
    }
    l += 4;
  });
}
async function gc(n, t, e, r, s) {
  const a = new Uint8Array(4), c = he(a);
  yc(c, 0, t);
  const l = r + s;
  return await f(r) || await f(Math.min(l, e));
  async function f(_) {
    const x = e - _, w = await _e(n, x, _);
    for (let g = w.length - r; g >= 0; g--)
      if (w[g] == a[0] && w[g + 1] == a[1] && w[g + 2] == a[2] && w[g + 3] == a[3])
        return {
          offset: x + g,
          buffer: w.slice(g, g + r).buffer
        };
  }
}
function ve(n, t, e) {
  return t[e] === ke ? n.options[e] : t[e];
}
function _c(n) {
  const t = (n & 4294901760) >> 16, e = n & 65535;
  try {
    return new Date(1980 + ((t & 65024) >> 9), ((t & 480) >> 5) - 1, t & 31, (e & 63488) >> 11, (e & 2016) >> 5, (e & 31) * 2, 0);
  } catch {
  }
}
function bn(n) {
  return new Date(Number(n / BigInt(1e4) - BigInt(116444736e5)));
}
function xt(n, t) {
  return n.getUint8(t);
}
function me(n, t) {
  return n.getUint16(t, !0);
}
function ce(n, t) {
  return n.getUint32(t, !0);
}
function Zt(n, t) {
  return Number(n.getBigUint64(t, !0));
}
function yc(n, t, e) {
  n.setUint32(t, e, !0);
}
function he(n) {
  return new DataView(n.buffer);
}
let Ji;
try {
  Ji = import.meta.url;
} catch {
}
Wn({ baseURL: Ji });
Da(Wn);
Wn({ Deflate: so, Inflate: To });
class bc {
  constructor(t) {
    this.fileTree = t;
  }
  async read(t) {
    let e = this.getEntryAtPath(t);
    if (typeof e == "string")
      e = new TextEncoder().encode(e);
    else if (!(e instanceof Uint8Array))
      throw new Error(`Unsupported content type: ${typeof e}`);
    const r = new ReadableStream({
      start(s) {
        s.enqueue(e), s.close();
      }
    });
    return new Vt(r, t, {
      filesize: e.byteLength
    });
  }
  getEntryAtPath(t) {
    let e = t.replace(/^\//, ""), r = this.fileTree;
    for (; e; ) {
      if (r[e])
        return r[e];
      const s = e.split("/"), a = s.shift();
      if (!a || !r[a])
        break;
      r = r[a], e = s.join("/");
    }
    throw new Error(`File not found at ${t}`);
  }
}
class Qt {
  constructor(t) {
    this.entries = /* @__PURE__ */ new Map(), this.zipReader = t;
  }
  static fromStream(t) {
    const e = new zr(
      new Rn(new Vt(t, "archive.zip"))
    );
    return new Qt(e);
  }
  static fromArrayBuffer(t) {
    const e = new zr(
      new Rn(new Blob([t]))
    );
    return new Qt(e);
  }
  async read(t) {
    const e = await this.getEntry(t), r = await e.getData(new Ba());
    return new Vt(r.stream(), t, {
      filesize: e.uncompressedSize
    });
  }
  async getEntry(t) {
    const r = (await this.getEntries()).get(t.replace(/^\//, ""));
    if (!r)
      throw new Error(`File ${t} not found in the zip.`);
    return r;
  }
  async getEntries() {
    if (this.entries.size === 0) {
      const t = await this.zipReader.getEntries();
      for (const e of t)
        this.entries.set(e.filename, e);
    }
    return this.entries;
  }
}
class vc {
  /**
   * Creates a new OverlayFilesystem.
   *
   * @param filesystems An array of Filesystem instances to cascade through.
   *                    The order determines the priority - earlier filesystems
   *                    are checked first.
   */
  constructor(t) {
    if (!t.length)
      throw new Error(
        "OverlayFilesystem requires at least one filesystem"
      );
    this.filesystems = t;
  }
  /**
   * Reads a file by trying each filesystem in order until one succeeds.
   *
   * @param path The path to the file to read.
   * @returns A Promise that resolves to a StreamedFile from the first
   *          filesystem that successfully resolves the path.
   * @throws Error if all filesystems fail to resolve the path.
   */
  async read(t) {
    const e = [];
    for (const s of this.filesystems)
      try {
        return await s.read(t);
      } catch (a) {
        e.push(
          a instanceof Error ? a : new Error(String(a))
        );
      }
    const r = e.map((s) => s.message).join("; ");
    throw new Error(
      `Failed to read ${t} from any filesystem: ${r}`,
      { cause: e }
    );
  }
}
class Ec {
  constructor(t) {
    this.root = t;
  }
  async ensureNodeModules() {
    if (!this.fs || !this.path) {
      try {
        this.fs = await import("fs"), this.path = await import("path");
      } catch {
        this.fs = require("fs"), this.path = require("path");
      }
      this.root = this.path.resolve(this.root) + this.path.sep;
    }
  }
  async read(t) {
    if (await this.ensureNodeModules(), t = this.path.resolve(
      this.root,
      this.path.normalize(t.replace(/^\//, ""))
    ), !t.startsWith(this.root))
      throw new Error(
        `Refused to read a file outside of the root directory: ${t}`
      );
    return new Promise((e, r) => {
      const s = this.path.resolve(t), a = this.fs.createReadStream(s);
      a.on("error", (c) => {
        r(
          new Error(
            `Failed to read file at ${t}: ${c.message}`
          )
        );
      }), this.fs.stat(s, (c, l) => {
        c ? r(
          new Error(
            `Failed to read file at ${t}: ${c.message}`
          )
        ) : e(
          new Vt(
            kc(a),
            t,
            {
              filesize: l.size
            }
          )
        );
      });
    });
  }
}
function kc(n) {
  return new ReadableStream({
    start(e) {
      n.on("data", (r) => e.enqueue(r)), n.on("end", () => e.close());
    }
  });
}
async function Sc({
  sourceString: n,
  blueprintMayReadAdjacentFiles: t
}) {
  if (!n)
    return;
  if (n.startsWith("http://") || n.startsWith("https://"))
    return await as(n);
  let e = Je.resolve(process.cwd(), n);
  if (!ye.existsSync(e))
    throw new Error(`Blueprint file does not exist: ${e}`);
  const r = ye.statSync(e);
  if (r.isDirectory() && (e = Je.join(e, "blueprint.json")), !r.isFile() && r.isSymbolicLink())
    throw new Error(
      `Blueprint path is neither a file nor a directory: ${e}`
    );
  const s = Je.extname(e);
  switch (s) {
    case ".zip":
      return Qt.fromArrayBuffer(
        ye.readFileSync(e)
      );
    case ".json": {
      const a = ye.readFileSync(e, "utf-8");
      try {
        JSON.parse(a);
      } catch {
        throw new Error(
          `Blueprint file at ${e} is not a valid JSON file`
        );
      }
      const c = Je.dirname(e), l = new Ec(c);
      return new vc([
        new bc({
          "blueprint.json": a
        }),
        /**
         * Wrap the NodeJS filesystem to prevent access to local files
         * unless the user explicitly allowed it.
         */
        {
          read(f) {
            if (!t)
              throw new oi(
                `Error: Blueprint contained tried to read a local file at path "${f}" (via a resource of type "bundled"). Playground restricts access to local resources by default as a security measure. 

You can allow this Blueprint to read files from the same parent directory by explicitly adding the --blueprint-may-read-adjacent-files option to your command.`
              );
            return l.read(f);
          }
        }
      ]);
    }
    default:
      throw new Error(
        `Unsupported blueprint file extension: ${s}. Only .zip and .json files are supported.`
      );
  }
}
async function jc() {
  const n = gs(process.argv.slice(2)).usage("Usage: wp-playground <command> [options]").positional("command", {
    describe: "Command to run",
    choices: ["server", "run-blueprint", "build-snapshot"],
    demandOption: !0
  }).option("outfile", {
    describe: "When building, write to this output file.",
    type: "string",
    default: "wordpress.zip"
  }).option("port", {
    describe: "Port to listen on when serving.",
    type: "number",
    default: 9400
  }).option("php", {
    describe: "PHP version to use.",
    type: "string",
    default: Qr,
    choices: ss
  }).option("wp", {
    describe: "WordPress version to use.",
    type: "string",
    default: "latest"
  }).option("mount", {
    describe: "Mount a directory to the PHP runtime (can be used multiple times). Format: /host/path:/vfs/path",
    type: "array",
    string: !0,
    coerce: Kn
  }).option("mount-before-install", {
    describe: "Mount a directory to the PHP runtime before WordPress installation (can be used multiple times). Format: /host/path:/vfs/path",
    type: "array",
    string: !0,
    coerce: Kn
  }).option("mount-dir", {
    describe: 'Mount a directory to the PHP runtime (can be used multiple times). Format: "/host/path" "/vfs/path"',
    type: "array",
    nargs: 2,
    array: !0
    // coerce: parseMountDirArguments,
  }).option("mount-dir-before-install", {
    describe: 'Mount a directory before WordPress installation (can be used multiple times). Format: "/host/path" "/vfs/path"',
    type: "string",
    nargs: 2,
    array: !0,
    coerce: Cs
  }).option("login", {
    describe: "Should log the user in",
    type: "boolean",
    default: !1
  }).option("blueprint", {
    describe: "Blueprint to execute.",
    type: "string"
  }).option("blueprint-may-read-adjacent-files", {
    describe: 'Consent flag: Allow "bundled" resources in a local blueprint to read files in the same directory as the blueprint file.',
    type: "boolean",
    default: !1
  }).option("skip-wordpress-setup", {
    describe: "Do not download, unzip, and install WordPress. Useful for mounting a pre-configured WordPress directory at /wordpress.",
    type: "boolean",
    default: !1
  }).option("skip-sqlite-setup", {
    describe: "Skip the SQLite integration plugin setup to allow the WordPress site to use MySQL.",
    type: "boolean",
    default: !1
  }).option("quiet", {
    describe: "Do not output logs and progress messages.",
    type: "boolean",
    default: !1
  }).option("debug", {
    describe: "Print PHP error log content if an error occurs during Playground boot.",
    type: "boolean",
    default: !1
  }).option("auto-mount", {
    describe: "Automatically mount the current working directory. You can mount a WordPress directory, a plugin directory, a theme directory, a wp-content directory, or any directory containing PHP and HTML files.",
    type: "boolean",
    default: !1
  }).option("follow-symlinks", {
    describe: `Allow Playground to follow symlinks by automatically mounting symlinked directories and files encountered in mounted directories. 
Warning: Following symlinks will expose files outside mounted directories to Playground and could be a security risk.`,
    type: "boolean",
    default: !1
  }).option("experimentalTrace", {
    describe: "Print detailed messages about system behavior to the console. Useful for troubleshooting.",
    type: "boolean",
    default: !1,
    // Hide this option because we want to replace with a more general log-level flag.
    hidden: !0
  }).option("experimentalMultiWorker", {
    describe: "Enable experimental multi-worker support which requires JSPI and a /wordpress directory backed by a real filesystem. Pass a positive number to specify the number of workers to use. Otherwise, default to the number of CPUs minus 1.",
    type: "number",
    coerce: (s) => s ?? hs().length - 1
  }).showHelpOnFail(!1).check(async (s) => {
    if (s.wp !== void 0 && !Fs(s.wp))
      try {
        new URL(s.wp);
      } catch {
        throw new Error(
          'Unrecognized WordPress version. Please use "latest", a URL, or a numeric version such as "6.2", "6.0.1", "6.2-beta1", or "6.2-RC1"'
        );
      }
    if (s.experimentalMultiWorker !== void 0) {
      if (s.experimentalMultiWorker <= 1)
        throw new Error(
          "The --experimentalMultiWorker flag must be a positive integer greater than 1."
        );
      if (!await Rs())
        throw new Error(
          "JavaScript Promise Integration (JSPI) is not enabled. Please enable JSPI in your JavaScript runtime before using the --experimentalMultiWorker flag."
        );
      const a = (c) => c.vfsPath === "/wordpress";
      if (!s.mount?.some(a) && !s.mountBeforeInstall?.some(
        a
      ))
        throw new Error(
          "Please mount a real filesystem directory as the /wordpress directory before using the --experimentalMultiWorker flag."
        );
    }
    return !0;
  });
  n.wrap(n.terminalWidth());
  const t = await n.argv, e = t._[0];
  ["run-blueprint", "server", "build-snapshot"].includes(e) || (n.showHelp(), process.exit(1));
  const r = {
    ...t,
    command: e,
    blueprint: await Sc({
      sourceString: t.blueprint,
      blueprintMayReadAdjacentFiles: t.blueprintMayReadAdjacentFiles
    }),
    mount: [...t.mount || [], ...t.mountDir || []],
    mountBeforeInstall: [
      ...t.mountBeforeInstall || [],
      ...t.mountDirBeforeInstall || []
    ]
  };
  try {
    return Ac(r);
  } catch (s) {
    const a = oi.getReportableCause(s);
    if (a)
      console.log(""), console.log(a.message), process.exit(1);
    else
      throw s;
  }
}
async function Ac(n) {
  let t, e;
  const r = [];
  n.autoMount && (n = _s(n));
  async function s(k) {
    await e.run({
      code: `<?php
			$zip = new ZipArchive();
			if(false === $zip->open('/tmp/build.zip', ZipArchive::CREATE | ZipArchive::OVERWRITE)) {
				throw new Exception('Failed to create ZIP');
			}
			$files = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator('/wordpress')
			);
			foreach ($files as $file) {
				echo $file . PHP_EOL;
				if (!$file->isFile()) {
					continue;
				}
				$zip->addFile($file->getPathname(), $file->getPathname());
			}
			$zip->close();

		`
    });
    const P = await e.readFileAsBuffer("/tmp/build.zip");
    ye.writeFileSync(k, P);
  }
  async function a() {
    const k = cs(n.blueprint) ? n.blueprint : {
      login: n.login,
      ...n.blueprint,
      preferredVersions: {
        php: n.php ?? n?.blueprint?.preferredVersions?.php ?? Qr,
        wp: n.wp ?? n?.blueprint?.preferredVersions?.wp ?? "latest",
        ...n.blueprint?.preferredVersions || {}
      }
    }, P = new rs();
    let m = "", d = !1;
    return P.addEventListener("progress", (h) => {
      if (d)
        return;
      d = h.detail.progress === 100;
      const y = Math.floor(h.detail.progress);
      m = h.detail.caption || m || "Running the Blueprint";
      const T = `${m.trim()}  ${y}%`;
      n.quiet || l(
        process.stdout,
        T,
        d
      );
    }), await ls(k, {
      progress: P
    });
  }
  let c = "";
  function l(k, P, m) {
    P !== c && (c = P, k.isTTY ? (k.cursorTo(0), k.write(P), k.clearLine(1), m && k.write(`
`)) : k.write(`${P}
`));
  }
  async function f(k) {
    const P = new ds(k);
    return new Promise((m, d) => {
      function h(T) {
        T === "worker-script-initialized" && (m(P), P.off("message", h));
      }
      function y(T) {
        const D = new Error(
          `Worker failed to load at ${k}. ${T.message ? `Original error: ${T.message}` : ""}`
        );
        D.filename = k, d(D), P.off("error", y);
      }
      P.on("message", h), P.on("error", y);
    });
  }
  function _(k) {
    const P = new URL(
      As,
      import.meta.url
    ), m = [];
    for (let d = 0; d < k; d++)
      m.push(f(P));
    return Promise.all(m);
  }
  n.quiet && (xe.handlers = []);
  const x = await a(), w = new ws();
  let g = !1;
  return xe.log("Starting a PHP server..."), Es({
    port: n.port,
    onBind: async (k, P) => {
      const m = `http://127.0.0.1:${P}`, d = n.experimentalMultiWorker ?? 1, h = _(d);
      xe.log(`Setting up WordPress ${n.wp}`);
      let y;
      const T = new is();
      if (!n.skipWordPressSetup) {
        let C = !1;
        T.addEventListener("progress", (v) => {
          if (C)
            return;
          const { loaded: S, total: M } = v.detail, L = Math.floor(
            Math.min(100, 100 * S / M)
          );
          C = L === 100, n.quiet || l(
            process.stdout,
            `Downloading WordPress ${L}%...`,
            C
          );
        }), y = await ps(n.wp), xe.log(
          `Resolved WordPress release URL: ${y?.releaseUrl}`
        );
      }
      const D = y && Je.join(
        En,
        `prebuilt-wp-content-for-wp-${y.version}.zip`
      ), A = y ? ye.existsSync(D) ? si(D) : await ii(
        y.releaseUrl,
        `${y.version}.zip`,
        T
      ) : void 0;
      xe.log("Fetching SQLite integration plugin...");
      const R = n.skipSqliteSetup ? void 0 : await bs(T), F = n.followSymlinks === !0, b = n.experimentalTrace === !0;
      try {
        const C = n.mountBeforeInstall || [], v = n.mount || [], [S, ...M] = await h;
        e = Yn(S), r.push({
          playground: e,
          worker: S
        }), await e.isConnected(), Zn(w, void 0, S), xe.log("Booting WordPress...");
        const L = Math.floor(
          Number.MAX_SAFE_INTEGER / d
        );
        if (await e.boot({
          phpVersion: x.versions.php,
          wpVersion: x.versions.wp,
          absoluteUrl: m,
          mountsBeforeWpInstall: C,
          mountsAfterWpInstall: v,
          wordPressZip: A && await A.arrayBuffer(),
          sqliteIntegrationPluginZip: await R.arrayBuffer(),
          firstProcessId: 0,
          processIdSpaceLength: L,
          followSymlinks: F,
          trace: b
        }), y && !n.mountBeforeInstall && !ye.existsSync(D) && (xe.log(
          "Caching preinstalled WordPress for the next boot..."
        ), ye.writeFileSync(
          D,
          await Vn(e, "/wordpress")
        ), xe.log("Cached!")), t = new Ts(e), await e.isReady(), g = !0, xe.log("Booted!"), x && (xe.log("Running the Blueprint..."), await fs(x, e), xe.log("Finished running the blueprint")), n.command === "build-snapshot" ? (await s(n.outfile), xe.log(`WordPress exported to ${n.outfile}`), process.exit(0)) : n.command === "run-blueprint" && (xe.log("Blueprint executed"), process.exit(0)), n.experimentalMultiWorker && n.experimentalMultiWorker > 1) {
          xe.log("Preparing additional workers...");
          const Y = await Vn(
            e,
            "/internal"
          ), H = L;
          await Promise.all(
            M.map(async (j, K) => {
              const V = Yn(j);
              r.push({
                playground: V,
                worker: j
              }), await V.isConnected(), Zn(w, void 0, j);
              const oe = H + K * L;
              await V.boot({
                phpVersion: x.versions.php,
                absoluteUrl: m,
                mountsBeforeWpInstall: C,
                mountsAfterWpInstall: v,
                // Skip WordPress zip because we share the /wordpress directory
                // populated by the initial worker.
                wordPressZip: void 0,
                // Skip SQLite integration plugin for now because we
                // will copy it from primary's `/internal` directory.
                sqliteIntegrationPluginZip: void 0,
                dataSqlPath: "/wordpress/wp-content/database/.ht.sqlite",
                firstProcessId: oe,
                processIdSpaceLength: L,
                followSymlinks: F,
                trace: b
              }), await V.isReady(), await V.writeFile(
                "/tmp/internal.zip",
                Y
              ), await us(
                V,
                "/tmp/internal.zip",
                "/internal"
              ), await V.unlink(
                "/tmp/internal.zip"
              ), t.addWorker(V);
            })
          ), xe.log("Ready!");
        }
        return xe.log(`WordPress is running on ${m}`), {
          playground: e,
          server: k,
          [Symbol.asyncDispose]: async function() {
            await Promise.all(
              r.map(
                async ({ playground: H, worker: j }) => {
                  await H.dispose(), await j.terminate();
                }
              )
            ), await new Promise((H) => k.close(H));
          }
        };
      } catch (C) {
        if (!n.debug)
          throw C;
        const v = await e.readFileAsText(ns);
        throw new Error(v, { cause: C });
      }
    },
    async handleRequest(k) {
      return g ? await t.handleRequest(k) : os.forHttpCode(
        502,
        "WordPress is not ready yet"
      );
    }
  });
}
export {
  jc as p,
  Ac as r
};
//# sourceMappingURL=run-cli-bX1Rsm_j.js.map
