import { Semaphore as Mt, normalizePath as mt, joinPaths as ge } from "@php-wasm/util";
import { Octokit as be } from "octokit";
import xe from "crc-32";
import Nt from "pako";
import { StreamedFile as V } from "@php-wasm/stream-compression";
import { ZipReader as kt, BlobReader as Tt, BlobWriter as Ee } from "@zip.js/zip.js";
function Dr(i) {
  return new be({
    auth: i
  });
}
function Lr(i, t = "") {
  t.length && !t.endsWith("/") && (t += "/");
  const n = {};
  for (const s of i)
    s.path.startsWith(t) && (n[s.path.substring(t.length)] = s.content);
  return n;
}
async function Be(i, t, n, s, c, f = {}) {
  f.progress || (f.progress = {
    foundFiles: 0,
    downloadedFiles: 0
  });
  const { onProgress: h } = f, a = [], d = [], { data: y } = await i.rest.repos.getContent({
    owner: t,
    repo: n,
    path: c,
    ref: s
  });
  if (!Array.isArray(y))
    throw new Error(
      `Expected the list of files to be an array, but got ${typeof y}`
    );
  for (const b of y)
    b.type === "file" ? (++f.progress.foundFiles, h == null || h(f.progress), a.push(
      _e(i, t, n, s, b).then((x) => (++f.progress.downloadedFiles, h == null || h(f.progress), x))
    )) : b.type === "dir" && d.push(
      Be(
        i,
        t,
        n,
        s,
        b.path,
        f
      )
    );
  const m = await Promise.all(a), g = (await Promise.all(d)).flatMap(
    (b) => b
  );
  return [...m, ...g];
}
const ve = new Mt({ concurrency: 15 });
async function _e(i, t, n, s, c) {
  const f = await ve.acquire();
  try {
    const { data: h } = await i.rest.repos.getContent({
      owner: t,
      repo: n,
      ref: s,
      path: c.path
    });
    if (!("content" in h))
      throw new Error(`No content found for ${c.path}`);
    return {
      name: c.name,
      path: c.path,
      content: Ie(h.content)
    };
  } finally {
    f();
  }
}
function Ie(i) {
  const t = window.atob(i), n = t.length, s = new Uint8Array(n);
  for (let c = 0; c < n; c++)
    s[c] = t.charCodeAt(c);
  return s;
}
async function Mr(i, t, n, s, c) {
  var m;
  const { data: f } = await i.rest.pulls.get({
    owner: t,
    repo: n,
    pull_number: s
  }), a = (m = (await i.rest.actions.listWorkflowRuns({
    owner: t,
    repo: n,
    branch: f.head.ref,
    workflow_id: c
  })).data.workflow_runs[0]) == null ? void 0 : m.id, d = await i.rest.actions.listWorkflowRunArtifacts({
    owner: t,
    repo: n,
    run_id: a
  });
  return (await i.rest.actions.downloadArtifact({
    owner: t,
    repo: n,
    artifact_id: d.data.artifacts[0].id,
    archive_format: "zip"
  })).data;
}
async function Nr(i, t, n) {
  var f;
  const { data: s, headers: c } = await i.request(
    "GET /repos/{owner}/{repo}",
    {
      owner: t,
      repo: n
    }
  );
  return !(!c["x-oauth-scopes"] || !((f = s.permissions) != null && f.push));
}
async function Pr(i, t, n, s, c) {
  await i.request("GET /repos/{owner}/{repo}/branches/{branch}", {
    owner: t,
    repo: n,
    branch: s
  }).then(
    () => !0,
    () => !1
  ) ? await i.request("PATCH /repos/{owner}/{repo}/git/refs/{ref}", {
    owner: t,
    repo: n,
    sha: c,
    ref: `heads/${s}`
  }) : await i.request("POST /repos/{owner}/{repo}/git/refs", {
    owner: t,
    repo: n,
    sha: c,
    ref: `refs/heads/${s}`
  });
}
async function jr(i, t, n) {
  const s = await i.request("GET /user");
  return (await i.request("GET /repos/{owner}/{repo}/forks", {
    owner: t,
    repo: n
  })).data.find(
    (h) => h.owner && h.owner.login === s.data.login
  ) || await i.request("POST /repos/{owner}/{repo}/forks", {
    owner: t,
    repo: n
  }), s.data.login;
}
async function Gr(i, t, n, s, c, f) {
  const {
    data: { sha: h }
  } = await i.request("POST /repos/{owner}/{repo}/git/commits", {
    owner: t,
    repo: n,
    message: s,
    tree: f,
    parents: [c]
  });
  return h;
}
async function zr(i, t, n, s, c) {
  const f = await Fe(
    i,
    t,
    n,
    s,
    c
  );
  if (f.length === 0)
    return null;
  const {
    data: { sha: h }
  } = await i.request("POST /repos/{owner}/{repo}/git/trees", {
    owner: t,
    repo: n,
    base_tree: s,
    tree: f
  });
  return h;
}
async function Fe(i, t, n, s, c) {
  const f = [];
  for (const [h, a] of c.create)
    f.push($t(i, t, n, h, a));
  for (const [h, a] of c.update)
    f.push($t(i, t, n, h, a));
  for (const h of c.delete)
    f.push(Ae(i, t, n, s, h));
  return Promise.all(f).then(
    (h) => h.filter((a) => !!a)
  );
}
const Pt = new Mt({ concurrency: 10 });
async function $t(i, t, n, s, c) {
  const f = await Pt.acquire();
  try {
    if (ArrayBuffer.isView(c))
      try {
        const h = new TextDecoder("utf-8", {
          fatal: !0
        }).decode(c);
        return {
          path: s,
          content: h,
          mode: "100644"
        };
      } catch {
        const {
          data: { sha: h }
        } = await i.rest.git.createBlob({
          owner: t,
          repo: n,
          encoding: "base64",
          content: Se(c)
        });
        return {
          path: s,
          sha: h,
          mode: "100644"
        };
      }
    else
      return {
        path: s,
        content: c,
        mode: "100644"
      };
  } finally {
    f();
  }
}
async function Ae(i, t, n, s, c) {
  const f = await Pt.acquire();
  try {
    return await i.request("HEAD /repos/{owner}/{repo}/contents/:path", {
      owner: t,
      repo: n,
      ref: s,
      path: c
    }), {
      path: c,
      mode: "100644",
      sha: null
    };
  } catch {
    return;
  } finally {
    f();
  }
}
function Se(i) {
  const t = [], n = i.byteLength;
  for (let s = 0; s < n; s++)
    t.push(String.fromCharCode(i[s]));
  return window.btoa(t.join(""));
}
async function* Hr(i, t, { exceptPaths: n = [] } = {}) {
  if (t = mt(t), !await i.isDir(t)) {
    await i.fileExists(t) && (yield {
      path: t,
      read: async () => await i.readFileAsBuffer(t)
    });
    return;
  }
  const s = [t];
  for (; s.length; ) {
    const c = s.pop();
    if (!c)
      return;
    const f = await i.listFiles(c);
    for (const h of f) {
      const a = ge(c, h);
      n.includes(a.substring(t.length + 1)) || (await i.isDir(a) ? s.push(a) : yield {
        path: a,
        read: async () => await i.readFileAsBuffer(a)
      });
    }
  }
}
async function qr(i, t) {
  const n = {
    create: /* @__PURE__ */ new Map(),
    update: /* @__PURE__ */ new Map(),
    delete: /* @__PURE__ */ new Set()
  }, s = /* @__PURE__ */ new Set();
  for await (const c of t) {
    s.add(c.path);
    const f = i.get(c.path), h = await c.read();
    f ? Ue(f, h) || n.update.set(c.path, h) : n.create.set(c.path, h);
  }
  for (const c of i.keys())
    s.has(c) || n.delete.add(c);
  return n;
}
function Ue(i, t) {
  return i.length === t.length && i.every((n, s) => n === t[s]);
}
async function ke(i) {
  return i.type === "local-fs" ? i.handle : Te(i.path);
}
async function Te(i) {
  const t = i.split("/").filter((s) => s.length > 0);
  let n = await navigator.storage.getDirectory();
  for (const s of t)
    n = await n.getDirectoryHandle(s, { create: !0 });
  return n;
}
async function Wr(i) {
  const n = await (await navigator.storage.getDirectory()).resolve(i);
  if (n === null)
    throw new DOMException(
      "Unable to resolve path of OPFS directory handle.",
      "NotFoundError"
    );
  return "/" + n.join("/");
}
async function Yr(i) {
  const t = await ke(i);
  for await (const n of t.keys())
    await t.removeEntry(n, {
      recursive: !0
    });
}
function $e(i) {
  let t = [i];
  return {
    next() {
      return Promise.resolve({ done: t.length === 0, value: t.pop() });
    },
    return() {
      return t = [], {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function jt(i) {
  return i[Symbol.asyncIterator] ? i[Symbol.asyncIterator]() : i[Symbol.iterator] ? i[Symbol.iterator]() : i.next ? i : $e(i);
}
class Gt {
  constructor(t) {
    if (typeof Buffer > "u")
      throw new Error("Missing Buffer dependency");
    this.stream = jt(t), this.buffer = null, this.cursor = 0, this.undoCursor = 0, this.started = !1, this._ended = !1, this._discardedBytes = 0;
  }
  eof() {
    return this._ended && this.cursor === this.buffer.length;
  }
  tell() {
    return this._discardedBytes + this.cursor;
  }
  async byte() {
    if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended))))
      return this._moveCursor(1), this.buffer[this.undoCursor];
  }
  async chunk() {
    if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended))))
      return this._moveCursor(this.buffer.length), this.buffer.slice(this.undoCursor, this.cursor);
  }
  async read(t) {
    if (!this.eof())
      return this.started || await this._init(), this.cursor + t > this.buffer.length && (this._trim(), await this._accumulate(t)), this._moveCursor(t), this.buffer.slice(this.undoCursor, this.cursor);
  }
  async skip(t) {
    this.eof() || (this.started || await this._init(), this.cursor + t > this.buffer.length && (this._trim(), await this._accumulate(t)), this._moveCursor(t));
  }
  async undo() {
    this.cursor = this.undoCursor;
  }
  async _next() {
    this.started = !0;
    let { done: t, value: n } = await this.stream.next();
    return t && (this._ended = !0, !n) ? Buffer.alloc(0) : (n && (n = Buffer.from(n)), n);
  }
  _trim() {
    this.buffer = this.buffer.slice(this.undoCursor), this.cursor -= this.undoCursor, this._discardedBytes += this.undoCursor, this.undoCursor = 0;
  }
  _moveCursor(t) {
    this.undoCursor = this.cursor, this.cursor += t, this.cursor > this.buffer.length && (this.cursor = this.buffer.length);
  }
  async _accumulate(t) {
    if (this._ended) return;
    const n = [this.buffer];
    for (; this.cursor + t > Ce(n); ) {
      const s = await this._next();
      if (this._ended) break;
      n.push(s);
    }
    this.buffer = Buffer.concat(n);
  }
  async _loadnext() {
    this._discardedBytes += this.buffer.length, this.undoCursor = 0, this.cursor = 0, this.buffer = await this._next();
  }
  async _init() {
    this.buffer = await this._next();
  }
}
function Ce(i) {
  return i.reduce((t, n) => t + n.length, 0);
}
function Re(i, t) {
  const n = t.toString(16);
  return "0".repeat(i - n.length) + n;
}
class S {
  static flush() {
    return Buffer.from("0000", "utf8");
  }
  static delim() {
    return Buffer.from("0001", "utf8");
  }
  static encode(t) {
    typeof t == "string" && (t = Buffer.from(t));
    const n = t.length + 4, s = Re(4, n);
    return Buffer.concat([Buffer.from(s, "utf8"), t]);
  }
  static streamReader(t) {
    const n = new Gt(t);
    return async function() {
      try {
        let c = await n.read(4);
        if (c == null) return !0;
        if (c = parseInt(c.toString("utf8"), 16), c === 0 || c === 1) return null;
        const f = await n.read(c - 4);
        return f ?? !0;
      } catch (c) {
        return t.error = c, !0;
      }
    };
  }
}
class Y extends Error {
  constructor(t) {
    super(t), this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(t) {
    const n = new Y(t.message);
    return n.code = t.code, n.data = t.data, n.caller = t.caller, n.stack = t.stack, n;
  }
  get isIsomorphicGitError() {
    return !0;
  }
}
class _ extends Y {
  /**
   * @param {string} message
   */
  constructor(t) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`
    ), this.code = this.name = _.code, this.data = { message: t };
  }
}
_.code = "InternalError";
class nt extends Y {
  /**
   * @param {string} filepath
   */
  constructor(t) {
    super(`The filepath "${t}" contains unsafe character sequences`), this.code = this.name = nt.code, this.data = { filepath: t };
  }
}
nt.code = "UnsafeFilepathError";
function zt(i, t) {
  return -(i < t) || +(i > t);
}
function Oe(i, t) {
  return zt(i.path, t.path);
}
function De(i, t) {
  return zt(Ct(i), Ct(t));
}
function Ct(i) {
  return i.mode === "040000" ? i.path + "/" : i.path;
}
function Ht(i) {
  switch (i) {
    case "040000":
      return "tree";
    case "100644":
      return "blob";
    case "100755":
      return "blob";
    case "120000":
      return "blob";
    case "160000":
      return "commit";
  }
  throw new _(`Unexpected GitTree entry mode: ${i}`);
}
function Le(i) {
  const t = [];
  let n = 0;
  for (; n < i.length; ) {
    const s = i.indexOf(32, n);
    if (s === -1)
      throw new _(
        `GitTree: Error parsing buffer at byte location ${n}: Could not find the next space character.`
      );
    const c = i.indexOf(0, n);
    if (c === -1)
      throw new _(
        `GitTree: Error parsing buffer at byte location ${n}: Could not find the next null character.`
      );
    let f = i.slice(n, s).toString("utf8");
    f === "40000" && (f = "040000");
    const h = Ht(f), a = i.slice(s + 1, c).toString("utf8");
    if (a.includes("\\") || a.includes("/"))
      throw new nt(a);
    const d = i.slice(c + 1, c + 21).toString("hex");
    n = c + 21, t.push({ mode: f, path: a, oid: d, type: h });
  }
  return t;
}
function Me(i) {
  if (typeof i == "number" && (i = i.toString(8)), i.match(/^0?4.*/)) return "040000";
  if (i.match(/^1006.*/)) return "100644";
  if (i.match(/^1007.*/)) return "100755";
  if (i.match(/^120.*/)) return "120000";
  if (i.match(/^160.*/)) return "160000";
  throw new _(`Could not understand file mode: ${i}`);
}
function Ne(i) {
  return !i.oid && i.sha && (i.oid = i.sha), i.mode = Me(i.mode), i.type || (i.type = Ht(i.mode)), i;
}
class gt {
  constructor(t) {
    if (Buffer.isBuffer(t))
      this._entries = Le(t);
    else if (Array.isArray(t))
      this._entries = t.map(Ne);
    else
      throw new _("invalid type passed to GitTree constructor");
    this._entries.sort(Oe);
  }
  static from(t) {
    return new gt(t);
  }
  render() {
    return this._entries.map((t) => `${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`);
  }
  toObject() {
    const t = [...this._entries];
    return t.sort(De), Buffer.concat(
      t.map((n) => {
        const s = Buffer.from(n.mode.replace(/^0/, "")), c = Buffer.from(" "), f = Buffer.from(n.path, "utf8"), h = Buffer.from([0]), a = Buffer.from(n.oid, "hex");
        return Buffer.concat([s, c, f, h, a]);
      })
    );
  }
  /**
   * @returns {TreeEntry[]}
   */
  entries() {
    return this._entries;
  }
  *[Symbol.iterator]() {
    for (const t of this._entries)
      yield t;
  }
}
function pt({ name: i, email: t, timestamp: n, timezoneOffset: s }) {
  return s = Pe(s), `${i} <${t}> ${n} ${s}`;
}
function Pe(i) {
  const t = je(Ge(i));
  i = Math.abs(i);
  const n = Math.floor(i / 60);
  i -= n * 60;
  let s = String(n), c = String(i);
  return s.length < 2 && (s = "0" + s), c.length < 2 && (c = "0" + c), (t === -1 ? "-" : "+") + s + c;
}
function je(i) {
  return Math.sign(i) || (Object.is(i, -0) ? -1 : 1);
}
function Ge(i) {
  return i === 0 ? i : -i;
}
function G(i) {
  return i = i.replace(/\r/g, ""), i = i.replace(/^\n+/, ""), i = i.replace(/\n+$/, "") + `
`, i;
}
function rt(i) {
  const [, t, n, s, c] = i.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name: t,
    email: n,
    timestamp: Number(s),
    timezoneOffset: ze(c)
  };
}
function ze(i) {
  let [, t, n, s] = i.match(/(\+|-)(\d\d)(\d\d)/);
  return s = (t === "+" ? 1 : -1) * (Number(n) * 60 + Number(s)), He(s);
}
function He(i) {
  return i === 0 ? i : -i;
}
class K {
  constructor(t) {
    if (typeof t == "string")
      this._tag = t;
    else if (Buffer.isBuffer(t))
      this._tag = t.toString("utf8");
    else if (typeof t == "object")
      this._tag = K.render(t);
    else
      throw new _(
        "invalid type passed to GitAnnotatedTag constructor"
      );
  }
  static from(t) {
    return new K(t);
  }
  static render(t) {
    return `object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${pt(t.tagger)}

${t.message}
${t.gpgsig ? t.gpgsig : ""}`;
  }
  justHeaders() {
    return this._tag.slice(0, this._tag.indexOf(`

`));
  }
  message() {
    const t = this.withoutSignature();
    return t.slice(t.indexOf(`

`) + 2);
  }
  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig()
    });
  }
  render() {
    return this._tag;
  }
  headers() {
    const t = this.justHeaders().split(`
`), n = [];
    for (const c of t)
      c[0] === " " ? n[n.length - 1] += `
` + c.slice(1) : n.push(c);
    const s = {};
    for (const c of n) {
      const f = c.slice(0, c.indexOf(" ")), h = c.slice(c.indexOf(" ") + 1);
      Array.isArray(s[f]) ? s[f].push(h) : s[f] = h;
    }
    return s.tagger && (s.tagger = rt(s.tagger)), s.committer && (s.committer = rt(s.committer)), s;
  }
  withoutSignature() {
    const t = G(this._tag);
    return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`) === -1 ? t : t.slice(0, t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`));
  }
  gpgsig() {
    if (this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`) === -1) return;
    const t = this._tag.slice(
      this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._tag.indexOf("-----END PGP SIGNATURE-----") + 27
    );
    return G(t);
  }
  payload() {
    return this.withoutSignature() + `
`;
  }
  toObject() {
    return Buffer.from(this._tag, "utf8");
  }
  static async sign(t, n, s) {
    const c = t.payload();
    let { signature: f } = await n({ payload: c, secretKey: s });
    f = G(f);
    const h = c + f;
    return K.from(h);
  }
}
function ut(i) {
  return i.trim().split(`
`).map((t) => " " + t).join(`
`) + `
`;
}
function qe(i) {
  return i.split(`
`).map((t) => t.replace(/^ /, "")).join(`
`);
}
class R {
  constructor(t) {
    if (typeof t == "string")
      this._commit = t;
    else if (Buffer.isBuffer(t))
      this._commit = t.toString("utf8");
    else if (typeof t == "object")
      this._commit = R.render(t);
    else
      throw new _("invalid type passed to GitCommit constructor");
  }
  static fromPayloadSignature({ payload: t, signature: n }) {
    const s = R.justHeaders(t), c = R.justMessage(t), f = G(
      s + `
gpgsig` + ut(n) + `
` + c
    );
    return new R(f);
  }
  static from(t) {
    return new R(t);
  }
  toObject() {
    return Buffer.from(this._commit, "utf8");
  }
  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders();
  }
  // Todo: allow setting the headers and message
  message() {
    return R.justMessage(this._commit);
  }
  parse() {
    return Object.assign({ message: this.message() }, this.headers());
  }
  static justMessage(t) {
    return G(t.slice(t.indexOf(`

`) + 2));
  }
  static justHeaders(t) {
    return t.slice(0, t.indexOf(`

`));
  }
  parseHeaders() {
    const t = R.justHeaders(this._commit).split(`
`), n = [];
    for (const c of t)
      c[0] === " " ? n[n.length - 1] += `
` + c.slice(1) : n.push(c);
    const s = {
      parent: []
    };
    for (const c of n) {
      const f = c.slice(0, c.indexOf(" ")), h = c.slice(c.indexOf(" ") + 1);
      Array.isArray(s[f]) ? s[f].push(h) : s[f] = h;
    }
    return s.author && (s.author = rt(s.author)), s.committer && (s.committer = rt(s.committer)), s;
  }
  static renderHeaders(t) {
    let n = "";
    if (t.tree ? n += `tree ${t.tree}
` : n += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`, t.parent) {
      if (t.parent.length === void 0)
        throw new _("commit 'parent' property should be an array");
      for (const f of t.parent)
        n += `parent ${f}
`;
    }
    const s = t.author;
    n += `author ${pt(s)}
`;
    const c = t.committer || t.author;
    return n += `committer ${pt(c)}
`, t.gpgsig && (n += "gpgsig" + ut(t.gpgsig)), n;
  }
  static render(t) {
    return R.renderHeaders(t) + `
` + G(t.message);
  }
  render() {
    return this._commit;
  }
  withoutSignature() {
    const t = G(this._commit);
    if (t.indexOf(`
gpgsig`) === -1) return t;
    const n = t.slice(0, t.indexOf(`
gpgsig`)), s = t.slice(
      t.indexOf(`-----END PGP SIGNATURE-----
`) + 28
    );
    return G(n + `
` + s);
  }
  isolateSignature() {
    const t = this._commit.slice(
      this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._commit.indexOf("-----END PGP SIGNATURE-----") + 27
    );
    return qe(t);
  }
  static async sign(t, n, s) {
    const c = t.withoutSignature(), f = R.justMessage(t._commit);
    let { signature: h } = await n({ payload: c, secretKey: s });
    h = G(h);
    const d = R.justHeaders(t._commit) + `
gpgsig` + ut(h) + `
` + f;
    return R.from(d);
  }
}
class We {
  static wrap({ type: t, object: n }) {
    return Buffer.concat([
      Buffer.from(`${t} ${n.byteLength.toString()}\0`),
      Buffer.from(n)
    ]);
  }
  static unwrap(t) {
    const n = t.indexOf(32), s = t.indexOf(0), c = t.slice(0, n).toString("utf8"), f = t.slice(n + 1, s).toString("utf8"), h = t.length - (s + 1);
    if (parseInt(f) !== h)
      throw new _(
        `Length mismatch: expected ${f} bytes but got ${h} instead.`
      );
    return {
      type: c,
      object: Buffer.from(t.slice(s + 1))
    };
  }
}
class H {
  constructor(t) {
    this.buffer = t, this._start = 0;
  }
  eof() {
    return this._start >= this.buffer.length;
  }
  tell() {
    return this._start;
  }
  seek(t) {
    this._start = t;
  }
  slice(t) {
    const n = this.buffer.slice(this._start, this._start + t);
    return this._start += t, n;
  }
  toString(t, n) {
    const s = this.buffer.toString(t, this._start, this._start + n);
    return this._start += n, s;
  }
  write(t, n, s) {
    const c = this.buffer.write(t, this._start, n, s);
    return this._start += n, c;
  }
  copy(t, n, s) {
    const c = t.copy(this.buffer, this._start, n, s);
    return this._start += c, c;
  }
  readUInt8() {
    const t = this.buffer.readUInt8(this._start);
    return this._start += 1, t;
  }
  writeUInt8(t) {
    const n = this.buffer.writeUInt8(t, this._start);
    return this._start += 1, n;
  }
  readUInt16BE() {
    const t = this.buffer.readUInt16BE(this._start);
    return this._start += 2, t;
  }
  writeUInt16BE(t) {
    const n = this.buffer.writeUInt16BE(t, this._start);
    return this._start += 2, n;
  }
  readUInt32BE() {
    const t = this.buffer.readUInt32BE(this._start);
    return this._start += 4, t;
  }
  writeUInt32BE(t) {
    const n = this.buffer.writeUInt32BE(t, this._start);
    return this._start += 4, n;
  }
}
function Ye(i, t) {
  const n = new H(i), s = Rt(n);
  if (s !== t.byteLength)
    throw new _(
      `applyDelta expected source buffer to be ${s} bytes but the provided buffer was ${t.length} bytes`
    );
  const c = Rt(n);
  let f;
  const h = Dt(n, t);
  if (h.byteLength === c)
    f = h;
  else {
    f = Buffer.alloc(c);
    const a = new H(f);
    for (a.copy(h); !n.eof(); )
      a.copy(Dt(n, t));
    const d = a.tell();
    if (c !== d)
      throw new _(
        `applyDelta expected target buffer to be ${c} bytes but the resulting buffer was ${d} bytes`
      );
  }
  return f;
}
function Rt(i) {
  let t = 0, n = 0, s = null;
  do
    s = i.readUInt8(), t |= (s & 127) << n, n += 7;
  while (s & 128);
  return t;
}
function Ot(i, t, n) {
  let s = 0, c = 0;
  for (; n--; )
    t & 1 && (s |= i.readUInt8() << c), t >>= 1, c += 8;
  return s;
}
function Dt(i, t) {
  const n = i.readUInt8(), s = 128, c = 15, f = 112;
  if (n & s) {
    const h = Ot(i, n & c, 4);
    let a = Ot(i, (n & f) >> 4, 3);
    return a === 0 && (a = 65536), t.slice(h, h + a);
  } else
    return i.slice(n);
}
async function Ke(i, t) {
  const n = new Gt(i);
  let s = await n.read(4);
  if (s = s.toString("utf8"), s !== "PACK")
    throw new _(`Invalid PACK header '${s}'`);
  let c = await n.read(4);
  if (c = c.readUInt32BE(0), c !== 2)
    throw new _(`Invalid packfile version: ${c}`);
  let f = await n.read(4);
  if (f = f.readUInt32BE(0), !(f < 1))
    for (; !n.eof() && f--; ) {
      const h = n.tell(), { type: a, length: d, ofs: y, reference: m } = await Ve(n), g = new Nt.Inflate();
      for (; !g.result; ) {
        const b = await n.chunk();
        if (!b) break;
        if (g.push(b, !1), g.err)
          throw new _(`Pako error: ${g.msg}`);
        if (g.result) {
          if (g.result.length !== d)
            throw new _(
              "Inflated object size is different from that stated in packfile."
            );
          await n.undo(), await n.read(b.length - g.strm.avail_in);
          const x = n.tell();
          await t({
            data: g.result,
            type: a,
            num: f,
            offset: h,
            end: x,
            reference: m,
            ofs: y
          });
        }
      }
    }
}
async function Ve(i) {
  let t = await i.byte();
  const n = t >> 4 & 7;
  let s = t & 15;
  if (t & 128) {
    let h = 4;
    do
      t = await i.byte(), s |= (t & 127) << h, h += 7;
    while (t & 128);
  }
  let c, f;
  if (n === 6) {
    let h = 0;
    c = 0;
    const a = [];
    do
      t = await i.byte(), c |= (t & 127) << h, h += 7, a.push(t);
    while (t & 128);
    f = Buffer.from(a);
  }
  return n === 7 && (f = await i.read(20)), { type: n, length: s, ofs: c, reference: f };
}
async function Je(i) {
  return Nt.inflate(i);
}
function Xe(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var dt = { exports: {} };
typeof Object.create == "function" ? dt.exports = function(t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : dt.exports = function(t, n) {
  if (n) {
    t.super_ = n;
    var s = function() {
    };
    s.prototype = n.prototype, t.prototype = new s(), t.prototype.constructor = t;
  }
};
var Ze = dt.exports, wt = { exports: {} }, z = {}, it = {};
it.byteLength = er;
it.toByteArray = nr;
it.fromByteArray = or;
var M = [], O = [], Qe = typeof Uint8Array < "u" ? Uint8Array : Array, ft = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var W = 0, tr = ft.length; W < tr; ++W)
  M[W] = ft[W], O[ft.charCodeAt(W)] = W;
O[45] = 62;
O[95] = 63;
function qt(i) {
  var t = i.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = i.indexOf("=");
  n === -1 && (n = t);
  var s = n === t ? 0 : 4 - n % 4;
  return [n, s];
}
function er(i) {
  var t = qt(i), n = t[0], s = t[1];
  return (n + s) * 3 / 4 - s;
}
function rr(i, t, n) {
  return (t + n) * 3 / 4 - n;
}
function nr(i) {
  var t, n = qt(i), s = n[0], c = n[1], f = new Qe(rr(i, s, c)), h = 0, a = c > 0 ? s - 4 : s, d;
  for (d = 0; d < a; d += 4)
    t = O[i.charCodeAt(d)] << 18 | O[i.charCodeAt(d + 1)] << 12 | O[i.charCodeAt(d + 2)] << 6 | O[i.charCodeAt(d + 3)], f[h++] = t >> 16 & 255, f[h++] = t >> 8 & 255, f[h++] = t & 255;
  return c === 2 && (t = O[i.charCodeAt(d)] << 2 | O[i.charCodeAt(d + 1)] >> 4, f[h++] = t & 255), c === 1 && (t = O[i.charCodeAt(d)] << 10 | O[i.charCodeAt(d + 1)] << 4 | O[i.charCodeAt(d + 2)] >> 2, f[h++] = t >> 8 & 255, f[h++] = t & 255), f;
}
function ir(i) {
  return M[i >> 18 & 63] + M[i >> 12 & 63] + M[i >> 6 & 63] + M[i & 63];
}
function sr(i, t, n) {
  for (var s, c = [], f = t; f < n; f += 3)
    s = (i[f] << 16 & 16711680) + (i[f + 1] << 8 & 65280) + (i[f + 2] & 255), c.push(ir(s));
  return c.join("");
}
function or(i) {
  for (var t, n = i.length, s = n % 3, c = [], f = 16383, h = 0, a = n - s; h < a; h += f)
    c.push(sr(i, h, h + f > a ? a : h + f));
  return s === 1 ? (t = i[n - 1], c.push(
    M[t >> 2] + M[t << 4 & 63] + "=="
  )) : s === 2 && (t = (i[n - 2] << 8) + i[n - 1], c.push(
    M[t >> 10] + M[t >> 4 & 63] + M[t << 2 & 63] + "="
  )), c.join("");
}
var bt = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
bt.read = function(i, t, n, s, c) {
  var f, h, a = c * 8 - s - 1, d = (1 << a) - 1, y = d >> 1, m = -7, g = n ? c - 1 : 0, b = n ? -1 : 1, x = i[t + g];
  for (g += b, f = x & (1 << -m) - 1, x >>= -m, m += a; m > 0; f = f * 256 + i[t + g], g += b, m -= 8)
    ;
  for (h = f & (1 << -m) - 1, f >>= -m, m += s; m > 0; h = h * 256 + i[t + g], g += b, m -= 8)
    ;
  if (f === 0)
    f = 1 - y;
  else {
    if (f === d)
      return h ? NaN : (x ? -1 : 1) * (1 / 0);
    h = h + Math.pow(2, s), f = f - y;
  }
  return (x ? -1 : 1) * h * Math.pow(2, f - s);
};
bt.write = function(i, t, n, s, c, f) {
  var h, a, d, y = f * 8 - c - 1, m = (1 << y) - 1, g = m >> 1, b = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = s ? 0 : f - 1, U = s ? 1 : -1, N = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, h = m) : (h = Math.floor(Math.log(t) / Math.LN2), t * (d = Math.pow(2, -h)) < 1 && (h--, d *= 2), h + g >= 1 ? t += b / d : t += b * Math.pow(2, 1 - g), t * d >= 2 && (h++, d /= 2), h + g >= m ? (a = 0, h = m) : h + g >= 1 ? (a = (t * d - 1) * Math.pow(2, c), h = h + g) : (a = t * Math.pow(2, g - 1) * Math.pow(2, c), h = 0)); c >= 8; i[n + x] = a & 255, x += U, a /= 256, c -= 8)
    ;
  for (h = h << c | a, y += c; y > 0; i[n + x] = h & 255, x += U, h /= 256, y -= 8)
    ;
  i[n + x - U] |= N * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(i) {
  var t = it, n = bt, s = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  i.Buffer = a, i.SlowBuffer = P, i.INSPECT_MAX_BYTES = 50;
  var c = 2147483647;
  i.kMaxLength = c, a.TYPED_ARRAY_SUPPORT = f(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function f() {
    try {
      var o = new Uint8Array(1), e = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(o, e), o.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function h(o) {
    if (o > c)
      throw new RangeError('The value "' + o + '" is invalid for option "size"');
    var e = new Uint8Array(o);
    return Object.setPrototypeOf(e, a.prototype), e;
  }
  function a(o, e, r) {
    if (typeof o == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return g(o);
    }
    return d(o, e, r);
  }
  a.poolSize = 8192;
  function d(o, e, r) {
    if (typeof o == "string")
      return b(o, e);
    if (ArrayBuffer.isView(o))
      return U(o);
    if (o == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof o
      );
    if (L(o, ArrayBuffer) || o && L(o.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (L(o, SharedArrayBuffer) || o && L(o.buffer, SharedArrayBuffer)))
      return N(o, e, r);
    if (typeof o == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var u = o.valueOf && o.valueOf();
    if (u != null && u !== o)
      return a.from(u, e, r);
    var l = D(o);
    if (l) return l;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof o[Symbol.toPrimitive] == "function")
      return a.from(
        o[Symbol.toPrimitive]("string"),
        e,
        r
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof o
    );
  }
  a.from = function(o, e, r) {
    return d(o, e, r);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function y(o) {
    if (typeof o != "number")
      throw new TypeError('"size" argument must be of type number');
    if (o < 0)
      throw new RangeError('The value "' + o + '" is invalid for option "size"');
  }
  function m(o, e, r) {
    return y(o), o <= 0 ? h(o) : e !== void 0 ? typeof r == "string" ? h(o).fill(e, r) : h(o).fill(e) : h(o);
  }
  a.alloc = function(o, e, r) {
    return m(o, e, r);
  };
  function g(o) {
    return y(o), h(o < 0 ? 0 : F(o) | 0);
  }
  a.allocUnsafe = function(o) {
    return g(o);
  }, a.allocUnsafeSlow = function(o) {
    return g(o);
  };
  function b(o, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !a.isEncoding(e))
      throw new TypeError("Unknown encoding: " + e);
    var r = T(o, e) | 0, u = h(r), l = u.write(o, e);
    return l !== r && (u = u.slice(0, l)), u;
  }
  function x(o) {
    for (var e = o.length < 0 ? 0 : F(o.length) | 0, r = h(e), u = 0; u < e; u += 1)
      r[u] = o[u] & 255;
    return r;
  }
  function U(o) {
    if (L(o, Uint8Array)) {
      var e = new Uint8Array(o);
      return N(e.buffer, e.byteOffset, e.byteLength);
    }
    return x(o);
  }
  function N(o, e, r) {
    if (e < 0 || o.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (o.byteLength < e + (r || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var u;
    return e === void 0 && r === void 0 ? u = new Uint8Array(o) : r === void 0 ? u = new Uint8Array(o, e) : u = new Uint8Array(o, e, r), Object.setPrototypeOf(u, a.prototype), u;
  }
  function D(o) {
    if (a.isBuffer(o)) {
      var e = F(o.length) | 0, r = h(e);
      return r.length === 0 || o.copy(r, 0, 0, e), r;
    }
    if (o.length !== void 0)
      return typeof o.length != "number" || ct(o.length) ? h(0) : x(o);
    if (o.type === "Buffer" && Array.isArray(o.data))
      return x(o.data);
  }
  function F(o) {
    if (o >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return o | 0;
  }
  function P(o) {
    return +o != o && (o = 0), a.alloc(+o);
  }
  a.isBuffer = function(e) {
    return e != null && e._isBuffer === !0 && e !== a.prototype;
  }, a.compare = function(e, r) {
    if (L(e, Uint8Array) && (e = a.from(e, e.offset, e.byteLength)), L(r, Uint8Array) && (r = a.from(r, r.offset, r.byteLength)), !a.isBuffer(e) || !a.isBuffer(r))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === r) return 0;
    for (var u = e.length, l = r.length, p = 0, w = Math.min(u, l); p < w; ++p)
      if (e[p] !== r[p]) {
        u = e[p], l = r[p];
        break;
      }
    return u < l ? -1 : l < u ? 1 : 0;
  }, a.isEncoding = function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a.concat = function(e, r) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0)
      return a.alloc(0);
    var u;
    if (r === void 0)
      for (r = 0, u = 0; u < e.length; ++u)
        r += e[u].length;
    var l = a.allocUnsafe(r), p = 0;
    for (u = 0; u < e.length; ++u) {
      var w = e[u];
      if (L(w, Uint8Array))
        p + w.length > l.length ? a.from(w).copy(l, p) : Uint8Array.prototype.set.call(
          l,
          w,
          p
        );
      else if (a.isBuffer(w))
        w.copy(l, p);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      p += w.length;
    }
    return l;
  };
  function T(o, e) {
    if (a.isBuffer(o))
      return o.length;
    if (ArrayBuffer.isView(o) || L(o, ArrayBuffer))
      return o.byteLength;
    if (typeof o != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof o
      );
    var r = o.length, u = arguments.length > 2 && arguments[2] === !0;
    if (!u && r === 0) return 0;
    for (var l = !1; ; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return r;
        case "utf8":
        case "utf-8":
          return at(o).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return r * 2;
        case "hex":
          return r >>> 1;
        case "base64":
          return At(o).length;
        default:
          if (l)
            return u ? -1 : at(o).length;
          e = ("" + e).toLowerCase(), l = !0;
      }
  }
  a.byteLength = T;
  function j(o, e, r) {
    var u = !1;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
      return "";
    for (o || (o = "utf8"); ; )
      switch (o) {
        case "hex":
          return he(this, e, r);
        case "utf8":
        case "utf-8":
          return Bt(this, e, r);
        case "ascii":
          return ue(this, e, r);
        case "latin1":
        case "binary":
          return fe(this, e, r);
        case "base64":
          return ae(this, e, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return le(this, e, r);
        default:
          if (u) throw new TypeError("Unknown encoding: " + o);
          o = (o + "").toLowerCase(), u = !0;
      }
  }
  a.prototype._isBuffer = !0;
  function $(o, e, r) {
    var u = o[e];
    o[e] = o[r], o[r] = u;
  }
  a.prototype.swap16 = function() {
    var e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var r = 0; r < e; r += 2)
      $(this, r, r + 1);
    return this;
  }, a.prototype.swap32 = function() {
    var e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var r = 0; r < e; r += 4)
      $(this, r, r + 3), $(this, r + 1, r + 2);
    return this;
  }, a.prototype.swap64 = function() {
    var e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var r = 0; r < e; r += 8)
      $(this, r, r + 7), $(this, r + 1, r + 6), $(this, r + 2, r + 5), $(this, r + 3, r + 4);
    return this;
  }, a.prototype.toString = function() {
    var e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? Bt(this, 0, e) : j.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(e) {
    if (!a.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : a.compare(this, e) === 0;
  }, a.prototype.inspect = function() {
    var e = "", r = i.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
  }, s && (a.prototype[s] = a.prototype.inspect), a.prototype.compare = function(e, r, u, l, p) {
    if (L(e, Uint8Array) && (e = a.from(e, e.offset, e.byteLength)), !a.isBuffer(e))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e
      );
    if (r === void 0 && (r = 0), u === void 0 && (u = e ? e.length : 0), l === void 0 && (l = 0), p === void 0 && (p = this.length), r < 0 || u > e.length || l < 0 || p > this.length)
      throw new RangeError("out of range index");
    if (l >= p && r >= u)
      return 0;
    if (l >= p)
      return -1;
    if (r >= u)
      return 1;
    if (r >>>= 0, u >>>= 0, l >>>= 0, p >>>= 0, this === e) return 0;
    for (var w = p - l, E = u - r, B = Math.min(w, E), v = this.slice(l, p), k = e.slice(r, u), I = 0; I < B; ++I)
      if (v[I] !== k[I]) {
        w = v[I], E = k[I];
        break;
      }
    return w < E ? -1 : E < w ? 1 : 0;
  };
  function xt(o, e, r, u, l) {
    if (o.length === 0) return -1;
    if (typeof r == "string" ? (u = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, ct(r) && (r = l ? 0 : o.length - 1), r < 0 && (r = o.length + r), r >= o.length) {
      if (l) return -1;
      r = o.length - 1;
    } else if (r < 0)
      if (l) r = 0;
      else return -1;
    if (typeof e == "string" && (e = a.from(e, u)), a.isBuffer(e))
      return e.length === 0 ? -1 : Et(o, e, r, u, l);
    if (typeof e == "number")
      return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? l ? Uint8Array.prototype.indexOf.call(o, e, r) : Uint8Array.prototype.lastIndexOf.call(o, e, r) : Et(o, [e], r, u, l);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Et(o, e, r, u, l) {
    var p = 1, w = o.length, E = e.length;
    if (u !== void 0 && (u = String(u).toLowerCase(), u === "ucs2" || u === "ucs-2" || u === "utf16le" || u === "utf-16le")) {
      if (o.length < 2 || e.length < 2)
        return -1;
      p = 2, w /= 2, E /= 2, r /= 2;
    }
    function B(St, Ut) {
      return p === 1 ? St[Ut] : St.readUInt16BE(Ut * p);
    }
    var v;
    if (l) {
      var k = -1;
      for (v = r; v < w; v++)
        if (B(o, v) === B(e, k === -1 ? 0 : v - k)) {
          if (k === -1 && (k = v), v - k + 1 === E) return k * p;
        } else
          k !== -1 && (v -= v - k), k = -1;
    } else
      for (r + E > w && (r = w - E), v = r; v >= 0; v--) {
        for (var I = !0, et = 0; et < E; et++)
          if (B(o, v + et) !== B(e, et)) {
            I = !1;
            break;
          }
        if (I) return v;
      }
    return -1;
  }
  a.prototype.includes = function(e, r, u) {
    return this.indexOf(e, r, u) !== -1;
  }, a.prototype.indexOf = function(e, r, u) {
    return xt(this, e, r, u, !0);
  }, a.prototype.lastIndexOf = function(e, r, u) {
    return xt(this, e, r, u, !1);
  };
  function re(o, e, r, u) {
    r = Number(r) || 0;
    var l = o.length - r;
    u ? (u = Number(u), u > l && (u = l)) : u = l;
    var p = e.length;
    u > p / 2 && (u = p / 2);
    for (var w = 0; w < u; ++w) {
      var E = parseInt(e.substr(w * 2, 2), 16);
      if (ct(E)) return w;
      o[r + w] = E;
    }
    return w;
  }
  function ne(o, e, r, u) {
    return tt(at(e, o.length - r), o, r, u);
  }
  function ie(o, e, r, u) {
    return tt(we(e), o, r, u);
  }
  function se(o, e, r, u) {
    return tt(At(e), o, r, u);
  }
  function oe(o, e, r, u) {
    return tt(ye(e, o.length - r), o, r, u);
  }
  a.prototype.write = function(e, r, u, l) {
    if (r === void 0)
      l = "utf8", u = this.length, r = 0;
    else if (u === void 0 && typeof r == "string")
      l = r, u = this.length, r = 0;
    else if (isFinite(r))
      r = r >>> 0, isFinite(u) ? (u = u >>> 0, l === void 0 && (l = "utf8")) : (l = u, u = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var p = this.length - r;
    if ((u === void 0 || u > p) && (u = p), e.length > 0 && (u < 0 || r < 0) || r > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    l || (l = "utf8");
    for (var w = !1; ; )
      switch (l) {
        case "hex":
          return re(this, e, r, u);
        case "utf8":
        case "utf-8":
          return ne(this, e, r, u);
        case "ascii":
        case "latin1":
        case "binary":
          return ie(this, e, r, u);
        case "base64":
          return se(this, e, r, u);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return oe(this, e, r, u);
        default:
          if (w) throw new TypeError("Unknown encoding: " + l);
          l = ("" + l).toLowerCase(), w = !0;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ae(o, e, r) {
    return e === 0 && r === o.length ? t.fromByteArray(o) : t.fromByteArray(o.slice(e, r));
  }
  function Bt(o, e, r) {
    r = Math.min(o.length, r);
    for (var u = [], l = e; l < r; ) {
      var p = o[l], w = null, E = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
      if (l + E <= r) {
        var B, v, k, I;
        switch (E) {
          case 1:
            p < 128 && (w = p);
            break;
          case 2:
            B = o[l + 1], (B & 192) === 128 && (I = (p & 31) << 6 | B & 63, I > 127 && (w = I));
            break;
          case 3:
            B = o[l + 1], v = o[l + 2], (B & 192) === 128 && (v & 192) === 128 && (I = (p & 15) << 12 | (B & 63) << 6 | v & 63, I > 2047 && (I < 55296 || I > 57343) && (w = I));
            break;
          case 4:
            B = o[l + 1], v = o[l + 2], k = o[l + 3], (B & 192) === 128 && (v & 192) === 128 && (k & 192) === 128 && (I = (p & 15) << 18 | (B & 63) << 12 | (v & 63) << 6 | k & 63, I > 65535 && I < 1114112 && (w = I));
        }
      }
      w === null ? (w = 65533, E = 1) : w > 65535 && (w -= 65536, u.push(w >>> 10 & 1023 | 55296), w = 56320 | w & 1023), u.push(w), l += E;
    }
    return ce(u);
  }
  var vt = 4096;
  function ce(o) {
    var e = o.length;
    if (e <= vt)
      return String.fromCharCode.apply(String, o);
    for (var r = "", u = 0; u < e; )
      r += String.fromCharCode.apply(
        String,
        o.slice(u, u += vt)
      );
    return r;
  }
  function ue(o, e, r) {
    var u = "";
    r = Math.min(o.length, r);
    for (var l = e; l < r; ++l)
      u += String.fromCharCode(o[l] & 127);
    return u;
  }
  function fe(o, e, r) {
    var u = "";
    r = Math.min(o.length, r);
    for (var l = e; l < r; ++l)
      u += String.fromCharCode(o[l]);
    return u;
  }
  function he(o, e, r) {
    var u = o.length;
    (!e || e < 0) && (e = 0), (!r || r < 0 || r > u) && (r = u);
    for (var l = "", p = e; p < r; ++p)
      l += me[o[p]];
    return l;
  }
  function le(o, e, r) {
    for (var u = o.slice(e, r), l = "", p = 0; p < u.length - 1; p += 2)
      l += String.fromCharCode(u[p] + u[p + 1] * 256);
    return l;
  }
  a.prototype.slice = function(e, r) {
    var u = this.length;
    e = ~~e, r = r === void 0 ? u : ~~r, e < 0 ? (e += u, e < 0 && (e = 0)) : e > u && (e = u), r < 0 ? (r += u, r < 0 && (r = 0)) : r > u && (r = u), r < e && (r = e);
    var l = this.subarray(e, r);
    return Object.setPrototypeOf(l, a.prototype), l;
  };
  function A(o, e, r) {
    if (o % 1 !== 0 || o < 0) throw new RangeError("offset is not uint");
    if (o + e > r) throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(e, r, u) {
    e = e >>> 0, r = r >>> 0, u || A(e, r, this.length);
    for (var l = this[e], p = 1, w = 0; ++w < r && (p *= 256); )
      l += this[e + w] * p;
    return l;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(e, r, u) {
    e = e >>> 0, r = r >>> 0, u || A(e, r, this.length);
    for (var l = this[e + --r], p = 1; r > 0 && (p *= 256); )
      l += this[e + --r] * p;
    return l;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(e, r) {
    return e = e >>> 0, r || A(e, 1, this.length), this[e];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(e, r) {
    return e = e >>> 0, r || A(e, 2, this.length), this[e] | this[e + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(e, r) {
    return e = e >>> 0, r || A(e, 2, this.length), this[e] << 8 | this[e + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(e, r) {
    return e = e >>> 0, r || A(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(e, r) {
    return e = e >>> 0, r || A(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  }, a.prototype.readIntLE = function(e, r, u) {
    e = e >>> 0, r = r >>> 0, u || A(e, r, this.length);
    for (var l = this[e], p = 1, w = 0; ++w < r && (p *= 256); )
      l += this[e + w] * p;
    return p *= 128, l >= p && (l -= Math.pow(2, 8 * r)), l;
  }, a.prototype.readIntBE = function(e, r, u) {
    e = e >>> 0, r = r >>> 0, u || A(e, r, this.length);
    for (var l = r, p = 1, w = this[e + --l]; l > 0 && (p *= 256); )
      w += this[e + --l] * p;
    return p *= 128, w >= p && (w -= Math.pow(2, 8 * r)), w;
  }, a.prototype.readInt8 = function(e, r) {
    return e = e >>> 0, r || A(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  }, a.prototype.readInt16LE = function(e, r) {
    e = e >>> 0, r || A(e, 2, this.length);
    var u = this[e] | this[e + 1] << 8;
    return u & 32768 ? u | 4294901760 : u;
  }, a.prototype.readInt16BE = function(e, r) {
    e = e >>> 0, r || A(e, 2, this.length);
    var u = this[e + 1] | this[e] << 8;
    return u & 32768 ? u | 4294901760 : u;
  }, a.prototype.readInt32LE = function(e, r) {
    return e = e >>> 0, r || A(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  }, a.prototype.readInt32BE = function(e, r) {
    return e = e >>> 0, r || A(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  }, a.prototype.readFloatLE = function(e, r) {
    return e = e >>> 0, r || A(e, 4, this.length), n.read(this, e, !0, 23, 4);
  }, a.prototype.readFloatBE = function(e, r) {
    return e = e >>> 0, r || A(e, 4, this.length), n.read(this, e, !1, 23, 4);
  }, a.prototype.readDoubleLE = function(e, r) {
    return e = e >>> 0, r || A(e, 8, this.length), n.read(this, e, !0, 52, 8);
  }, a.prototype.readDoubleBE = function(e, r) {
    return e = e >>> 0, r || A(e, 8, this.length), n.read(this, e, !1, 52, 8);
  };
  function C(o, e, r, u, l, p) {
    if (!a.isBuffer(o)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > l || e < p) throw new RangeError('"value" argument is out of bounds');
    if (r + u > o.length) throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(e, r, u, l) {
    if (e = +e, r = r >>> 0, u = u >>> 0, !l) {
      var p = Math.pow(2, 8 * u) - 1;
      C(this, e, r, u, p, 0);
    }
    var w = 1, E = 0;
    for (this[r] = e & 255; ++E < u && (w *= 256); )
      this[r + E] = e / w & 255;
    return r + u;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(e, r, u, l) {
    if (e = +e, r = r >>> 0, u = u >>> 0, !l) {
      var p = Math.pow(2, 8 * u) - 1;
      C(this, e, r, u, p, 0);
    }
    var w = u - 1, E = 1;
    for (this[r + w] = e & 255; --w >= 0 && (E *= 256); )
      this[r + w] = e / E & 255;
    return r + u;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
  }, a.prototype.writeIntLE = function(e, r, u, l) {
    if (e = +e, r = r >>> 0, !l) {
      var p = Math.pow(2, 8 * u - 1);
      C(this, e, r, u, p - 1, -p);
    }
    var w = 0, E = 1, B = 0;
    for (this[r] = e & 255; ++w < u && (E *= 256); )
      e < 0 && B === 0 && this[r + w - 1] !== 0 && (B = 1), this[r + w] = (e / E >> 0) - B & 255;
    return r + u;
  }, a.prototype.writeIntBE = function(e, r, u, l) {
    if (e = +e, r = r >>> 0, !l) {
      var p = Math.pow(2, 8 * u - 1);
      C(this, e, r, u, p - 1, -p);
    }
    var w = u - 1, E = 1, B = 0;
    for (this[r + w] = e & 255; --w >= 0 && (E *= 256); )
      e < 0 && B === 0 && this[r + w + 1] !== 0 && (B = 1), this[r + w] = (e / E >> 0) - B & 255;
    return r + u;
  }, a.prototype.writeInt8 = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
  }, a.prototype.writeInt16LE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
  }, a.prototype.writeInt16BE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
  }, a.prototype.writeInt32LE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
  }, a.prototype.writeInt32BE = function(e, r, u) {
    return e = +e, r = r >>> 0, u || C(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
  };
  function _t(o, e, r, u, l, p) {
    if (r + u > o.length) throw new RangeError("Index out of range");
    if (r < 0) throw new RangeError("Index out of range");
  }
  function It(o, e, r, u, l) {
    return e = +e, r = r >>> 0, l || _t(o, e, r, 4), n.write(o, e, r, u, 23, 4), r + 4;
  }
  a.prototype.writeFloatLE = function(e, r, u) {
    return It(this, e, r, !0, u);
  }, a.prototype.writeFloatBE = function(e, r, u) {
    return It(this, e, r, !1, u);
  };
  function Ft(o, e, r, u, l) {
    return e = +e, r = r >>> 0, l || _t(o, e, r, 8), n.write(o, e, r, u, 52, 8), r + 8;
  }
  a.prototype.writeDoubleLE = function(e, r, u) {
    return Ft(this, e, r, !0, u);
  }, a.prototype.writeDoubleBE = function(e, r, u) {
    return Ft(this, e, r, !1, u);
  }, a.prototype.copy = function(e, r, u, l) {
    if (!a.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (u || (u = 0), !l && l !== 0 && (l = this.length), r >= e.length && (r = e.length), r || (r = 0), l > 0 && l < u && (l = u), l === u || e.length === 0 || this.length === 0) return 0;
    if (r < 0)
      throw new RangeError("targetStart out of bounds");
    if (u < 0 || u >= this.length) throw new RangeError("Index out of range");
    if (l < 0) throw new RangeError("sourceEnd out of bounds");
    l > this.length && (l = this.length), e.length - r < l - u && (l = e.length - r + u);
    var p = l - u;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, u, l) : Uint8Array.prototype.set.call(
      e,
      this.subarray(u, l),
      r
    ), p;
  }, a.prototype.fill = function(e, r, u, l) {
    if (typeof e == "string") {
      if (typeof r == "string" ? (l = r, r = 0, u = this.length) : typeof u == "string" && (l = u, u = this.length), l !== void 0 && typeof l != "string")
        throw new TypeError("encoding must be a string");
      if (typeof l == "string" && !a.isEncoding(l))
        throw new TypeError("Unknown encoding: " + l);
      if (e.length === 1) {
        var p = e.charCodeAt(0);
        (l === "utf8" && p < 128 || l === "latin1") && (e = p);
      }
    } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (r < 0 || this.length < r || this.length < u)
      throw new RangeError("Out of range index");
    if (u <= r)
      return this;
    r = r >>> 0, u = u === void 0 ? this.length : u >>> 0, e || (e = 0);
    var w;
    if (typeof e == "number")
      for (w = r; w < u; ++w)
        this[w] = e;
    else {
      var E = a.isBuffer(e) ? e : a.from(e, l), B = E.length;
      if (B === 0)
        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (w = 0; w < u - r; ++w)
        this[w + r] = E[w % B];
    }
    return this;
  };
  var pe = /[^+/0-9A-Za-z-_]/g;
  function de(o) {
    if (o = o.split("=")[0], o = o.trim().replace(pe, ""), o.length < 2) return "";
    for (; o.length % 4 !== 0; )
      o = o + "=";
    return o;
  }
  function at(o, e) {
    e = e || 1 / 0;
    for (var r, u = o.length, l = null, p = [], w = 0; w < u; ++w) {
      if (r = o.charCodeAt(w), r > 55295 && r < 57344) {
        if (!l) {
          if (r > 56319) {
            (e -= 3) > -1 && p.push(239, 191, 189);
            continue;
          } else if (w + 1 === u) {
            (e -= 3) > -1 && p.push(239, 191, 189);
            continue;
          }
          l = r;
          continue;
        }
        if (r < 56320) {
          (e -= 3) > -1 && p.push(239, 191, 189), l = r;
          continue;
        }
        r = (l - 55296 << 10 | r - 56320) + 65536;
      } else l && (e -= 3) > -1 && p.push(239, 191, 189);
      if (l = null, r < 128) {
        if ((e -= 1) < 0) break;
        p.push(r);
      } else if (r < 2048) {
        if ((e -= 2) < 0) break;
        p.push(
          r >> 6 | 192,
          r & 63 | 128
        );
      } else if (r < 65536) {
        if ((e -= 3) < 0) break;
        p.push(
          r >> 12 | 224,
          r >> 6 & 63 | 128,
          r & 63 | 128
        );
      } else if (r < 1114112) {
        if ((e -= 4) < 0) break;
        p.push(
          r >> 18 | 240,
          r >> 12 & 63 | 128,
          r >> 6 & 63 | 128,
          r & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return p;
  }
  function we(o) {
    for (var e = [], r = 0; r < o.length; ++r)
      e.push(o.charCodeAt(r) & 255);
    return e;
  }
  function ye(o, e) {
    for (var r, u, l, p = [], w = 0; w < o.length && !((e -= 2) < 0); ++w)
      r = o.charCodeAt(w), u = r >> 8, l = r % 256, p.push(l), p.push(u);
    return p;
  }
  function At(o) {
    return t.toByteArray(de(o));
  }
  function tt(o, e, r, u) {
    for (var l = 0; l < u && !(l + r >= e.length || l >= o.length); ++l)
      e[l + r] = o[l];
    return l;
  }
  function L(o, e) {
    return o instanceof e || o != null && o.constructor != null && o.constructor.name != null && o.constructor.name === e.name;
  }
  function ct(o) {
    return o !== o;
  }
  var me = function() {
    for (var o = "0123456789abcdef", e = new Array(256), r = 0; r < 16; ++r)
      for (var u = r * 16, l = 0; l < 16; ++l)
        e[u + l] = o[r] + o[l];
    return e;
  }();
})(z);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(i, t) {
  var n = z, s = n.Buffer;
  function c(h, a) {
    for (var d in h)
      a[d] = h[d];
  }
  s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? i.exports = n : (c(n, t), t.Buffer = f);
  function f(h, a, d) {
    return s(h, a, d);
  }
  f.prototype = Object.create(s.prototype), c(s, f), f.from = function(h, a, d) {
    if (typeof h == "number")
      throw new TypeError("Argument must not be a number");
    return s(h, a, d);
  }, f.alloc = function(h, a, d) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    var y = s(h);
    return a !== void 0 ? typeof d == "string" ? y.fill(a, d) : y.fill(a) : y.fill(0), y;
  }, f.allocUnsafe = function(h) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    return s(h);
  }, f.allocUnsafeSlow = function(h) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(h);
  };
})(wt, wt.exports);
var Wt = wt.exports, Yt = Wt.Buffer;
function st(i, t) {
  this._block = Yt.alloc(i), this._finalSize = t, this._blockSize = i, this._len = 0;
}
st.prototype.update = function(i, t) {
  typeof i == "string" && (t = t || "utf8", i = Yt.from(i, t));
  for (var n = this._block, s = this._blockSize, c = i.length, f = this._len, h = 0; h < c; ) {
    for (var a = f % s, d = Math.min(c - h, s - a), y = 0; y < d; y++)
      n[a + y] = i[h + y];
    f += d, h += d, f % s === 0 && this._update(n);
  }
  return this._len += c, this;
};
st.prototype.digest = function(i) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var n = this._len * 8;
  if (n <= 4294967295)
    this._block.writeUInt32BE(n, this._blockSize - 4);
  else {
    var s = (n & 4294967295) >>> 0, c = (n - s) / 4294967296;
    this._block.writeUInt32BE(c, this._blockSize - 8), this._block.writeUInt32BE(s, this._blockSize - 4);
  }
  this._update(this._block);
  var f = this._hash();
  return i ? f.toString(i) : f;
};
st.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var ar = st, cr = Ze, Kt = ar, ur = Wt.Buffer, fr = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], hr = new Array(80);
function Q() {
  this.init(), this._w = hr, Kt.call(this, 64, 56);
}
cr(Q, Kt);
Q.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function lr(i) {
  return i << 1 | i >>> 31;
}
function pr(i) {
  return i << 5 | i >>> 27;
}
function dr(i) {
  return i << 30 | i >>> 2;
}
function wr(i, t, n, s) {
  return i === 0 ? t & n | ~t & s : i === 2 ? t & n | t & s | n & s : t ^ n ^ s;
}
Q.prototype._update = function(i) {
  for (var t = this._w, n = this._a | 0, s = this._b | 0, c = this._c | 0, f = this._d | 0, h = this._e | 0, a = 0; a < 16; ++a) t[a] = i.readInt32BE(a * 4);
  for (; a < 80; ++a) t[a] = lr(t[a - 3] ^ t[a - 8] ^ t[a - 14] ^ t[a - 16]);
  for (var d = 0; d < 80; ++d) {
    var y = ~~(d / 20), m = pr(n) + wr(y, s, c, f) + h + t[d] + fr[y] | 0;
    h = f, f = c, c = dr(s), s = n, n = m;
  }
  this._a = n + this._a | 0, this._b = s + this._b | 0, this._c = c + this._c | 0, this._d = f + this._d | 0, this._e = h + this._e | 0;
};
Q.prototype._hash = function() {
  var i = ur.allocUnsafe(20);
  return i.writeInt32BE(this._a | 0, 0), i.writeInt32BE(this._b | 0, 4), i.writeInt32BE(this._c | 0, 8), i.writeInt32BE(this._d | 0, 12), i.writeInt32BE(this._e | 0, 16), i;
};
var yr = Q;
const mr = /* @__PURE__ */ Xe(yr);
function gr(i) {
  let t = "";
  for (const n of new Uint8Array(i))
    n < 16 && (t += "0"), t += n.toString(16);
  return t;
}
let ht = null;
async function Lt(i) {
  return ht === null && (ht = await xr()), ht ? Vt(i) : br(i);
}
function br(i) {
  return new mr().update(i).digest("hex");
}
async function Vt(i) {
  const t = await crypto.subtle.digest("SHA-1", i);
  return gr(t);
}
async function xr() {
  try {
    if (await Vt(new Uint8Array([])) === "da39a3ee5e6b4b0d3255bfef95601890afd80709") return !0;
  } catch {
  }
  return !1;
}
function Er(i) {
  const t = [];
  let n = 0, s = 0;
  do {
    n = i.readUInt8();
    const c = n & 127;
    t.push(c), s = n & 128;
  } while (s);
  return t.reduce((c, f) => c + 1 << 7 | f, -1);
}
function Br(i, t) {
  let n = t, s = 4, c = null;
  do
    c = i.readUInt8(), n |= (c & 127) << s, s += 7;
  while (c & 128);
  return n;
}
class J {
  constructor(t) {
    Object.assign(this, t), this.offsetCache = {};
  }
  static async fromIdx({ idx: t, getExternalRefDelta: n }) {
    const s = new H(t);
    if (s.slice(4).toString("hex") !== "ff744f63")
      return;
    const f = s.readUInt32BE();
    if (f !== 2)
      throw new _(
        `Unable to read version ${f} packfile IDX. (Only version 2 supported)`
      );
    if (t.byteLength > 2048 * 1024 * 1024)
      throw new _(
        "To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size."
      );
    s.seek(s.tell() + 4 * 255);
    const h = s.readUInt32BE(), a = [];
    for (let m = 0; m < h; m++) {
      const g = s.slice(20).toString("hex");
      a[m] = g;
    }
    s.seek(s.tell() + 4 * h);
    const d = /* @__PURE__ */ new Map();
    for (let m = 0; m < h; m++)
      d.set(a[m], s.readUInt32BE());
    const y = s.slice(20).toString("hex");
    return new J({
      hashes: a,
      crcs: {},
      offsets: d,
      packfileSha: y,
      getExternalRefDelta: n
    });
  }
  static async fromPack({ pack: t, getExternalRefDelta: n, onProgress: s }) {
    const c = {
      1: "commit",
      2: "tree",
      3: "blob",
      4: "tag",
      6: "ofs-delta",
      7: "ref-delta"
    }, f = {}, h = t.slice(-20).toString("hex"), a = [], d = {}, y = /* @__PURE__ */ new Map();
    let m = null, g = null;
    await Ke([t], async ({ data: D, type: F, reference: P, offset: T, num: j }) => {
      m === null && (m = j);
      const $ = Math.floor(
        (m - j) * 100 / m
      );
      $ !== g && s && await s({
        phase: "Receiving objects",
        loaded: m - j,
        total: m
      }), g = $, F = c[F], ["commit", "tree", "blob", "tag"].includes(F) ? f[T] = {
        type: F,
        offset: T
      } : F === "ofs-delta" ? f[T] = {
        type: F,
        offset: T
      } : F === "ref-delta" && (f[T] = {
        type: F,
        offset: T
      });
    });
    const b = Object.keys(f).map(Number);
    for (const [D, F] of b.entries()) {
      const P = D + 1 === b.length ? t.byteLength - 20 : b[D + 1], T = f[F], j = xe.buf(t.slice(F, P)) >>> 0;
      T.end = P, T.crc = j;
    }
    const x = new J({
      pack: Promise.resolve(t),
      packfileSha: h,
      crcs: d,
      hashes: a,
      offsets: y,
      getExternalRefDelta: n
    });
    g = null;
    let U = 0;
    const N = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let D in f) {
      D = Number(D);
      const F = Math.floor(U * 100 / m);
      F !== g && s && await s({
        phase: "Resolving deltas",
        loaded: U,
        total: m
      }), U++, g = F;
      const P = f[D];
      if (!P.oid)
        try {
          x.readDepth = 0, x.externalReadDepth = 0;
          const { type: T, object: j } = await x.readSlice({ start: D });
          N[x.readDepth] += 1;
          const $ = await Lt(We.wrap({ type: T, object: j }));
          P.oid = $, a.push($), y.set($, D), d[$] = P.crc;
        } catch {
          continue;
        }
    }
    return a.sort(), x;
  }
  async toBuffer() {
    const t = [], n = (y, m) => {
      t.push(Buffer.from(y, m));
    };
    n("ff744f63", "hex"), n("00000002", "hex");
    const s = new H(Buffer.alloc(256 * 4));
    for (let y = 0; y < 256; y++) {
      let m = 0;
      for (const g of this.hashes)
        parseInt(g.slice(0, 2), 16) <= y && m++;
      s.writeUInt32BE(m);
    }
    t.push(s.buffer);
    for (const y of this.hashes)
      n(y, "hex");
    const c = new H(Buffer.alloc(this.hashes.length * 4));
    for (const y of this.hashes)
      c.writeUInt32BE(this.crcs[y]);
    t.push(c.buffer);
    const f = new H(Buffer.alloc(this.hashes.length * 4));
    for (const y of this.hashes)
      f.writeUInt32BE(this.offsets.get(y));
    t.push(f.buffer), n(this.packfileSha, "hex");
    const h = Buffer.concat(t), a = await Lt(h), d = Buffer.alloc(20);
    return d.write(a, "hex"), Buffer.concat([h, d]);
  }
  async load({ pack: t }) {
    this.pack = t;
  }
  async unload() {
    this.pack = null;
  }
  async read({ oid: t }) {
    if (!this.offsets.get(t)) {
      if (this.getExternalRefDelta)
        return this.externalReadDepth++, this.getExternalRefDelta(t);
      throw new _(`Could not read object ${t} from packfile`);
    }
    const n = this.offsets.get(t);
    return this.readSlice({ start: n });
  }
  async readSlice({ start: t }) {
    if (this.offsetCache[t])
      return Object.assign({}, this.offsetCache[t]);
    this.readDepth++;
    const n = {
      16: "commit",
      32: "tree",
      48: "blob",
      64: "tag",
      96: "ofs_delta",
      112: "ref_delta"
    };
    if (!this.pack)
      throw new _(
        "Tried to read from a GitPackIndex with no packfile loaded into memory"
      );
    const s = (await this.pack).slice(t), c = new H(s), f = c.readUInt8(), h = f & 112;
    let a = n[h];
    if (a === void 0)
      throw new _("Unrecognized type: 0b" + h.toString(2));
    const d = f & 15;
    let y = d;
    f & 128 && (y = Br(c, d));
    let g = null, b = null;
    if (a === "ofs_delta") {
      const U = Er(c), N = t - U;
      ({ object: g, type: a } = await this.readSlice({ start: N }));
    }
    if (a === "ref_delta") {
      const U = c.slice(20).toString("hex");
      ({ object: g, type: a } = await this.read({ oid: U }));
    }
    const x = s.slice(c.tell());
    if (b = Buffer.from(await Je(x)), b.byteLength !== y)
      throw new _(
        `Packfile told us object would have length ${y} but it had length ${b.byteLength}`
      );
    return g && (b = Buffer.from(Ye(b, g))), this.readDepth > 3 && (this.offsetCache[t] = { type: a, object: b }), { type: a, format: "content", object: b };
  }
}
class X extends Y {
  /**
   * @param {string} value
   */
  constructor(t) {
    super(`Expected a 40-char hex object id but saw "${t}".`), this.code = this.name = X.code, this.data = { value: t };
  }
}
X.code = "InvalidOidError";
class ot extends Y {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(t, n, s, c) {
    super(
      `Object ${t} ${c ? `at ${c}` : ""}was anticipated to be a ${s} but it is a ${n}.`
    ), this.code = this.name = ot.code, this.data = { oid: t, actual: n, expected: s, filepath: c };
  }
}
ot.code = "ObjectTypeError";
async function Jt(i, t) {
  const n = jt(i);
  for (; ; ) {
    const { value: s, done: c } = await n.next();
    if (s && await t(s), c) break;
  }
  n.return && n.return();
}
async function Z(i) {
  let t = 0;
  const n = [];
  await Jt(i, (f) => {
    n.push(f), t += f.byteLength;
  });
  const s = new Uint8Array(t);
  let c = 0;
  for (const f of n)
    s.set(f, c), c += f.byteLength;
  return s;
}
class lt {
  constructor() {
    this._queue = [];
  }
  write(t) {
    if (this._ended)
      throw Error("You cannot write to a FIFO that has already been ended!");
    if (this._waiting) {
      const n = this._waiting;
      this._waiting = null, n({ value: t });
    } else
      this._queue.push(t);
  }
  end() {
    if (this._ended = !0, this._waiting) {
      const t = this._waiting;
      this._waiting = null, t({ done: !0 });
    }
  }
  destroy(t) {
    this.error = t, this.end();
  }
  async next() {
    if (this._queue.length > 0)
      return { value: this._queue.shift() };
    if (this._ended)
      return { done: !0 };
    if (this._waiting)
      throw Error(
        "You cannot call read until the previous call to read has returned!"
      );
    return new Promise((t) => {
      this._waiting = t;
    });
  }
}
class vr {
  static demux(t) {
    const n = S.streamReader(t), s = new lt(), c = new lt(), f = new lt(), h = async function() {
      const a = await n();
      if (a === null) return h();
      if (a === !0) {
        s.end(), f.end(), t.error ? c.destroy(t.error) : c.end();
        return;
      }
      switch (a[0]) {
        case 1: {
          c.write(a.slice(1));
          break;
        }
        case 2: {
          f.write(a.slice(1));
          break;
        }
        case 3: {
          const d = a.slice(1);
          f.write(d), s.end(), f.end(), c.destroy(new Error(d.toString("utf8")));
          return;
        }
        default:
          s.write(a);
      }
      h();
    };
    return h(), {
      packetlines: s,
      packfile: c,
      progress: f
    };
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-64k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('010A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
}
async function Xt(i) {
  const { packetlines: t, packfile: n, progress: s } = vr.demux(i), c = [], f = [], h = [];
  let a = !1, d = !1;
  return new Promise((y, m) => {
    Jt(t, (g) => {
      const b = g.toString("utf8").trim();
      if (b.startsWith("shallow")) {
        const x = b.slice(-41).trim();
        x.length !== 40 && m(new X(x)), c.push(x);
      } else if (b.startsWith("unshallow")) {
        const x = b.slice(-41).trim();
        x.length !== 40 && m(new X(x)), f.push(x);
      } else if (b.startsWith("ACK")) {
        const [, x, U] = b.split(" ");
        h.push({ oid: x, status: U }), U || (d = !0);
      } else b.startsWith("NAK") ? (a = !0, d = !0) : (d = !0, a = !0);
      d && (i.error ? m(i.error) : y({ shallows: c, unshallows: f, acks: h, nak: a, packfile: n, progress: s }));
    }).finally(() => {
      d || (i.error ? m(i.error) : y({ shallows: c, unshallows: f, acks: h, nak: a, packfile: n, progress: s }));
    });
  });
}
typeof window < "u" && (window.Buffer = z.Buffer);
async function Kr(i, t, n) {
  const s = await Qt(i, t), c = await Fr(s, t, n), f = await Ar(
    i,
    n.map((a) => c[a].oid)
  ), h = {};
  return await Promise.all(
    n.map(async (a) => {
      h[a] = await te(
        f,
        c[a].oid
      );
    })
  ), h;
}
async function Vr(i, t) {
  const n = await Qt(i, t), s = await Ir(n, t);
  return s != null && s.object ? Zt(s) : [];
}
async function Jr(i, t) {
  switch ((t.type === "infer" || t.type === void 0) && (["", "HEAD"].includes(t.value) ? t = {
    value: t.value,
    type: "refname"
  } : typeof t.value == "string" && t.value.length === 40 && (t = {
    value: t.value,
    type: "commit"
  })), t.type === "branch" && (t = {
    value: `refs/heads/${t.value}`,
    type: "refname"
  }), t.type) {
    case "commit":
      return t.value;
    case "refname": {
      const n = await _r(i, t.value);
      if (!(t.value in n))
        throw new Error(`Branch ${t.value} not found`);
      return n[t.value];
    }
    default:
      throw new Error(`Invalid ref type: ${t.type}`);
  }
}
function Zt(i) {
  return i.object.map((t) => {
    if (t.type === "blob")
      return {
        name: t.path,
        type: "file"
      };
    if (t.type === "tree" && t.object)
      return {
        name: t.path,
        type: "folder",
        children: Zt(t)
      };
  }).filter((t) => !!(t != null && t.name));
}
async function _r(i, t) {
  const n = z.Buffer.from(
    await Z([
      S.encode(`command=ls-refs
`),
      S.encode(`agent=git/2.37.3
`),
      S.encode(`object-format=sha1
`),
      S.delim(),
      S.encode(`peel
`),
      S.encode(`ref-prefix ${t}
`),
      S.flush()
    ])
  ), s = await fetch(i + "/git-upload-pack", {
    method: "POST",
    headers: {
      Accept: "application/x-git-upload-pack-advertisement",
      "content-type": "application/x-git-upload-pack-request",
      "Content-Length": `${n.length}`,
      "Git-Protocol": "version=2"
    },
    body: n
  }), c = {};
  for await (const f of Sr(s)) {
    const h = f.indexOf(" "), a = f.slice(0, h), d = f.slice(h + 1, f.length - 1);
    c[d] = a;
  }
  return c;
}
async function Qt(i, t) {
  const n = z.Buffer.from(
    await Z([
      S.encode(
        `want ${t} multi_ack_detailed no-done side-band-64k thin-pack ofs-delta agent=git/2.37.3 filter 
`
      ),
      S.encode(`filter blob:none
`),
      S.encode(`shallow ${t}
`),
      S.encode(`deepen 1
`),
      S.flush(),
      S.encode(`done
`),
      S.encode(`done
`)
    ])
  ), s = await fetch(i + "/git-upload-pack", {
    method: "POST",
    headers: {
      Accept: "application/x-git-upload-pack-advertisement",
      "content-type": "application/x-git-upload-pack-request",
      "Content-Length": `${n.length}`
    },
    body: n
  }), c = ee(s.body), f = await Xt(c), h = z.Buffer.from(await Z(f.packfile)), a = await J.fromPack({
    pack: h
  }), d = a.read;
  return a.read = async function({ oid: y, ...m }) {
    const g = await d.call(this, { oid: y, ...m });
    return g.oid = y, g;
  }, a;
}
async function Ir(i, t) {
  const n = await i.read({
    oid: t
  });
  q(n);
  const s = await i.read({ oid: n.object.tree }), c = [s];
  for (; c.length > 0; ) {
    const f = c.pop(), h = await i.read({ oid: f.oid });
    if (q(h), f.object = h.object, h.type === "tree")
      for (const a of h.object)
        a.type === "tree" && c.push(a);
  }
  return s;
}
async function Fr(i, t, n) {
  const s = await i.read({
    oid: t
  });
  q(s);
  const c = await i.read({ oid: s.object.tree });
  q(c);
  const f = {};
  for (const h of n) {
    let a = c;
    const d = h.split("/");
    for (const y of d) {
      if (a.type !== "tree")
        throw new Error(`Path not found in the repo: ${h}`);
      let m = !1;
      for (const g of a.object)
        if (g.path === y) {
          try {
            a = await i.read({ oid: g.oid }), q(a);
          } catch {
            a = g;
          }
          m = !0;
          break;
        }
      if (!m)
        throw new Error(`Path not found in the repo: ${h}`);
    }
    f[h] = a;
  }
  return f;
}
async function Ar(i, t) {
  const n = z.Buffer.from(
    await Z([
      ...t.map(
        (a) => S.encode(
          `want ${a} multi_ack_detailed no-done side-band-64k thin-pack ofs-delta agent=git/2.37.3 
`
        )
      ),
      S.flush(),
      S.encode(`done
`)
    ])
  ), s = await fetch(i + "/git-upload-pack", {
    method: "POST",
    headers: {
      Accept: "application/x-git-upload-pack-advertisement",
      "content-type": "application/x-git-upload-pack-request",
      "Content-Length": `${n.length}`
    },
    body: n
  }), c = ee(s.body), f = await Xt(c), h = z.Buffer.from(await Z(f.packfile));
  return await J.fromPack({
    pack: h
  });
}
async function te(i, t) {
  const n = await i.read({ oid: t });
  if (q(n), n.type === "blob")
    return n.object;
  const s = {};
  for (const { path: c, oid: f, type: h } of n.object)
    if (h === "blob") {
      const a = await i.read({ oid: f });
      q(a), s[c] = a.object;
    } else h === "tree" && (s[c] = await te(i, f));
  return s;
}
function q(i) {
  if (i.object instanceof z.Buffer)
    switch (i.type) {
      case "commit":
        i.object = R.from(i.object).parse();
        break;
      case "tree":
        i.object = gt.from(i.object).entries();
        break;
      case "blob":
        i.object = new Uint8Array(i.object), i.format = "content";
        break;
      case "tag":
        i.object = K.from(i.object).parse();
        break;
      default:
        throw new ot(
          i.oid,
          i.type,
          "blob|commit|tag|tree"
        );
    }
}
async function* Sr(i) {
  const t = await i.text();
  let n = 0;
  for (; n <= t.length; ) {
    const s = parseInt(t.substring(n, n + 4), 16);
    if (s === 0)
      break;
    yield t.substring(n + 4, n + s), n += s;
  }
}
function ee(i) {
  if (i[Symbol.asyncIterator])
    return i;
  const t = i.getReader();
  return {
    next() {
      return t.read();
    },
    return() {
      return t.releaseLock(), {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function Xr(i, t) {
  t = mt(t);
  const n = ["", ".", "/"].includes(t);
  let s = i;
  if (n)
    t = "";
  else {
    const h = t.split("/");
    for (const a of h) {
      const d = s == null ? void 0 : s.find(
        (y) => y.name === a
      );
      if ((d == null ? void 0 : d.type) === "folder")
        s = d.children;
      else return d ? [d.name] : [];
    }
  }
  const c = [], f = [{ tree: s, path: t }];
  for (; f.length > 0; ) {
    const { tree: h, path: a } = f.pop();
    for (const d of h) {
      const y = `${a}${a ? "/" : ""}${d.name}`;
      d.type === "folder" ? f.push({
        tree: d.children,
        path: y
      }) : c.push(y);
    }
  }
  return c;
}
function Zr(i, t) {
  return i.startsWith(t) ? i.substring(t.length) : i;
}
class Qr {
  constructor(t) {
    this.fileTree = t;
  }
  async read(t) {
    let n = this.getEntryAtPath(t);
    if (typeof n == "string")
      n = new TextEncoder().encode(n);
    else if (!(n instanceof Uint8Array))
      throw new Error(`Unsupported content type: ${typeof n}`);
    const s = new ReadableStream({
      start(c) {
        c.enqueue(n), c.close();
      }
    });
    return new V(s, t, {
      filesize: n.byteLength
    });
  }
  getEntryAtPath(t) {
    let n = t.replace(/^\//, ""), s = this.fileTree;
    for (; n; ) {
      if (s[n])
        return s[n];
      const c = n.split("/"), f = c.shift();
      if (!f || !s[f])
        break;
      s = s[f], n = c.join("/");
    }
    throw new Error(`File not found at ${t}`);
  }
}
class yt {
  constructor(t) {
    this.entries = /* @__PURE__ */ new Map(), this.zipReader = t;
  }
  static fromStream(t) {
    const n = new kt(
      new Tt(new V(t, "archive.zip"))
    );
    return new yt(n);
  }
  static fromArrayBuffer(t) {
    const n = new kt(
      new Tt(new Blob([t]))
    );
    return new yt(n);
  }
  async read(t) {
    const n = await this.getEntry(t), s = await n.getData(new Ee());
    return new V(s.stream(), t, {
      filesize: n.uncompressedSize
    });
  }
  async getEntry(t) {
    const s = (await this.getEntries()).get(t.replace(/^\//, ""));
    if (!s)
      throw new Error(`File ${t} not found in the zip.`);
    return s;
  }
  async getEntries() {
    if (this.entries.size === 0) {
      const t = await this.zipReader.getEntries();
      for (const n of t)
        this.entries.set(n.filename, n);
    }
    return this.entries;
  }
}
class tn {
  /**
   * Creates a new OverlayFilesystem.
   *
   * @param filesystems An array of Filesystem instances to cascade through.
   *                    The order determines the priority - earlier filesystems
   *                    are checked first.
   */
  constructor(t) {
    if (!t.length)
      throw new Error(
        "OverlayFilesystem requires at least one filesystem"
      );
    this.filesystems = t;
  }
  /**
   * Reads a file by trying each filesystem in order until one succeeds.
   *
   * @param path The path to the file to read.
   * @returns A Promise that resolves to a StreamedFile from the first
   *          filesystem that successfully resolves the path.
   * @throws Error if all filesystems fail to resolve the path.
   */
  async read(t) {
    const n = [];
    for (const c of this.filesystems)
      try {
        return await c.read(t);
      } catch (f) {
        n.push(
          f instanceof Error ? f : new Error(String(f))
        );
      }
    const s = n.map((c) => c.message).join("; ");
    throw new Error(
      `Failed to read ${t} from any filesystem: ${s}`,
      { cause: n }
    );
  }
}
class en {
  constructor(t) {
    if (this.baseUrl = "", this.options = t, this.isDataUrl = t.baseUrl.startsWith("data:"), this.isDataUrl)
      return;
    const n = new URL("./", t.baseUrl);
    if (n.protocol !== "http:" && n.protocol !== "https:")
      throw new Error(
        "Unsupported protocol: " + n.protocol + ". Only HTTP and HTTPS are supported."
      );
    this.baseUrl = n.origin + n.pathname;
  }
  async read(t) {
    if (this.isDataUrl)
      throw new Error(
        "FetchFilesystem cannot fetch files from data URLs"
      );
    t = mt(t);
    const n = t.replace(/^\//, ""), s = new URL(n, this.baseUrl).toString();
    if (!s.startsWith(this.baseUrl))
      throw new Error(
        `Refused to read a file outside of the base URL: ${s}`
      );
    const c = this.options.corsProxy ? `${this.options.corsProxy}${encodeURIComponent(s)}` : s, f = await fetch(c);
    if (!f.ok)
      throw new Error(
        `Failed to fetch file at ${t}: ${f.statusText}`
      );
    const h = f.headers.get("content-length") ? parseInt(f.headers.get("content-length"), 10) : void 0;
    return new V(f.body, t, { filesize: h });
  }
}
class rn {
  constructor(t) {
    this.root = t;
  }
  async ensureNodeModules() {
    if (!this.fs || !this.path) {
      try {
        this.fs = await import("fs"), this.path = await import("path");
      } catch {
        this.fs = require("fs"), this.path = require("path");
      }
      this.root = this.path.resolve(this.root) + this.path.sep;
    }
  }
  async read(t) {
    if (await this.ensureNodeModules(), t = this.path.resolve(
      this.root,
      this.path.normalize(t.replace(/^\//, ""))
    ), !t.startsWith(this.root))
      throw new Error(
        `Refused to read a file outside of the root directory: ${t}`
      );
    return new Promise((n, s) => {
      const c = this.path.resolve(t), f = this.fs.createReadStream(c);
      f.on("error", (h) => {
        s(
          new Error(
            `Failed to read file at ${t}: ${h.message}`
          )
        );
      }), this.fs.stat(c, (h, a) => {
        h ? s(
          new Error(
            `Failed to read file at ${t}: ${h.message}`
          )
        ) : n(
          new V(
            Ur(f),
            t,
            {
              filesize: a.size
            }
          )
        );
      });
    });
  }
}
function Ur(i) {
  return new ReadableStream({
    start(n) {
      i.on("data", (s) => n.enqueue(s)), i.on("end", () => n.close());
    }
  });
}
export {
  en as FetchFilesystem,
  Qr as InMemoryFilesystem,
  rn as NodeJsFilesystem,
  tn as OverlayFilesystem,
  yt as ZipFilesystem,
  qr as changeset,
  Yr as clearContentsFromMountDevice,
  Dr as createClient,
  Gr as createCommit,
  Pr as createOrUpdateBranch,
  zr as createTree,
  $t as createTreeNode,
  Fe as createTreeNodes,
  Ae as deleteFile,
  ke as directoryHandleFromMountDevice,
  Wr as directoryHandleToOpfsPath,
  Lr as filesListToObject,
  jr as fork,
  Mr as getArtifact,
  Be as getFilesFromDirectory,
  Hr as iterateFiles,
  Xr as listDescendantFiles,
  Vr as listGitFiles,
  _r as listGitRefs,
  Nr as mayPush,
  Te as opfsPathToDirectoryHandle,
  Zr as removePathPrefix,
  Jr as resolveCommitHash,
  Kr as sparseCheckout
};
//# sourceMappingURL=index.js.map
