"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const c=require("@php-wasm/util");function l(i=fetch){const e={};return async function(t,r){if(!e[t]){e[t]={responsePromise:i(t,r),async nextResponse(){const s=await e[t].responsePromise,[$,f]=e[t].unlockedBodyStream.tee();return e[t].unlockedBodyStream=$,new Response(f,{status:s.status,statusText:s.statusText,headers:s.headers})}};const n=await e[t].responsePromise;e[t].unlockedBodyStream=n.body}return e[t].nextResponse()}}const p="8.0",a="/tmp/file.zip",u=async(i,e,o,t=!0)=>{if(e instanceof File){const n=e;e=a,await i.writeFile(e,new Uint8Array(await n.arrayBuffer()))}const r=c.phpVars({zipPath:e,extractToPath:o,overwriteFiles:t});await i.run({code:`<?php
        function unzip($zipPath, $extractTo, $overwriteFiles = true)
        {
            if (!is_dir($extractTo)) {
                mkdir($extractTo, 0777, true);
            }
            $zip = new ZipArchive;
            $res = $zip->open($zipPath);
            if ($res === TRUE) {
				for ($i = 0; $i < $zip->numFiles; $i++) {
					$filename = $zip->getNameIndex($i);
					$fileinfo = pathinfo($filename);
					$extractFilePath = rtrim($extractTo, '/') . '/' . $filename;
					// Check if file exists and $overwriteFiles is false
					if (!file_exists($extractFilePath) || $overwriteFiles) {
						// Extract file
						$zip->extractTo($extractTo, $filename);
					}
				}
				$zip->close();
				chmod($extractTo, 0777);
            } else {
                throw new Exception("Could not unzip file: " . $zip->getStatusString());
            }
        }
        unzip(${r.zipPath}, ${r.extractToPath}, ${r.overwriteFiles});
        `}),await i.fileExists(a)&&await i.unlink(a)},d=async(i,e)=>{const o=`/tmp/file${Math.random()}.zip`,t=c.phpVars({directoryPath:e,outputPath:o});await i.run({code:`<?php
		function zipDirectory($directoryPath, $outputPath) {
			$zip = new ZipArchive;
			$res = $zip->open($outputPath, ZipArchive::CREATE);
			if ($res !== TRUE) {
				throw new Exception('Failed to create ZIP');
			}
			$files = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator($directoryPath)
			);
			foreach ($files as $file) {
				$file = strval($file);
				if (is_dir($file)) {
					continue;
				}
				$zip->addFile($file, substr($file, strlen($directoryPath)));
			}
			$zip->close();
			chmod($outputPath, 0777);
		}
		zipDirectory(${t.directoryPath}, ${t.outputPath});
		`});const r=await i.readFileAsBuffer(o);return i.unlink(o),r};exports.RecommendedPHPVersion=p;exports.createMemoizedFetch=l;exports.unzipFile=u;exports.zipDirectory=d;
//# sourceMappingURL=index.cjs.map
