var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'node:path';
import { asArray, extToGlob, glob, readJson, resolveTsConfig } from './util.mjs';
import { DEFAULT_FIX_OPTIONS } from "./options.mjs";
export const getTsconfigTargets = (tsconfig, cwd) => asArray(tsconfig).reduce((targets, file) => {
    var _a, _b, _c, _d;
    const tsconfigJson = resolveTsConfig(path.resolve(cwd, file));
    const outDir = (_a = tsconfigJson === null || tsconfigJson === void 0 ? void 0 : tsconfigJson.compilerOptions) === null || _a === void 0 ? void 0 : _a.outDir;
    const module = (_d = (_b = tsconfigJson === null || tsconfigJson === void 0 ? void 0 : tsconfigJson.compilerOptions) === null || _b === void 0 ? void 0 : (_c = _b.module).toLowerCase) === null || _d === void 0 ? void 0 : _d.call(_c);
    if (outDir && module.startsWith('es')) {
        targets.push(outDir);
    }
    else {
        console.warn('tsconfig should declare `outDir` and `module` type es6 or above');
    }
    return targets;
}, []);
export const getLocalModules = (sources, targets, cwd, tsExt = DEFAULT_FIX_OPTIONS.tsExt) => glob(getPatterns(sources, targets, tsExt), {
    cwd,
    onlyFiles: true,
    absolute: true,
});
export const getExternalModules = (cwd_1, ...args_1) => __awaiter(void 0, [cwd_1, ...args_1], void 0, function* (cwd, jsExt = DEFAULT_FIX_OPTIONS.jsExt) {
    const allPackages = yield getExternalPackages(cwd);
    const allPackageNames = allPackages.map(p => p.name);
    const exportedModules = (yield Promise.all(allPackages.map(getPackageEntryPoints))).flat();
    const anyModules = yield getAllModules(cwd, jsExt);
    return {
        exportedModules,
        anyModules,
        allPackageNames,
    };
});
const getAllModules = (cwd_1, ...args_1) => __awaiter(void 0, [cwd_1, ...args_1], void 0, function* (cwd, jsExt = DEFAULT_FIX_OPTIONS.jsExt) {
    return glob([
        '!node_modules/.cache',
        '!node_modules/.bin',
        '!node_modules/**/node_modules',
        `node_modules/${extToGlob(jsExt)}`,
    ], {
        cwd,
        onlyFiles: true,
        absolute: true,
    });
});
const getPatterns = (sources, targets, tsExt) => sources.length > 0
    ? sources.map((src) => src.includes('*') ? src : `${src}/${extToGlob(tsExt)}`)
    : targets.map((target) => target.includes('*') ? target : `${target}/**/*.{js,d.ts}`);
export const parseConditional = (e) => e
    ? typeof e === 'string'
        ? [e]
        : Object.values(e).map(parseConditional).flat(2)
    : [];
export const getExportsEntries = (exports) => {
    if (!exports) {
        return [];
    }
    // has subpaths
    if (Object.keys(exports).some((k) => k.startsWith('.'))) {
        const entries = Object.entries(exports);
        return entries.map(([k, v]) => [k, parseConditional(v)]);
    }
    return [['.', parseConditional(exports)]];
};
const getExternalPackages = (cwd) => __awaiter(void 0, void 0, void 0, function* () {
    return glob(['node_modules/*/package.json', 'node_modules/@*/*/package.json'], {
        cwd,
        onlyFiles: true,
        absolute: true,
    })
        .then((files) => __awaiter(void 0, void 0, void 0, function* () {
        return Promise.all(files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
            const manifest = yield readJson(file);
            const root = path.dirname(file);
            const exports = getExportsEntries(manifest.exports);
            return {
                name: manifest.name,
                type: manifest.type,
                main: manifest.main,
                manifest,
                file,
                root,
                exports
            };
        })));
    }));
});
const getPackageEntryPoints = (_a) => __awaiter(void 0, [_a], void 0, function* ({ name, exports, root, main }) {
    return (yield Promise.all(exports.map(([key, values]) => Promise.all(values.map((value) => __awaiter(void 0, void 0, void 0, function* () {
        return (yield glob(value, { cwd: root, onlyFiles: true, absolute: false }))
            .map(file => path.join(file)
            .replace(resolvePrefix('.', value), resolvePrefix(name, key)));
    })))))).flat(2);
});
const resolvePrefix = (prefix, pattern) => {
    if (!pattern) {
        return prefix;
    }
    let _pattern = pattern;
    if (_pattern.includes('*')) {
        _pattern = _pattern.slice(0, _pattern.indexOf('*'));
        if (_pattern.includes('/')) {
            _pattern = _pattern.slice(0, _pattern.lastIndexOf('/'));
        }
    }
    return path.join(prefix, _pattern);
};
