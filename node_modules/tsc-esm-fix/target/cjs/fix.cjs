"use strict";
const {
  __spreadValues,
  __spreadProps,
  __export,
  __toESM,
  __toCommonJS,
  __async
} = require('./esblib.cjs');


// src/main/ts/fix.ts
var fix_exports = {};
__export(fix_exports, {
  fix: () => fix,
  fixFilenameExtensions: () => fixFilenameExtensions
});
module.exports = __toCommonJS(fix_exports);
var import_node_path3 = __toESM(require("node:path"), 1);

// src/main/ts/fixes/fix-blank-files.ts
var fixBlankFiles = (ctx) => {
  const { contents } = ctx;
  const _contents = contents.trim().length === 0 ? `
export {}
export default undefined
` : contents;
  return __spreadProps(__spreadValues({}, ctx), { contents: _contents });
};

// src/main/ts/fixes/fix-default-export.ts
var fixDefaultExport = (ctx) => {
  const { contents } = ctx;
  const _contents = contents.includes("export default") ? contents : `${contents}
export default undefined
`;
  return __spreadProps(__spreadValues({}, ctx), { contents: _contents });
};

// src/main/ts/fixes/fix-dirname-var.ts
var fixDirnameVar = (ctx) => {
  const { contents, isSource } = ctx;
  const _contents = contents.replace(
    /__dirname/g,
    `\`\${process.platform === 'win32' ? '' : '/'}\${/file:\\/{2,3}(.+)\\/[^/]/.exec(import.meta.url)${isSource ? "!" : ""}[1]}\``
    // eslint-disable-line
  );
  return __spreadProps(__spreadValues({}, ctx), { contents: _contents });
};
var fixFilenameVar = (ctx) => {
  const { contents, isSource } = ctx;
  const _contents = contents.replace(
    /__filename/g,
    `\`\${process.platform === 'win32' ? '' : '/'}\${/file:\\/{2,3}(.+)/.exec(import.meta.url)${isSource ? "!" : ""}[1]}\``
    // eslint-disable-line
  );
  return __spreadProps(__spreadValues({}, ctx), { contents: _contents });
};

// src/main/ts/fixes/fix-module-ref.ts
var import_node_path = __toESM(require("node:path"), 1);
var import_depseek = require("depseek");
var import_util = require("./util.cjs");
var import_options = require("./options.cjs");
var fixModuleReferences = (ctx) => {
  const { contents, filename, filenames, options: { cwd, jsExt }, ignore } = ctx;
  const _contents = (0, import_depseek.patchRefs)(contents, (value) => {
    const v = value.endsWith("/") ? value.slice(0, -1) : value;
    return (v.includes("/") || v === "." || v === "..") && !ignore.includes(v) ? resolveDependency(filename, v, filenames, cwd, jsExt) : value;
  });
  return __spreadProps(__spreadValues({}, ctx), { contents: _contents });
};
var resolveDependency = (parent, nested, files, cwd, jsExt = import_options.DEFAULT_FIX_OPTIONS.jsExt) => {
  const dir = import_node_path.default.dirname(parent);
  const nmdir = import_node_path.default.resolve(cwd, "node_modules");
  const bases = /^\..+\.[^./\\]+$/.test(nested) ? [nested, nested.replace(/\.[^./\\]+$/, "")] : [nested];
  const variants = jsExt.reduce((m, e) => {
    bases.forEach((v) => m.push(`${v}${e}`, `${v}/index${e}`));
    return m;
  }, []);
  return variants.find((f) => files.includes((0, import_util.unixify)(import_node_path.default.resolve(dir, f)))) || variants.find((f) => files.includes((0, import_util.unixify)(import_node_path.default.resolve(nmdir, f)))) || nested;
};

// src/main/ts/fixes/fix-sourcemap-ref.ts
var import_node_path2 = __toESM(require("node:path"), 1);
var fixSourceMapRef = (ctx) => {
  const { contents, originName, filename } = ctx;
  const _contents = originName === filename ? contents : contents.replace(
    `//# sourceMappingURL=${import_node_path2.default.basename(originName)}.map`,
    `//# sourceMappingURL=${import_node_path2.default.basename(filename)}.map`
  );
  return __spreadProps(__spreadValues({}, ctx), { contents: _contents });
};

// src/main/ts/fixes/index.ts
var fixContents = (ctx) => {
  const { options } = ctx;
  let _ctx = ctx;
  if (options.ext) _ctx = fixModuleReferences(_ctx);
  if (options.dirnameVar) _ctx = fixDirnameVar(_ctx);
  if (options.filenameVar) _ctx = fixFilenameVar(_ctx);
  if (options.fillBlank) _ctx = fixBlankFiles(_ctx);
  if (options.forceDefaultExport) _ctx = fixDefaultExport(_ctx);
  if (options.sourceMap) _ctx = fixSourceMapRef(_ctx);
  return _ctx;
};

// src/main/ts/fix.ts
var import_util2 = require("./util.cjs");
var import_finder = require("./finder.cjs");
var import_options2 = require("./options.cjs");
var fixFilenameExtensions = (names, ext) => names.map((name) => name.endsWith(".d.ts") ? name : name.replace(/\.[^./\\]+$/, ext));
var fix = (opts) => __async(void 0, null, function* () {
  const options = (0, import_options2.normalizeOptions)(opts);
  const ctx = yield resolve(options);
  yield patch(ctx, options);
});
var resolve = (options) => __async(void 0, null, function* () {
  const { cwd, target: _targets, src: sources, tsconfig, out = cwd, ext, debug, tsExt, jsExt } = options;
  const outDir = import_node_path3.default.resolve(cwd, out);
  const targets = _targets.length > 0 ? _targets : (0, import_finder.getTsconfigTargets)(tsconfig, cwd);
  debug("debug:cwd", cwd);
  debug("debug:outdir", outDir);
  debug("debug:sources", sources);
  debug("debug:targets", targets);
  const isSource = sources.length > 0;
  const localModules = yield (0, import_finder.getLocalModules)(sources, targets, cwd, tsExt);
  const {
    exportedModules,
    anyModules,
    allPackageNames
  } = yield (0, import_finder.getExternalModules)(cwd, jsExt);
  debug("debug:external-package-names", allPackageNames);
  debug("debug:external-exported-modules", exportedModules);
  debug("debug:external-any-modules", anyModules);
  const ignore = [...exportedModules, ...allPackageNames];
  const _localModules = typeof ext === "string" ? fixFilenameExtensions(localModules, ext) : localModules;
  const allModules = [...anyModules, ..._localModules];
  const allJsModules = [...anyModules, ...fixFilenameExtensions(localModules, ".js")];
  debug("debug:local-modules", _localModules);
  return {
    outDir,
    isSource,
    ignore,
    allJsModules,
    allModules,
    _localModules,
    localModules,
    options
  };
});
var patch = (ctx, options) => __async(void 0, null, function* () {
  const { cwd, unlink, sourceMap, tsExt, jsExt } = options;
  const {
    outDir,
    isSource,
    ignore,
    allJsModules,
    allModules,
    _localModules,
    localModules
  } = ctx;
  yield Promise.all(_localModules.map((name, i) => __async(void 0, null, function* () {
    const all = name.endsWith(".d.ts") ? allJsModules : allModules;
    const originName = localModules[i];
    const nextName = (isSource ? originName : name).replace(
      (0, import_util2.unixify)(cwd),
      (0, import_util2.unixify)(outDir)
    );
    const contents = (0, import_util2.read)(originName);
    const ctx2 = {
      options,
      contents,
      isSource,
      ignore,
      filename: name,
      filenames: all,
      originName,
      nextName
    };
    const { contents: _contents } = fixContents(ctx2);
    (0, import_util2.write)(nextName, _contents);
    if (!isSource && unlink && cwd === outDir && nextName !== originName) {
      (0, import_util2.remove)(originName);
    }
    if (sourceMap) {
      patchSourceFile(originName, nextName, unlink && cwd === outDir);
    }
  })));
});
var patchSourceFile = (name, nextName, unlink = false) => {
  if (name === nextName) {
    return;
  }
  const mapfile = `${name}.map`;
  if (!(0, import_util2.existsSync)(mapfile)) {
    return;
  }
  const nextMapfile = `${nextName}.map`;
  const contents = (0, import_util2.readJson)(mapfile);
  contents.file = import_node_path3.default.basename(nextName);
  (0, import_util2.write)(nextMapfile, JSON.stringify(contents));
  if (unlink) {
    (0, import_util2.remove)(mapfile);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  fix,
  fixFilenameExtensions
});