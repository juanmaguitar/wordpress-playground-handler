import { createRequire as topLevelCreateRequire } from 'module';
const require = topLevelCreateRequire(import.meta.url);
const __filename = import.meta.filename;
const __dirname = import.meta.dirname;

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// packages/php-wasm/node/jspi/php_8_4.js
var php_8_4_exports = {};
__export(php_8_4_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize,
  dependencyFilename: () => dependencyFilename,
  init: () => init
});
import path from "path";
function init(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      wasmTable = wasmExports["__indirect_function_table"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var wasmTableMirror = [];
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      if (Asyncify.isAsyncExport(func)) {
        wasmTableMirror[funcPtr] = func = Asyncify.makeAsyncFunction(func);
      }
    }
    return func;
  };
  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getdtablesize = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_sync: _fd_sync,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getcontext: _getcontext,
    /** @export */
    getdtablesize: _getdtablesize,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    makecontext: _makecontext,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    swapcontext: _swapcontext,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt,
    /** @export */
    wasm_shutdown: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename, dependenciesTotalSize;
var init_php_8_4 = __esm({
  "packages/php-wasm/node/jspi/php_8_4.js"() {
    "use strict";
    dependencyFilename = path.join(__dirname + "/jspi", "8_4_0", "php_8_4.wasm");
    dependenciesTotalSize = 21293725;
  }
});

// packages/php-wasm/node/jspi/php_8_3.js
var php_8_3_exports = {};
__export(php_8_3_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize2,
  dependencyFilename: () => dependencyFilename2,
  init: () => init2
});
import path2 from "path";
function init2(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename2);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      wasmTable = wasmExports["__indirect_function_table"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var wasmTableMirror = [];
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      if (Asyncify.isAsyncExport(func)) {
        wasmTableMirror[funcPtr] = func = Asyncify.makeAsyncFunction(func);
      }
    }
    return func;
  };
  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getdtablesize = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_sync: _fd_sync,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getcontext: _getcontext,
    /** @export */
    getdtablesize: _getdtablesize,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    makecontext: _makecontext,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    swapcontext: _swapcontext,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt,
    /** @export */
    wasm_shutdown: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename2, dependenciesTotalSize2;
var init_php_8_3 = __esm({
  "packages/php-wasm/node/jspi/php_8_3.js"() {
    "use strict";
    dependencyFilename2 = path2.join(__dirname + "/jspi", "8_3_0", "php_8_3.wasm");
    dependenciesTotalSize2 = 17917660;
  }
});

// packages/php-wasm/node/jspi/php_8_2.js
var php_8_2_exports = {};
__export(php_8_2_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize3,
  dependencyFilename: () => dependencyFilename3,
  init: () => init3
});
import path3 from "path";
function init3(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename3);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      wasmTable = wasmExports["__indirect_function_table"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var wasmTableMirror = [];
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      if (Asyncify.isAsyncExport(func)) {
        wasmTableMirror[funcPtr] = func = Asyncify.makeAsyncFunction(func);
      }
    }
    return func;
  };
  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getdtablesize = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_sync: _fd_sync,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getcontext: _getcontext,
    /** @export */
    getdtablesize: _getdtablesize,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    makecontext: _makecontext,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    swapcontext: _swapcontext,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt,
    /** @export */
    wasm_shutdown: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename3, dependenciesTotalSize3;
var init_php_8_2 = __esm({
  "packages/php-wasm/node/jspi/php_8_2.js"() {
    "use strict";
    dependencyFilename3 = path3.join(__dirname + "/jspi", "8_2_10", "php_8_2.wasm");
    dependenciesTotalSize3 = 17529377;
  }
});

// packages/php-wasm/node/jspi/php_8_1.js
var php_8_1_exports = {};
__export(php_8_1_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize4,
  dependencyFilename: () => dependencyFilename4,
  init: () => init4
});
import path4 from "path";
function init4(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename4);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      wasmTable = wasmExports["__indirect_function_table"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var wasmTableMirror = [];
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      if (Asyncify.isAsyncExport(func)) {
        wasmTableMirror[funcPtr] = func = Asyncify.makeAsyncFunction(func);
      }
    }
    return func;
  };
  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_sync: _fd_sync,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getcontext: _getcontext,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    makecontext: _makecontext,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    swapcontext: _swapcontext,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt,
    /** @export */
    wasm_shutdown: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename4, dependenciesTotalSize4;
var init_php_8_1 = __esm({
  "packages/php-wasm/node/jspi/php_8_1.js"() {
    "use strict";
    dependencyFilename4 = path4.join(__dirname + "/jspi", "8_1_23", "php_8_1.wasm");
    dependenciesTotalSize4 = 17185468;
  }
});

// packages/php-wasm/node/jspi/php_8_0.js
var php_8_0_exports = {};
__export(php_8_0_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize5,
  dependencyFilename: () => dependencyFilename5,
  init: () => init5
});
import path5 from "path";
function init5(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename5);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      wasmTable = wasmExports["__indirect_function_table"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var wasmTableMirror = [];
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      if (Asyncify.isAsyncExport(func)) {
        wasmTableMirror[funcPtr] = func = Asyncify.makeAsyncFunction(func);
      }
    }
    return func;
  };
  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt,
    /** @export */
    wasm_shutdown: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename5, dependenciesTotalSize5;
var init_php_8_0 = __esm({
  "packages/php-wasm/node/jspi/php_8_0.js"() {
    "use strict";
    dependencyFilename5 = path5.join(__dirname + "/jspi", "8_0_30", "php_8_0.wasm");
    dependenciesTotalSize5 = 17169869;
  }
});

// packages/php-wasm/node/jspi/php_7_4.js
var php_7_4_exports = {};
__export(php_7_4_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize6,
  dependencyFilename: () => dependencyFilename6,
  init: () => init6
});
import path6 from "path";
function init6(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename6);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt,
    /** @export */
    wasm_shutdown: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["dynCall_vi"])(
    a0,
    a1
  );
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename6, dependenciesTotalSize6;
var init_php_7_4 = __esm({
  "packages/php-wasm/node/jspi/php_7_4.js"() {
    "use strict";
    dependencyFilename6 = path6.join(__dirname + "/jspi", "7_4_33", "php_7_4.wasm");
    dependenciesTotalSize6 = 18397523;
  }
});

// packages/php-wasm/node/jspi/php_7_3.js
var php_7_3_exports = {};
__export(php_7_3_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize7,
  dependencyFilename: () => dependencyFilename7,
  init: () => init7
});
import path7 from "path";
function init7(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename7);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["dynCall_vi"])(
    a0,
    a1
  );
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename7, dependenciesTotalSize7;
var init_php_7_3 = __esm({
  "packages/php-wasm/node/jspi/php_7_3.js"() {
    "use strict";
    dependencyFilename7 = path7.join(__dirname + "/jspi", "7_3_33", "php_7_3.wasm");
    dependenciesTotalSize7 = 17915848;
  }
});

// packages/php-wasm/node/jspi/php_7_2.js
var php_7_2_exports = {};
__export(php_7_2_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize8,
  dependencyFilename: () => dependencyFilename8,
  init: () => init8
});
import path8 from "path";
function init8(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/jspi/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["__wasm_call_ctors"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    if (runtimeInitialized) {
      ___trap();
    }
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename8);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    Asyncify.instrumentWasmImports(wasmImports);
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["memory"];
      updateMemoryViews();
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  function _fd_close(fd) {
    _js_wasm_trace("fd_close(%d)", fd);
    const [vfsPath, pathResolutionErrno] = locking2.get_vfs_path_from_fd(fd);
    if (pathResolutionErrno !== 0) {
      _js_wasm_trace(
        "fd_close(%d) get_vfs_path_from_fd error %d",
        fd,
        pathResolutionErrno
      );
      return -ERRNO_CODES.EBADF;
    }
    const result = _builtin_fd_close(fd);
    if (result === 0 && locking2.maybeLockedFds.has(fd)) {
      const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
      return PHPLoader.fileLockManager.releaseLocksForProcessFd(
        PHPLoader.processId,
        fd,
        nativeFilePath
      ).then(() => {
        _js_wasm_trace("fd_close(%d) release locks success", fd);
      }).catch((e) => {
        _js_wasm_trace("fd_close(%d) error '%s'", fd, e);
      }).then(() => {
        _js_wasm_trace("fd_close(%d) result %d", fd, result);
        return result;
      }).finally(() => {
        locking2.maybeLockedFds.delete(fd);
      });
    } else {
      _js_wasm_trace("fd_close(%d) result %d", fd, result);
      return result;
    }
  }
  function _builtin_fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _builtin_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var locking2 = {
    maybeLockedFds: /* @__PURE__ */ new Set(),
    F_RDLCK: 0,
    F_WRLCK: 1,
    F_UNLCK: 2,
    lockStateToFcntl: {
      shared: 0,
      exclusive: 1,
      unlocked: 2
    },
    fcntlToLockState: {
      0: "shared",
      1: "exclusive",
      2: "unlocked"
    },
    is_shared_fs_node(node) {
      if (node?.isSharedFS) {
        return true;
      }
      if (!node?.mount?.opts?.fs?.lookupPath || !node?.mount?.type?.realPath) {
        return false;
      }
      if (node.mount.type !== NODEFS) {
        return false;
      }
      const vfsPath = node.mount.type.realPath(node);
      try {
        const underlyingNode = node.mount.opts.fs.lookupPath(vfsPath)?.node;
        return !!underlyingNode?.isSharedFS;
      } catch (e) {
        return false;
      }
    },
    is_path_to_shared_fs(path17) {
      const { node } = FS.lookupPath(path17);
      return locking2.is_shared_fs_node(node);
    },
    get_fd_access_mode(fd) {
      const emscripten_F_GETFL = Number("3");
      const emscripten_O_ACCMODE = Number("2097155");
      return _builtin_fcntl64(fd, emscripten_F_GETFL) & emscripten_O_ACCMODE;
    },
    get_vfs_path_from_fd(fd) {
      try {
        return [FS.readlink(`/proc/self/fd/${fd}`), 0];
      } catch (error) {
        return [null, ERRNO_CODES.EBADF];
      }
    },
    get_native_path_from_vfs_path(vfsPath) {
      const { node } = FS.lookupPath(vfsPath);
      return NODEFS.realPath(node);
    },
    check_lock_params(fd, l_type) {
      const emscripten_O_RDONLY = Number("0");
      const emscripten_O_WRONLY = Number("1");
      const accessMode = locking2.get_fd_access_mode(fd);
      if (l_type === locking2.F_WRLCK && accessMode === emscripten_O_RDONLY || l_type === locking2.F_RDLCK && accessMode === emscripten_O_WRONLY) {
        return ERRNO_CODES.EBADF;
      }
      return 0;
    }
  };
  async function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    const emscripten_F_GETLK = Number("12");
    const emscripten_F_SETLK = Number("13");
    const emscripten_F_SETLKW = Number("14");
    const emscripten_SEEK_SET = Number("0");
    const emscripten_flock_l_type_offset = 0;
    const emscripten_flock_l_whence_offset = 2;
    const emscripten_flock_l_start_offset = 8;
    const emscripten_flock_l_len_offset = 16;
    const emscripten_flock_l_pid_offset = 24;
    function read_flock_struct(flockStructAddress) {
      return {
        l_type: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ],
        l_whence: HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ],
        l_start: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ],
        l_len: HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ],
        l_pid: HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ]
      };
    }
    function update_flock_struct(flockStructAddress, fields) {
      if (fields.l_type !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_type_offset >> 1
        ] = fields.l_type;
      }
      if (fields.l_whence !== void 0) {
        HEAP16[
          // Shift right by 1 to divide by 2^1.
          flockStructAddress + emscripten_flock_l_whence_offset >> 1
        ] = fields.l_whence;
      }
      if (fields.l_start !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_start_offset >> 3
        ] = fields.l_start;
      }
      if (fields.l_len !== void 0) {
        HEAP64[
          // Shift right by 3 to divide by 2^3.
          flockStructAddress + emscripten_flock_l_len_offset >> 3
        ] = fields.l_len;
      }
      if (fields.l_pid !== void 0) {
        HEAP32[
          // Shift right by 2 to divide by 2^2.
          flockStructAddress + emscripten_flock_l_pid_offset >> 2
        ] = fields.l_pid;
      }
    }
    function get_base_address(fd2, whence, startOffset) {
      let baseAddress;
      switch (whence) {
        case emscripten_SEEK_SET:
          baseAddress = 0n;
          break;
        case emscripten_SEEK_CUR:
          baseAddress = FS.lseek(fd2, 0, whence);
          break;
        case emscripten_SEEK_END:
          baseAddress = _wasm_get_end_offset(fd2);
          break;
        default:
          return [null, ERRNO_CODES.EINVAL];
      }
      if (baseAddress == -1) {
        return [null, ERRNO_CODES.EBADF];
      }
      const resolvedOffset = baseAddress + startOffset;
      if (resolvedOffset < 0) {
        return [null, ERRNO_CODES.EINVAL];
      }
      return [resolvedOffset, 0];
    }
    const pid = PHPLoader.processId;
    switch (cmd) {
      case emscripten_F_GETLK: {
        _js_wasm_trace("fcntl(%d, F_GETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EBADF;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) locking is not implemented for non-NodeFS path '%s'",
            fd,
            vfsPath
          );
          update_flock_struct(flockStructAddr2, {
            l_type: F_UNLCK
          });
          return 0;
        }
        const flockStructAddr2 = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr2);
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -ERRNO_CODES.EINVAL;
        }
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        return PHPLoader.fileLockManager.findFirstConflictingByteRangeLock(nativeFilePath, {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        }).then((conflictingLock) => {
          if (conflictingLock === void 0) {
            _js_wasm_trace(
              "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=unlocked start=0x%x end=0x%x",
              fd,
              vfsPath,
              absoluteStartOffset,
              absoluteStartOffset + flockStruct.l_len
            );
            update_flock_struct(flockStructAddr2, {
              l_type: F_UNLCK
            });
            return 0;
          }
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock type=%s start=0x%x end=0x%x conflictingLock %d",
            fd,
            vfsPath,
            conflictingLock.type,
            conflictingLock.start,
            conflictingLock.end,
            conflictingLock.pid
          );
          const fcntlLockState = locking2.lockStateToFcntl[conflictingLock.type];
          update_flock_struct(flockStructAddr2, {
            l_type: fcntlLockState,
            l_whence: emscripten_SEEK_SET,
            l_start: conflictingLock.start,
            l_len: conflictingLock.end - conflictingLock.start,
            l_pid: conflictingLock.pid
          });
          return 0;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_GETLK) %s findFirstConflictingByteRangeLock error %s",
            fd,
            vfsPath,
            e
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLK: {
        _js_wasm_trace("fcntl(%d, F_SETLK)", fd);
        let vfsPath;
        let errno;
        [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_vfs_path_from_fd errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!locking2.is_path_to_shared_fs(vfsPath)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) locking is not implemented for non-NodeFS path %s",
            fd,
            vfsPath
          );
          return 0;
        }
        var flockStructAddr = syscallGetVarargP();
        const flockStruct = read_flock_struct(flockStructAddr);
        let absoluteStartOffset;
        [absoluteStartOffset, errno] = get_base_address(
          fd,
          flockStruct.l_whence,
          flockStruct.l_start
        );
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s get_base_address errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        if (!(flockStruct.l_type in locking2.fcntlToLockState)) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s invalid lock type %d",
            fd,
            vfsPath,
            flockStruct.l_type
          );
          return -ERRNO_CODES.EINVAL;
        }
        errno = locking2.check_lock_params(fd, flockStruct.l_type);
        if (errno !== 0) {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s check_lock_params errno %d",
            fd,
            vfsPath,
            errno
          );
          return -errno;
        }
        locking2.maybeLockedFds.add(fd);
        const requestedLockType = locking2.fcntlToLockState[flockStruct.l_type];
        const rangeLock = {
          type: requestedLockType,
          start: absoluteStartOffset,
          end: absoluteStartOffset + flockStruct.l_len,
          pid
        };
        const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
        _js_wasm_trace(
          "fcntl(%d, F_SETLK) %s calling lockFileByteRange for range lock %s",
          fd,
          vfsPath,
          rangeLock
        );
        return PHPLoader.fileLockManager.lockFileByteRange(nativeFilePath, rangeLock).then((succeeded) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange returned %d for range lock %s",
            fd,
            vfsPath,
            succeeded,
            rangeLock
          );
          return succeeded ? 0 : -ERRNO_CODES.EAGAIN;
        }).catch((e) => {
          _js_wasm_trace(
            "fcntl(%d, F_SETLK) %s lockFileByteRange error %s for range lock %s",
            fd,
            vfsPath,
            e,
            rangeLock
          );
          return -ERRNO_CODES.EINVAL;
        });
      }
      case emscripten_F_SETLKW: {
        return -ERRNO_CODES.EDEADLK;
      }
      default:
        return _builtin_fcntl64(fd, cmd, varargs);
    }
  }
  ___syscall_fcntl64.isAsync = true;
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  async function _js_flock(fd, op) {
    _js_wasm_trace("js_flock(%d, %d)", fd, op);
    const emscripten_LOCK_SH = 1;
    const emscripten_LOCK_EX = 2;
    const emscripten_LOCK_NB = 4;
    const emscripten_LOCK_UN = 8;
    const flockToLockOpType = {
      [emscripten_LOCK_SH]: "shared",
      [emscripten_LOCK_EX]: "exclusive",
      [emscripten_LOCK_UN]: "unlocked"
    };
    let vfsPath;
    let errno;
    [vfsPath, errno] = locking2.get_vfs_path_from_fd(fd);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) get_vfs_path_from_fd errno %d",
        fd,
        op,
        vfsPath,
        errno
      );
      return -errno;
    }
    if (!locking2.is_path_to_shared_fs(vfsPath)) {
      _js_wasm_trace(
        "flock(%d, %d) locking is not implemented for non-NodeFS path %s",
        fd,
        op,
        vfsPath
      );
      return 0;
    }
    errno = locking2.check_lock_params(fd, op);
    if (errno !== 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) check_lock_params errno %d",
        fd,
        op,
        errno
      );
      return -errno;
    }
    if (op & emscripten_LOCK_NB === 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) blocking mode of flock() is not implemented",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const maskedOp = op & (emscripten_LOCK_SH | emscripten_LOCK_EX | emscripten_LOCK_UN);
    const lockOpType = flockToLockOpType[maskedOp];
    if (lockOpType === void 0) {
      _js_wasm_trace(
        "js_flock(%d, %d) invalid flock() operation",
        fd,
        op
      );
      return -ERRNO_CODES.EINVAL;
    }
    const nativeFilePath = locking2.get_native_path_from_vfs_path(vfsPath);
    const obtainedLock = await PHPLoader.fileLockManager.lockWholeFile(
      nativeFilePath,
      {
        type: lockOpType,
        pid: PHPLoader.processId,
        fd
      }
    );
    _js_wasm_trace(
      "js_flock(%d, %d) lockWholeFile %s returned %d",
      fd,
      op,
      vfsPath,
      obtainedLock
    );
    return obtainedLock ? 0 : -ERRNO_CODES.EWOULDBLOCK;
  }
  _js_flock.isAsync = true;
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  var _js_release_file_locks = async function js_release_file_locks() {
    _js_wasm_trace("js_release_file_locks()");
    const pid = PHPLoader.processId;
    return await PHPLoader.fileLockManager.releaseLocksForProcess(pid).then(() => {
      _js_wasm_trace("js_release_file_locks succeeded");
    }).catch((e) => {
      _js_wasm_trace("js_release_file_locks error %s", e);
    });
  };
  _js_release_file_locks.isAsync = true;
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(js_open_process|js_waitpid|js_process_status|js_create_input_device|wasm_setsockopt|wasm_shutdown|wasm_close|invoke_.*|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
          if (isAsyncifyImport) {
            imports[x] = original = new WebAssembly.Suspending(
              original
            );
          }
        }
      }
    },
    instrumentWasmExports(exports) {
      var exportPattern = /^(wasm_sleep|wasm_read|emscripten_sleep|wasm_sapi_handle_request|wasm_sapi_request_shutdown|wasm_poll_socket|wrap_select|__wrap_select|select|php_pollfd_for|fflush|wasm_popen|wasm_read|wasm_php_exec|run_cli|main|__main_argc_argv)$/;
      Asyncify.asyncExports = /* @__PURE__ */ new Set();
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          let isAsyncifyExport = exportPattern.test(x);
          if (isAsyncifyExport) {
            Asyncify.asyncExports.add(original);
            original = Asyncify.makeAsyncFunction(original);
          }
          ret[x] = (...args) => original(...args);
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    asyncExports: null,
    isAsyncExport(func) {
      return Asyncify.asyncExports?.has(func);
    },
    handleAsync: async (startAsync) => {
      runtimeKeepalivePush();
      try {
        return await startAsync();
      } finally {
        runtimeKeepalivePop();
      }
    },
    handleSleep(startAsync) {
      return Asyncify.handleAsync(() => new Promise(startAsync));
    },
    makeAsyncFunction(original) {
      return WebAssembly.promising(original);
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var stackSave = () => _emscripten_stack_get_current();
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func(...cArgs);
    function onDone(ret2) {
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    if (asyncMode)
      return ret.then(onDone);
    ret = onDone(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function __asyncjs__js_popen_to_file(command, mode, exitCodePtr) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (!command)
        return 1;
      const cmdstr = UTF8ToString(command);
      if (!cmdstr.length)
        return 0;
      const modestr = UTF8ToString(mode);
      if (!modestr.length)
        return 0;
      if (modestr === "w") {
        console.error('popen($cmd, "w") is not implemented yet');
      }
      return returnCallback(async (wakeUp) => {
        let cp;
        try {
          cp = PHPWASM.spawnProcess(cmdstr, []);
          if (cp instanceof Promise) {
            cp = await cp;
          }
        } catch (e) {
          console.error(e);
          if (e.code === "SPAWN_UNSUPPORTED") {
            return 1;
          }
          throw e;
        }
        const outByteArrays = [];
        cp.stdout.on("data", function(data) {
          outByteArrays.push(data);
        });
        const outputPath = "/tmp/popen_output";
        cp.on("exit", function(exitCode) {
          const outBytes = new Uint8Array(
            outByteArrays.reduce(
              (acc, curr) => acc + curr.length,
              0
            )
          );
          let offset = 0;
          for (const byteArray of outByteArrays) {
            outBytes.set(byteArray, offset);
            offset += byteArray.length;
          }
          FS.writeFile(outputPath, outBytes);
          HEAPU8[exitCodePtr] = exitCode;
          wakeUp(allocateUTF8OnStack(outputPath));
        });
      });
    });
  }
  __asyncjs__js_popen_to_file.sig = "iiii";
  function __asyncjs__wasm_poll_socket(socketd, events, timeout) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      const POLLIN = 1;
      const POLLPRI = 2;
      const POLLOUT = 4;
      const POLLERR = 8;
      const POLLHUP = 16;
      const POLLNVAL = 32;
      return returnCallback((wakeUp) => {
        const polls = [];
        if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
          const sock = getSocketFromFD(socketd);
          if (!sock) {
            wakeUp(0);
            return;
          }
          const lookingFor = /* @__PURE__ */ new Set();
          if (events & POLLIN || events & POLLPRI) {
            if (sock.server) {
              for (const client of sock.pending) {
                if ((client.recv_queue || []).length > 0) {
                  wakeUp(1);
                  return;
                }
              }
            } else if ((sock.recv_queue || []).length > 0) {
              wakeUp(1);
              return;
            }
          }
          const webSockets = PHPWASM.getAllWebSockets(sock);
          if (!webSockets.length) {
            wakeUp(0);
            return;
          }
          for (const ws of webSockets) {
            if (events & POLLIN || events & POLLPRI) {
              polls.push(PHPWASM.awaitData(ws));
              lookingFor.add("POLLIN");
            }
            if (events & POLLOUT) {
              polls.push(PHPWASM.awaitConnection(ws));
              lookingFor.add("POLLOUT");
            }
            if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
              polls.push(PHPWASM.awaitClose(ws));
              lookingFor.add("POLLHUP");
            }
            if (events & POLLERR || events & POLLNVAL) {
              polls.push(PHPWASM.awaitError(ws));
              lookingFor.add("POLLERR");
            }
          }
        } else if (socketd in PHPWASM.child_proc_by_fd) {
          const procInfo = PHPWASM.child_proc_by_fd[socketd];
          if (procInfo.exited) {
            wakeUp(0);
            return;
          }
          polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
        } else {
          setTimeout(function() {
            wakeUp(1);
          }, timeout);
          return;
        }
        if (polls.length === 0) {
          console.warn(
            "Unsupported poll event " + events + ", defaulting to setTimeout()."
          );
          setTimeout(function() {
            wakeUp(0);
          }, timeout);
          return;
        }
        const promises = polls.map(([promise]) => promise);
        const clearPolling = () => polls.forEach(([, clear]) => clear());
        let awaken = false;
        let timeoutId;
        Promise.race(promises).then(function(results) {
          if (!awaken) {
            awaken = true;
            wakeUp(1);
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            clearPolling();
          }
        });
        if (timeout !== -1) {
          timeoutId = setTimeout(function() {
            if (!awaken) {
              awaken = true;
              wakeUp(0);
              clearPolling();
            }
          }, timeout);
        }
      });
    });
  }
  __asyncjs__wasm_poll_socket.sig = "iiii";
  function __asyncjs__js_fd_read(fd, iov, iovcnt, pnum) {
    return Asyncify.handleAsync(async () => {
      const returnCallback = (resolver) => new Promise(resolver);
      if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
        var returnCode;
        var stream;
        let num = 0;
        try {
          stream = SYSCALLS.getStreamFromFD(fd);
          const num2 = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num2;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            throw e;
          }
          if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
            HEAPU32[pnum >> 2] = 0;
            return returnCode;
          }
        }
      }
      return returnCallback((wakeUp) => {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          let num;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            num = doReadv(stream2, iov, iovcnt);
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          const success = returnCode2 === 0;
          const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
          if (success) {
            HEAPU32[pnum >> 2] = num;
            wakeUp(0);
          } else if (failure) {
            HEAPU32[pnum >> 2] = 0;
            wakeUp(returnCode2 === 6 ? 0 : returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    });
  }
  __asyncjs__js_fd_read.sig = "iiiii";
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  __asyncjs__js_module_onMessage.sig = "iii";
  var wasmImports = {
    /** @export */
    __assert_fail: ___assert_fail,
    /** @export */
    __asyncjs__js_fd_read,
    /** @export */
    __asyncjs__js_module_onMessage,
    /** @export */
    __asyncjs__js_popen_to_file,
    /** @export */
    __asyncjs__wasm_poll_socket,
    /** @export */
    __call_sighandler: ___call_sighandler,
    /** @export */
    __syscall_accept4: ___syscall_accept4,
    /** @export */
    __syscall_bind: ___syscall_bind,
    /** @export */
    __syscall_chdir: ___syscall_chdir,
    /** @export */
    __syscall_chmod: ___syscall_chmod,
    /** @export */
    __syscall_connect: ___syscall_connect,
    /** @export */
    __syscall_dup: ___syscall_dup,
    /** @export */
    __syscall_dup3: ___syscall_dup3,
    /** @export */
    __syscall_faccessat: ___syscall_faccessat,
    /** @export */
    __syscall_fallocate: ___syscall_fallocate,
    /** @export */
    __syscall_fchmod: ___syscall_fchmod,
    /** @export */
    __syscall_fchown32: ___syscall_fchown32,
    /** @export */
    __syscall_fchownat: ___syscall_fchownat,
    /** @export */
    __syscall_fcntl64: ___syscall_fcntl64,
    /** @export */
    __syscall_fdatasync: ___syscall_fdatasync,
    /** @export */
    __syscall_fstat64: ___syscall_fstat64,
    /** @export */
    __syscall_ftruncate64: ___syscall_ftruncate64,
    /** @export */
    __syscall_getcwd: ___syscall_getcwd,
    /** @export */
    __syscall_getdents64: ___syscall_getdents64,
    /** @export */
    __syscall_getpeername: ___syscall_getpeername,
    /** @export */
    __syscall_getsockname: ___syscall_getsockname,
    /** @export */
    __syscall_getsockopt: ___syscall_getsockopt,
    /** @export */
    __syscall_ioctl: ___syscall_ioctl,
    /** @export */
    __syscall_listen: ___syscall_listen,
    /** @export */
    __syscall_lstat64: ___syscall_lstat64,
    /** @export */
    __syscall_mkdirat: ___syscall_mkdirat,
    /** @export */
    __syscall_newfstatat: ___syscall_newfstatat,
    /** @export */
    __syscall_openat: ___syscall_openat,
    /** @export */
    __syscall_pipe: ___syscall_pipe,
    /** @export */
    __syscall_poll: ___syscall_poll,
    /** @export */
    __syscall_readlinkat: ___syscall_readlinkat,
    /** @export */
    __syscall_recvfrom: ___syscall_recvfrom,
    /** @export */
    __syscall_renameat: ___syscall_renameat,
    /** @export */
    __syscall_rmdir: ___syscall_rmdir,
    /** @export */
    __syscall_sendto: ___syscall_sendto,
    /** @export */
    __syscall_socket: ___syscall_socket,
    /** @export */
    __syscall_stat64: ___syscall_stat64,
    /** @export */
    __syscall_statfs64: ___syscall_statfs64,
    /** @export */
    __syscall_symlinkat: ___syscall_symlinkat,
    /** @export */
    __syscall_unlinkat: ___syscall_unlinkat,
    /** @export */
    __syscall_utimensat: ___syscall_utimensat,
    /** @export */
    _abort_js: __abort_js,
    /** @export */
    _emscripten_lookup_name: __emscripten_lookup_name,
    /** @export */
    _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
    /** @export */
    _gmtime_js: __gmtime_js,
    /** @export */
    _localtime_js: __localtime_js,
    /** @export */
    _mktime_js: __mktime_js,
    /** @export */
    _mmap_js: __mmap_js,
    /** @export */
    _munmap_js: __munmap_js,
    /** @export */
    _setitimer_js: __setitimer_js,
    /** @export */
    _tzset_js: __tzset_js,
    /** @export */
    clock_time_get: _clock_time_get,
    /** @export */
    emscripten_date_now: _emscripten_date_now,
    /** @export */
    emscripten_get_heap_max: _emscripten_get_heap_max,
    /** @export */
    emscripten_get_now: _emscripten_get_now,
    /** @export */
    emscripten_resize_heap: _emscripten_resize_heap,
    /** @export */
    emscripten_sleep: _emscripten_sleep,
    /** @export */
    environ_get: _environ_get,
    /** @export */
    environ_sizes_get: _environ_sizes_get,
    /** @export */
    exit: _exit,
    /** @export */
    fd_close: _fd_close,
    /** @export */
    fd_fdstat_get: _fd_fdstat_get,
    /** @export */
    fd_read: _fd_read,
    /** @export */
    fd_seek: _fd_seek,
    /** @export */
    fd_write: _fd_write,
    /** @export */
    getaddrinfo: _getaddrinfo,
    /** @export */
    getnameinfo: _getnameinfo,
    /** @export */
    getprotobyname: _getprotobyname,
    /** @export */
    getprotobynumber: _getprotobynumber,
    /** @export */
    js_create_input_device: _js_create_input_device,
    /** @export */
    js_flock: _js_flock,
    /** @export */
    js_getpid: _js_getpid,
    /** @export */
    js_open_process: _js_open_process,
    /** @export */
    js_process_status: _js_process_status,
    /** @export */
    js_release_file_locks: _js_release_file_locks,
    /** @export */
    js_waitpid: _js_waitpid,
    /** @export */
    js_wasm_trace: _js_wasm_trace,
    /** @export */
    proc_exit: _proc_exit,
    /** @export */
    strptime: _strptime,
    /** @export */
    wasm_close: _wasm_close,
    /** @export */
    wasm_setsockopt: _wasm_setsockopt
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
  var _malloc = (a0) => (_malloc = wasmExports["malloc"])(a0);
  var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wasm_sleep"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
  var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wasm_read"])(
    a0,
    a1,
    a2
  );
  var _fflush = (a0) => (_fflush = wasmExports["fflush"])(a0);
  var _flock = Module["_flock"] = (a0, a1) => (_flock = Module["_flock"] = wasmExports["flock"])(a0, a1);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["wasm_popen"])(
    a0,
    a1
  );
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["wasm_php_exec"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["php_pollfd_for"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["__wrap_select"])(a0, a1, a2, a3, a4);
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["wasm_set_sapi_name"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["wasm_set_phpini_path"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wasm_add_cli_arg"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["run_cli"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wasm_add_SERVER_entry"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wasm_add_ENV_entry"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wasm_set_query_string"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["wasm_set_path_translated"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["wasm_set_skip_shebang"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["wasm_set_request_uri"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["wasm_set_request_method"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wasm_set_request_host"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wasm_set_content_type"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["wasm_set_request_body"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["wasm_set_content_length"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["wasm_set_cookies"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["wasm_set_request_port"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["wasm_sapi_request_shutdown"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["wasm_sapi_handle_request"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["php_wasm_init"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["wasm_free"])(a0);
  var _wasm_get_end_offset = Module["_wasm_get_end_offset"] = (a0) => (_wasm_get_end_offset = Module["_wasm_get_end_offset"] = wasmExports["wasm_get_end_offset"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["wasm_trace"])(
    a0,
    a1
  );
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["__funcs_on_exit"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
  var ___trap = () => (___trap = wasmExports["__trap"])();
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
    a0
  );
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["dynCall_vi"])(
    a0,
    a1
  );
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free === "function" ? _free : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking2 === "object" && locking2?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename8, dependenciesTotalSize8;
var init_php_7_2 = __esm({
  "packages/php-wasm/node/jspi/php_7_2.js"() {
    "use strict";
    dependencyFilename8 = path8.join(__dirname + "/jspi", "7_2_34", "php_7_2.wasm");
    dependenciesTotalSize8 = 17821497;
  }
});

// packages/php-wasm/node/asyncify/php_8_4.js
var php_8_4_exports2 = {};
__export(php_8_4_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize9,
  dependencyFilename: () => dependencyFilename9,
  init: () => init9
});
import path9 from "path";
function init9(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["kb"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename9);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["jb"];
      updateMemoryViews();
      wasmTable = wasmExports["lb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getdtablesize = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    o: ___assert_fail,
    /** @export */
    da: __asyncjs__js_module_onMessage,
    /** @export */
    ib: ___call_sighandler,
    /** @export */
    W: ___cxa_throw,
    /** @export */
    hb: ___syscall_accept4,
    /** @export */
    gb: ___syscall_bind,
    /** @export */
    fb: ___syscall_chdir,
    /** @export */
    V: ___syscall_chmod,
    /** @export */
    eb: ___syscall_connect,
    /** @export */
    db: ___syscall_dup,
    /** @export */
    cb: ___syscall_dup3,
    /** @export */
    bb: ___syscall_faccessat,
    /** @export */
    ab: ___syscall_fallocate,
    /** @export */
    $a: ___syscall_fchmod,
    /** @export */
    _a: ___syscall_fchown32,
    /** @export */
    U: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    Za: ___syscall_fdatasync,
    /** @export */
    Ya: ___syscall_fstat64,
    /** @export */
    Xa: ___syscall_ftruncate64,
    /** @export */
    Wa: ___syscall_getcwd,
    /** @export */
    Va: ___syscall_getdents64,
    /** @export */
    Ua: ___syscall_getpeername,
    /** @export */
    Ta: ___syscall_getsockname,
    /** @export */
    Sa: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Ra: ___syscall_listen,
    /** @export */
    Qa: ___syscall_lstat64,
    /** @export */
    Pa: ___syscall_mkdirat,
    /** @export */
    Oa: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Na: ___syscall_pipe,
    /** @export */
    Ma: ___syscall_poll,
    /** @export */
    La: ___syscall_readlinkat,
    /** @export */
    Ka: ___syscall_recvfrom,
    /** @export */
    Ja: ___syscall_renameat,
    /** @export */
    T: ___syscall_rmdir,
    /** @export */
    Ia: ___syscall_sendto,
    /** @export */
    S: ___syscall_socket,
    /** @export */
    Ha: ___syscall_stat64,
    /** @export */
    Ga: ___syscall_statfs64,
    /** @export */
    Fa: ___syscall_symlinkat,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    Ea: ___syscall_utimensat,
    /** @export */
    xa: __abort_js,
    /** @export */
    wa: __emscripten_lookup_name,
    /** @export */
    va: __emscripten_runtime_keepalive_clear,
    /** @export */
    ua: __emscripten_throw_longjmp,
    /** @export */
    ta: __gmtime_js,
    /** @export */
    sa: __localtime_js,
    /** @export */
    ra: __mktime_js,
    /** @export */
    qa: __mmap_js,
    /** @export */
    pa: __munmap_js,
    /** @export */
    P: __setitimer_js,
    /** @export */
    oa: __tzset_js,
    /** @export */
    Da: _clock_time_get,
    /** @export */
    O: _emscripten_date_now,
    /** @export */
    na: _emscripten_get_heap_max,
    /** @export */
    x: _emscripten_get_now,
    /** @export */
    ma: _emscripten_resize_heap,
    /** @export */
    N: _emscripten_sleep,
    /** @export */
    Ca: _environ_get,
    /** @export */
    Ba: _environ_sizes_get,
    /** @export */
    q: _exit,
    /** @export */
    r: _fd_close,
    /** @export */
    R: _fd_fdstat_get,
    /** @export */
    Q: _fd_read,
    /** @export */
    Aa: _fd_seek,
    /** @export */
    za: _fd_sync,
    /** @export */
    C: _fd_write,
    /** @export */
    M: _getaddrinfo,
    /** @export */
    la: _getcontext,
    /** @export */
    ka: _getdtablesize,
    /** @export */
    w: _getnameinfo,
    /** @export */
    ja: _getprotobyname,
    /** @export */
    ia: _getprotobynumber,
    /** @export */
    k: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    g: invoke_iiii,
    /** @export */
    h: invoke_iiiii,
    /** @export */
    m: invoke_iiiiii,
    /** @export */
    u: invoke_iiiiiii,
    /** @export */
    v: invoke_iiiiiiii,
    /** @export */
    L: invoke_iiiiiiiiii,
    /** @export */
    B: invoke_iij,
    /** @export */
    K: invoke_iiji,
    /** @export */
    ha: invoke_iijii,
    /** @export */
    ga: invoke_iijiji,
    /** @export */
    J: invoke_jii,
    /** @export */
    I: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    f: invoke_viii,
    /** @export */
    l: invoke_viiii,
    /** @export */
    j: invoke_viiiii,
    /** @export */
    fa: invoke_viiiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    i: invoke_viijii,
    /** @export */
    H: invoke_vji,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    ea: js_fd_read,
    /** @export */
    F: _js_open_process,
    /** @export */
    ca: js_popen_to_file,
    /** @export */
    ba: _js_process_status,
    /** @export */
    aa: _js_waitpid,
    /** @export */
    $: _js_wasm_trace,
    /** @export */
    _: _makecontext,
    /** @export */
    ya: _proc_exit,
    /** @export */
    Z: _strptime,
    /** @export */
    Y: _swapcontext,
    /** @export */
    s: _wasm_close,
    /** @export */
    t: wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt,
    /** @export */
    X: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["kb"])();
  var _free2 = (a0) => (_free2 = wasmExports["mb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["nb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["ob"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["pb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["qb"])(
    a0,
    a1,
    a2
  );
  var _htons = (a0) => (_htons = wasmExports["rb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["sb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["tb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["ub"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["vb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["wb"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["xb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["yb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["zb"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["Ab"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["Bb"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["Cb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Db"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Eb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Fb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Gb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Hb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Ib"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Jb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Kb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Lb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Mb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Nb"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Ob"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Pb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Qb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Rb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Sb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Tb"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Ub"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Vb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Wb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Xb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Yb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Zb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["_b"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["$b"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["ac"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["bc"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["cc"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["dc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["ec"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["fc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iij = Module["dynCall_iij"] = (a0, a1, a2) => (dynCall_iij = Module["dynCall_iij"] = wasmExports["ic"])(a0, a1, a2);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["jc"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["kc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["lc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["mc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["oc"])(a0, a1, a2);
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["pc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["qc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["rc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["sc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["tc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["uc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["vc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["wc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["xc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["yc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["zc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["Ac"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["Bc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["Cc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iij(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iij(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename9, dependenciesTotalSize9;
var init_php_8_42 = __esm({
  "packages/php-wasm/node/asyncify/php_8_4.js"() {
    "use strict";
    dependencyFilename9 = path9.join(__dirname + "/asyncify", "8_4_0", "php_8_4.wasm");
    dependenciesTotalSize9 = 21815449;
  }
});

// packages/php-wasm/node/asyncify/php_8_3.js
var php_8_3_exports2 = {};
__export(php_8_3_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize10,
  dependencyFilename: () => dependencyFilename10,
  init: () => init10
});
import path10 from "path";
function init10(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["lb"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename10);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["kb"];
      updateMemoryViews();
      wasmTable = wasmExports["mb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getdtablesize = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    ea: __asyncjs__js_module_onMessage,
    /** @export */
    jb: ___call_sighandler,
    /** @export */
    X: ___cxa_throw,
    /** @export */
    ib: ___syscall_accept4,
    /** @export */
    hb: ___syscall_bind,
    /** @export */
    gb: ___syscall_chdir,
    /** @export */
    W: ___syscall_chmod,
    /** @export */
    fb: ___syscall_connect,
    /** @export */
    eb: ___syscall_dup,
    /** @export */
    db: ___syscall_dup3,
    /** @export */
    cb: ___syscall_faccessat,
    /** @export */
    bb: ___syscall_fallocate,
    /** @export */
    ab: ___syscall_fchmod,
    /** @export */
    $a: ___syscall_fchown32,
    /** @export */
    V: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    _a: ___syscall_fdatasync,
    /** @export */
    Za: ___syscall_fstat64,
    /** @export */
    Ya: ___syscall_ftruncate64,
    /** @export */
    Xa: ___syscall_getcwd,
    /** @export */
    Wa: ___syscall_getdents64,
    /** @export */
    Va: ___syscall_getpeername,
    /** @export */
    Ua: ___syscall_getsockname,
    /** @export */
    Ta: ___syscall_getsockopt,
    /** @export */
    F: ___syscall_ioctl,
    /** @export */
    Sa: ___syscall_listen,
    /** @export */
    Ra: ___syscall_lstat64,
    /** @export */
    Qa: ___syscall_mkdirat,
    /** @export */
    Pa: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Oa: ___syscall_pipe,
    /** @export */
    Na: ___syscall_poll,
    /** @export */
    Ma: ___syscall_readlinkat,
    /** @export */
    La: ___syscall_recvfrom,
    /** @export */
    Ka: ___syscall_renameat,
    /** @export */
    U: ___syscall_rmdir,
    /** @export */
    Ja: ___syscall_sendto,
    /** @export */
    T: ___syscall_socket,
    /** @export */
    Ia: ___syscall_stat64,
    /** @export */
    Ha: ___syscall_statfs64,
    /** @export */
    Ga: ___syscall_symlinkat,
    /** @export */
    E: ___syscall_unlinkat,
    /** @export */
    Fa: ___syscall_utimensat,
    /** @export */
    ya: __abort_js,
    /** @export */
    xa: __emscripten_lookup_name,
    /** @export */
    wa: __emscripten_runtime_keepalive_clear,
    /** @export */
    va: __emscripten_throw_longjmp,
    /** @export */
    ua: __gmtime_js,
    /** @export */
    ta: __localtime_js,
    /** @export */
    sa: __mktime_js,
    /** @export */
    ra: __mmap_js,
    /** @export */
    qa: __munmap_js,
    /** @export */
    Q: __setitimer_js,
    /** @export */
    pa: __tzset_js,
    /** @export */
    Ea: _clock_time_get,
    /** @export */
    P: _emscripten_date_now,
    /** @export */
    oa: _emscripten_get_heap_max,
    /** @export */
    x: _emscripten_get_now,
    /** @export */
    na: _emscripten_resize_heap,
    /** @export */
    O: _emscripten_sleep,
    /** @export */
    Da: _environ_get,
    /** @export */
    Ca: _environ_sizes_get,
    /** @export */
    q: _exit,
    /** @export */
    r: _fd_close,
    /** @export */
    S: _fd_fdstat_get,
    /** @export */
    R: _fd_read,
    /** @export */
    Ba: _fd_seek,
    /** @export */
    Aa: _fd_sync,
    /** @export */
    D: _fd_write,
    /** @export */
    N: _getaddrinfo,
    /** @export */
    ma: _getcontext,
    /** @export */
    la: _getdtablesize,
    /** @export */
    w: _getnameinfo,
    /** @export */
    ka: _getprotobyname,
    /** @export */
    ja: _getprotobynumber,
    /** @export */
    k: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    g: invoke_iiii,
    /** @export */
    h: invoke_iiiii,
    /** @export */
    o: invoke_iiiiii,
    /** @export */
    u: invoke_iiiiiii,
    /** @export */
    v: invoke_iiiiiiii,
    /** @export */
    M: invoke_iiiiiiiiii,
    /** @export */
    C: invoke_iij,
    /** @export */
    L: invoke_iiji,
    /** @export */
    ia: invoke_iijii,
    /** @export */
    ha: invoke_iijiji,
    /** @export */
    K: invoke_jii,
    /** @export */
    J: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    B: invoke_viidii,
    /** @export */
    f: invoke_viii,
    /** @export */
    l: invoke_viiii,
    /** @export */
    j: invoke_viiiii,
    /** @export */
    A: invoke_viiiiii,
    /** @export */
    ga: invoke_viiiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    i: invoke_viijii,
    /** @export */
    I: invoke_vji,
    /** @export */
    H: _js_create_input_device,
    /** @export */
    fa: js_fd_read,
    /** @export */
    G: _js_open_process,
    /** @export */
    da: js_popen_to_file,
    /** @export */
    ca: _js_process_status,
    /** @export */
    ba: _js_waitpid,
    /** @export */
    aa: _js_wasm_trace,
    /** @export */
    $: _makecontext,
    /** @export */
    za: _proc_exit,
    /** @export */
    _: _strptime,
    /** @export */
    Z: _swapcontext,
    /** @export */
    s: _wasm_close,
    /** @export */
    t: wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt,
    /** @export */
    Y: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["lb"])();
  var _free2 = (a0) => (_free2 = wasmExports["nb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["ob"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["pb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["qb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["rb"])(
    a0,
    a1,
    a2
  );
  var _htons = (a0) => (_htons = wasmExports["sb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["tb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["ub"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["vb"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["wb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["xb"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["yb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["zb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["Ab"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["Bb"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["Cb"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["Db"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Eb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Fb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Gb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Hb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Ib"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Jb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Kb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Lb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Mb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Nb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Ob"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Pb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Qb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Rb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Sb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Tb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Ub"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Vb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Wb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Xb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Yb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Zb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_b"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["$b"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["ac"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["bc"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["cc"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["dc"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["ec"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["fc"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["ic"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iij = Module["dynCall_iij"] = (a0, a1, a2) => (dynCall_iij = Module["dynCall_iij"] = wasmExports["jc"])(a0, a1, a2);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["kc"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["lc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["mc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["oc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["pc"])(a0, a1, a2);
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["qc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["rc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["sc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["tc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["uc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["vc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["wc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["xc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["yc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["zc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["Ac"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["Bc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["Cc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["Dc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["Ec"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iij(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iij(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename10, dependenciesTotalSize10;
var init_php_8_32 = __esm({
  "packages/php-wasm/node/asyncify/php_8_3.js"() {
    "use strict";
    dependencyFilename10 = path10.join(__dirname + "/asyncify", "8_3_0", "php_8_3.wasm");
    dependenciesTotalSize10 = 18440346;
  }
});

// packages/php-wasm/node/asyncify/php_8_2.js
var php_8_2_exports2 = {};
__export(php_8_2_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize11,
  dependencyFilename: () => dependencyFilename11,
  init: () => init11
});
import path11 from "path";
function init11(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["lb"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename11);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["kb"];
      updateMemoryViews();
      wasmTable = wasmExports["mb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getdtablesize = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    ea: __asyncjs__js_module_onMessage,
    /** @export */
    jb: ___call_sighandler,
    /** @export */
    X: ___cxa_throw,
    /** @export */
    ib: ___syscall_accept4,
    /** @export */
    hb: ___syscall_bind,
    /** @export */
    gb: ___syscall_chdir,
    /** @export */
    W: ___syscall_chmod,
    /** @export */
    fb: ___syscall_connect,
    /** @export */
    eb: ___syscall_dup,
    /** @export */
    db: ___syscall_dup3,
    /** @export */
    cb: ___syscall_faccessat,
    /** @export */
    bb: ___syscall_fallocate,
    /** @export */
    ab: ___syscall_fchmod,
    /** @export */
    $a: ___syscall_fchown32,
    /** @export */
    V: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    _a: ___syscall_fdatasync,
    /** @export */
    Za: ___syscall_fstat64,
    /** @export */
    Ya: ___syscall_ftruncate64,
    /** @export */
    Xa: ___syscall_getcwd,
    /** @export */
    Wa: ___syscall_getdents64,
    /** @export */
    Va: ___syscall_getpeername,
    /** @export */
    Ua: ___syscall_getsockname,
    /** @export */
    Ta: ___syscall_getsockopt,
    /** @export */
    F: ___syscall_ioctl,
    /** @export */
    Sa: ___syscall_listen,
    /** @export */
    Ra: ___syscall_lstat64,
    /** @export */
    Qa: ___syscall_mkdirat,
    /** @export */
    Pa: ___syscall_newfstatat,
    /** @export */
    z: ___syscall_openat,
    /** @export */
    Oa: ___syscall_pipe,
    /** @export */
    Na: ___syscall_poll,
    /** @export */
    Ma: ___syscall_readlinkat,
    /** @export */
    La: ___syscall_recvfrom,
    /** @export */
    Ka: ___syscall_renameat,
    /** @export */
    U: ___syscall_rmdir,
    /** @export */
    Ja: ___syscall_sendto,
    /** @export */
    T: ___syscall_socket,
    /** @export */
    Ia: ___syscall_stat64,
    /** @export */
    Ha: ___syscall_statfs64,
    /** @export */
    Ga: ___syscall_symlinkat,
    /** @export */
    E: ___syscall_unlinkat,
    /** @export */
    Fa: ___syscall_utimensat,
    /** @export */
    ya: __abort_js,
    /** @export */
    xa: __emscripten_lookup_name,
    /** @export */
    wa: __emscripten_runtime_keepalive_clear,
    /** @export */
    va: __emscripten_throw_longjmp,
    /** @export */
    ua: __gmtime_js,
    /** @export */
    ta: __localtime_js,
    /** @export */
    sa: __mktime_js,
    /** @export */
    ra: __mmap_js,
    /** @export */
    qa: __munmap_js,
    /** @export */
    Q: __setitimer_js,
    /** @export */
    pa: __tzset_js,
    /** @export */
    Ea: _clock_time_get,
    /** @export */
    P: _emscripten_date_now,
    /** @export */
    oa: _emscripten_get_heap_max,
    /** @export */
    y: _emscripten_get_now,
    /** @export */
    na: _emscripten_resize_heap,
    /** @export */
    O: _emscripten_sleep,
    /** @export */
    Da: _environ_get,
    /** @export */
    Ca: _environ_sizes_get,
    /** @export */
    q: _exit,
    /** @export */
    r: _fd_close,
    /** @export */
    S: _fd_fdstat_get,
    /** @export */
    R: _fd_read,
    /** @export */
    Ba: _fd_seek,
    /** @export */
    Aa: _fd_sync,
    /** @export */
    D: _fd_write,
    /** @export */
    N: _getaddrinfo,
    /** @export */
    ma: _getcontext,
    /** @export */
    la: _getdtablesize,
    /** @export */
    x: _getnameinfo,
    /** @export */
    ka: _getprotobyname,
    /** @export */
    ja: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    g: invoke_iiii,
    /** @export */
    h: invoke_iiiii,
    /** @export */
    p: invoke_iiiiii,
    /** @export */
    u: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    M: invoke_iiiiiiiiii,
    /** @export */
    C: invoke_iij,
    /** @export */
    L: invoke_iiji,
    /** @export */
    ia: invoke_iijii,
    /** @export */
    ha: invoke_iijiji,
    /** @export */
    K: invoke_jii,
    /** @export */
    J: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    B: invoke_viidii,
    /** @export */
    f: invoke_viii,
    /** @export */
    j: invoke_viiii,
    /** @export */
    t: invoke_viiiii,
    /** @export */
    k: invoke_viiiiii,
    /** @export */
    ga: invoke_viiiiiii,
    /** @export */
    A: invoke_viiiiiiiii,
    /** @export */
    o: invoke_viijii,
    /** @export */
    I: invoke_vji,
    /** @export */
    H: _js_create_input_device,
    /** @export */
    fa: js_fd_read,
    /** @export */
    G: _js_open_process,
    /** @export */
    da: js_popen_to_file,
    /** @export */
    ca: _js_process_status,
    /** @export */
    ba: _js_waitpid,
    /** @export */
    aa: _js_wasm_trace,
    /** @export */
    $: _makecontext,
    /** @export */
    za: _proc_exit,
    /** @export */
    _: _strptime,
    /** @export */
    Z: _swapcontext,
    /** @export */
    s: _wasm_close,
    /** @export */
    v: wasm_poll_socket,
    /** @export */
    n: _wasm_setsockopt,
    /** @export */
    Y: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["lb"])();
  var _free2 = (a0) => (_free2 = wasmExports["nb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["ob"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["pb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["qb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["rb"])(
    a0,
    a1,
    a2
  );
  var _htons = (a0) => (_htons = wasmExports["sb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["tb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["ub"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["vb"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["wb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["xb"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["yb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["zb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["Ab"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["Bb"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["Cb"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["Db"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Eb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Fb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Gb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Hb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Ib"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Jb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Kb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Lb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Mb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Nb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Ob"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Pb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Qb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Rb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Sb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Tb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Ub"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Vb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Wb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Xb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Yb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Zb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_b"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["$b"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["ac"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["bc"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["cc"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["dc"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["ec"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["fc"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["ic"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iij = Module["dynCall_iij"] = (a0, a1, a2) => (dynCall_iij = Module["dynCall_iij"] = wasmExports["jc"])(a0, a1, a2);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["kc"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["lc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["mc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["oc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["pc"])(a0, a1, a2);
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["qc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["rc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["sc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["tc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["uc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["vc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["wc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["xc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["yc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["zc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["Ac"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["Bc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["Cc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["Dc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["Ec"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iij(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iij(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename11, dependenciesTotalSize11;
var init_php_8_22 = __esm({
  "packages/php-wasm/node/asyncify/php_8_2.js"() {
    "use strict";
    dependencyFilename11 = path11.join(__dirname + "/asyncify", "8_2_10", "php_8_2.wasm");
    dependenciesTotalSize11 = 18041661;
  }
});

// packages/php-wasm/node/asyncify/php_8_1.js
var php_8_1_exports2 = {};
__export(php_8_1_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize12,
  dependencyFilename: () => dependencyFilename12,
  init: () => init12
});
import path12 from "path";
function init12(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["kb"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename12);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["jb"];
      updateMemoryViews();
      wasmTable = wasmExports["lb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getcontext = () => abort("missing function: ${name}");
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var _makecontext = () => abort("missing function: ${name}");
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  var _swapcontext = () => abort("missing function: ${name}");
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    ea: __asyncjs__js_module_onMessage,
    /** @export */
    ib: ___call_sighandler,
    /** @export */
    X: ___cxa_throw,
    /** @export */
    hb: ___syscall_accept4,
    /** @export */
    gb: ___syscall_bind,
    /** @export */
    fb: ___syscall_chdir,
    /** @export */
    W: ___syscall_chmod,
    /** @export */
    eb: ___syscall_connect,
    /** @export */
    db: ___syscall_dup,
    /** @export */
    cb: ___syscall_dup3,
    /** @export */
    bb: ___syscall_faccessat,
    /** @export */
    ab: ___syscall_fallocate,
    /** @export */
    $a: ___syscall_fchmod,
    /** @export */
    _a: ___syscall_fchown32,
    /** @export */
    V: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    Za: ___syscall_fdatasync,
    /** @export */
    Ya: ___syscall_fstat64,
    /** @export */
    Xa: ___syscall_ftruncate64,
    /** @export */
    Wa: ___syscall_getcwd,
    /** @export */
    Va: ___syscall_getdents64,
    /** @export */
    Ua: ___syscall_getpeername,
    /** @export */
    Ta: ___syscall_getsockname,
    /** @export */
    Sa: ___syscall_getsockopt,
    /** @export */
    F: ___syscall_ioctl,
    /** @export */
    Ra: ___syscall_listen,
    /** @export */
    Qa: ___syscall_lstat64,
    /** @export */
    Pa: ___syscall_mkdirat,
    /** @export */
    Oa: ___syscall_newfstatat,
    /** @export */
    z: ___syscall_openat,
    /** @export */
    Na: ___syscall_pipe,
    /** @export */
    Ma: ___syscall_poll,
    /** @export */
    La: ___syscall_readlinkat,
    /** @export */
    Ka: ___syscall_recvfrom,
    /** @export */
    Ja: ___syscall_renameat,
    /** @export */
    U: ___syscall_rmdir,
    /** @export */
    Ia: ___syscall_sendto,
    /** @export */
    T: ___syscall_socket,
    /** @export */
    Ha: ___syscall_stat64,
    /** @export */
    Ga: ___syscall_statfs64,
    /** @export */
    Fa: ___syscall_symlinkat,
    /** @export */
    E: ___syscall_unlinkat,
    /** @export */
    Ea: ___syscall_utimensat,
    /** @export */
    xa: __abort_js,
    /** @export */
    wa: __emscripten_lookup_name,
    /** @export */
    va: __emscripten_runtime_keepalive_clear,
    /** @export */
    ua: __emscripten_throw_longjmp,
    /** @export */
    ta: __gmtime_js,
    /** @export */
    sa: __localtime_js,
    /** @export */
    ra: __mktime_js,
    /** @export */
    qa: __mmap_js,
    /** @export */
    pa: __munmap_js,
    /** @export */
    Q: __setitimer_js,
    /** @export */
    oa: __tzset_js,
    /** @export */
    Da: _clock_time_get,
    /** @export */
    P: _emscripten_date_now,
    /** @export */
    na: _emscripten_get_heap_max,
    /** @export */
    y: _emscripten_get_now,
    /** @export */
    ma: _emscripten_resize_heap,
    /** @export */
    O: _emscripten_sleep,
    /** @export */
    Ca: _environ_get,
    /** @export */
    Ba: _environ_sizes_get,
    /** @export */
    q: _exit,
    /** @export */
    r: _fd_close,
    /** @export */
    S: _fd_fdstat_get,
    /** @export */
    R: _fd_read,
    /** @export */
    Aa: _fd_seek,
    /** @export */
    za: _fd_sync,
    /** @export */
    D: _fd_write,
    /** @export */
    N: _getaddrinfo,
    /** @export */
    la: _getcontext,
    /** @export */
    x: _getnameinfo,
    /** @export */
    ka: _getprotobyname,
    /** @export */
    ja: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    g: invoke_iiii,
    /** @export */
    h: invoke_iiiii,
    /** @export */
    p: invoke_iiiiii,
    /** @export */
    s: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    M: invoke_iiiiiiiiii,
    /** @export */
    C: invoke_iij,
    /** @export */
    L: invoke_iiji,
    /** @export */
    ia: invoke_iijii,
    /** @export */
    ha: invoke_iijiji,
    /** @export */
    K: invoke_jii,
    /** @export */
    J: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    B: invoke_viidii,
    /** @export */
    f: invoke_viii,
    /** @export */
    j: invoke_viiii,
    /** @export */
    u: invoke_viiiii,
    /** @export */
    k: invoke_viiiiii,
    /** @export */
    ga: invoke_viiiiiii,
    /** @export */
    A: invoke_viiiiiiiii,
    /** @export */
    n: invoke_viijii,
    /** @export */
    I: invoke_vji,
    /** @export */
    H: _js_create_input_device,
    /** @export */
    fa: js_fd_read,
    /** @export */
    G: _js_open_process,
    /** @export */
    da: js_popen_to_file,
    /** @export */
    ca: _js_process_status,
    /** @export */
    ba: _js_waitpid,
    /** @export */
    aa: _js_wasm_trace,
    /** @export */
    $: _makecontext,
    /** @export */
    ya: _proc_exit,
    /** @export */
    _: _strptime,
    /** @export */
    Z: _swapcontext,
    /** @export */
    t: _wasm_close,
    /** @export */
    v: wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt,
    /** @export */
    Y: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["kb"])();
  var _free2 = (a0) => (_free2 = wasmExports["mb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["nb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["ob"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["pb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["qb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["rb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["sb"])(
    a0,
    a1,
    a2
  );
  var _htons = (a0) => (_htons = wasmExports["tb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ub"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["vb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["wb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["xb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["yb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["zb"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["Ab"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["Bb"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["Cb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Db"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Eb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Fb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Gb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Hb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Ib"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Jb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Kb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Lb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Mb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Nb"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Ob"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Pb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Qb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Rb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Sb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Tb"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Ub"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Vb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Wb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Xb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Yb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Zb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["_b"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["$b"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["ac"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["bc"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["cc"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["dc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["ec"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["fc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iij = Module["dynCall_iij"] = (a0, a1, a2) => (dynCall_iij = Module["dynCall_iij"] = wasmExports["ic"])(a0, a1, a2);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["jc"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["kc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["lc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["mc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["oc"])(a0, a1, a2);
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["pc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["qc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["rc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["sc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["tc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["uc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["vc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["wc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["xc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["yc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["zc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["Ac"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["Bc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["Cc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["Dc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iij(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iij(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename12, dependenciesTotalSize12;
var init_php_8_12 = __esm({
  "packages/php-wasm/node/asyncify/php_8_1.js"() {
    "use strict";
    dependencyFilename12 = path12.join(__dirname + "/asyncify", "8_1_23", "php_8_1.wasm");
    dependenciesTotalSize12 = 17686407;
  }
});

// packages/php-wasm/node/asyncify/php_8_0.js
var php_8_0_exports2 = {};
__export(php_8_0_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize13,
  dependencyFilename: () => dependencyFilename13,
  init: () => init13
});
import path13 from "path";
function init13(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["gb"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename13);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["fb"];
      updateMemoryViews();
      wasmTable = wasmExports["hb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    $: __asyncjs__js_module_onMessage,
    /** @export */
    eb: ___call_sighandler,
    /** @export */
    U: ___cxa_throw,
    /** @export */
    db: ___syscall_accept4,
    /** @export */
    cb: ___syscall_bind,
    /** @export */
    bb: ___syscall_chdir,
    /** @export */
    T: ___syscall_chmod,
    /** @export */
    ab: ___syscall_connect,
    /** @export */
    $a: ___syscall_dup,
    /** @export */
    _a: ___syscall_dup3,
    /** @export */
    Za: ___syscall_faccessat,
    /** @export */
    Ya: ___syscall_fallocate,
    /** @export */
    Xa: ___syscall_fchmod,
    /** @export */
    Wa: ___syscall_fchown32,
    /** @export */
    S: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    Va: ___syscall_fdatasync,
    /** @export */
    Ua: ___syscall_fstat64,
    /** @export */
    Ta: ___syscall_ftruncate64,
    /** @export */
    Sa: ___syscall_getcwd,
    /** @export */
    Ra: ___syscall_getdents64,
    /** @export */
    Qa: ___syscall_getpeername,
    /** @export */
    Pa: ___syscall_getsockname,
    /** @export */
    Oa: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Na: ___syscall_listen,
    /** @export */
    Ma: ___syscall_lstat64,
    /** @export */
    La: ___syscall_mkdirat,
    /** @export */
    Ka: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Ja: ___syscall_pipe,
    /** @export */
    Ia: ___syscall_poll,
    /** @export */
    Ha: ___syscall_readlinkat,
    /** @export */
    Ga: ___syscall_recvfrom,
    /** @export */
    Fa: ___syscall_renameat,
    /** @export */
    R: ___syscall_rmdir,
    /** @export */
    Ea: ___syscall_sendto,
    /** @export */
    Q: ___syscall_socket,
    /** @export */
    Da: ___syscall_stat64,
    /** @export */
    Ca: ___syscall_statfs64,
    /** @export */
    Ba: ___syscall_symlinkat,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    Aa: ___syscall_utimensat,
    /** @export */
    ua: __abort_js,
    /** @export */
    ta: __emscripten_lookup_name,
    /** @export */
    sa: __emscripten_runtime_keepalive_clear,
    /** @export */
    ra: __emscripten_throw_longjmp,
    /** @export */
    qa: __gmtime_js,
    /** @export */
    pa: __localtime_js,
    /** @export */
    oa: __mktime_js,
    /** @export */
    na: __mmap_js,
    /** @export */
    ma: __munmap_js,
    /** @export */
    N: __setitimer_js,
    /** @export */
    la: __tzset_js,
    /** @export */
    za: _clock_time_get,
    /** @export */
    M: _emscripten_date_now,
    /** @export */
    ka: _emscripten_get_heap_max,
    /** @export */
    x: _emscripten_get_now,
    /** @export */
    ja: _emscripten_resize_heap,
    /** @export */
    L: _emscripten_sleep,
    /** @export */
    ya: _environ_get,
    /** @export */
    xa: _environ_sizes_get,
    /** @export */
    p: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    P: _fd_fdstat_get,
    /** @export */
    O: _fd_read,
    /** @export */
    wa: _fd_seek,
    /** @export */
    C: _fd_write,
    /** @export */
    K: _getaddrinfo,
    /** @export */
    B: _getnameinfo,
    /** @export */
    ia: _getprotobyname,
    /** @export */
    ha: _getprotobynumber,
    /** @export */
    k: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    t: invoke_iiiiii,
    /** @export */
    s: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    J: invoke_iiiiiiiiii,
    /** @export */
    I: invoke_iiji,
    /** @export */
    ga: invoke_iijii,
    /** @export */
    fa: invoke_iijiji,
    /** @export */
    ea: invoke_ji,
    /** @export */
    da: invoke_jii,
    /** @export */
    ca: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    i: invoke_viiii,
    /** @export */
    v: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    ba: invoke_viiiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    n: invoke_viijii,
    /** @export */
    H: invoke_vji,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    aa: js_fd_read,
    /** @export */
    F: _js_open_process,
    /** @export */
    _: js_popen_to_file,
    /** @export */
    Z: _js_process_status,
    /** @export */
    Y: _js_waitpid,
    /** @export */
    X: _js_wasm_trace,
    /** @export */
    va: _proc_exit,
    /** @export */
    W: _strptime,
    /** @export */
    r: _wasm_close,
    /** @export */
    u: wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt,
    /** @export */
    V: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["gb"])();
  var _free2 = (a0) => (_free2 = wasmExports["ib"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["jb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["kb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["lb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["mb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["nb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["ob"])(
    a0,
    a1,
    a2
  );
  var _htons = (a0) => (_htons = wasmExports["pb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["qb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["rb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["sb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["tb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["ub"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["vb"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wb"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["xb"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["yb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["zb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Ab"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Bb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Cb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Db"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Eb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Fb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Gb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Hb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Ib"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Jb"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Kb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Lb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Mb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Nb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Ob"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Pb"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Qb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Rb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Sb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Tb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Ub"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Vb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Wb"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Xb"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Yb"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Zb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["_b"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["$b"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["ac"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["bc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["cc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["dc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["ec"])(a0);
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["fc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_ji = Module["dynCall_ji"] = (a0, a1) => (dynCall_ji = Module["dynCall_ji"] = wasmExports["ic"])(a0, a1);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["jc"])(a0);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["kc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["lc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["mc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["oc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["pc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["qc"])(a0, a1, a2);
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["rc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["sc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["tc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["uc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["vc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["wc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["xc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["yc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["zc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ji(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ji(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename13, dependenciesTotalSize13;
var init_php_8_02 = __esm({
  "packages/php-wasm/node/asyncify/php_8_0.js"() {
    "use strict";
    dependencyFilename13 = path13.join(__dirname + "/asyncify", "8_0_30", "php_8_0.wasm");
    dependenciesTotalSize13 = 17684220;
  }
});

// packages/php-wasm/node/asyncify/php_7_4.js
var php_7_4_exports2 = {};
__export(php_7_4_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize14,
  dependencyFilename: () => dependencyFilename14,
  init: () => init14
});
import path14 from "path";
function init14(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["eb"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename14);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["db"];
      updateMemoryViews();
      wasmTable = wasmExports["fb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    $: __asyncjs__js_module_onMessage,
    /** @export */
    cb: ___call_sighandler,
    /** @export */
    U: ___cxa_throw,
    /** @export */
    bb: ___syscall_accept4,
    /** @export */
    ab: ___syscall_bind,
    /** @export */
    $a: ___syscall_chdir,
    /** @export */
    T: ___syscall_chmod,
    /** @export */
    _a: ___syscall_connect,
    /** @export */
    Za: ___syscall_dup,
    /** @export */
    Ya: ___syscall_dup3,
    /** @export */
    Xa: ___syscall_faccessat,
    /** @export */
    Wa: ___syscall_fallocate,
    /** @export */
    Va: ___syscall_fchmod,
    /** @export */
    Ua: ___syscall_fchown32,
    /** @export */
    S: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    Ta: ___syscall_fdatasync,
    /** @export */
    Sa: ___syscall_fstat64,
    /** @export */
    Ra: ___syscall_ftruncate64,
    /** @export */
    Qa: ___syscall_getcwd,
    /** @export */
    Pa: ___syscall_getdents64,
    /** @export */
    Oa: ___syscall_getpeername,
    /** @export */
    Na: ___syscall_getsockname,
    /** @export */
    Ma: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    La: ___syscall_listen,
    /** @export */
    Ka: ___syscall_lstat64,
    /** @export */
    Ja: ___syscall_mkdirat,
    /** @export */
    Ia: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Ha: ___syscall_pipe,
    /** @export */
    Ga: ___syscall_poll,
    /** @export */
    Fa: ___syscall_readlinkat,
    /** @export */
    Ea: ___syscall_recvfrom,
    /** @export */
    Da: ___syscall_renameat,
    /** @export */
    R: ___syscall_rmdir,
    /** @export */
    Ca: ___syscall_sendto,
    /** @export */
    Q: ___syscall_socket,
    /** @export */
    Ba: ___syscall_stat64,
    /** @export */
    Aa: ___syscall_statfs64,
    /** @export */
    za: ___syscall_symlinkat,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    ya: ___syscall_utimensat,
    /** @export */
    sa: __abort_js,
    /** @export */
    ra: __emscripten_lookup_name,
    /** @export */
    qa: __emscripten_runtime_keepalive_clear,
    /** @export */
    pa: __emscripten_throw_longjmp,
    /** @export */
    oa: __gmtime_js,
    /** @export */
    na: __localtime_js,
    /** @export */
    ma: __mktime_js,
    /** @export */
    la: __mmap_js,
    /** @export */
    ka: __munmap_js,
    /** @export */
    N: __setitimer_js,
    /** @export */
    ja: __tzset_js,
    /** @export */
    xa: _clock_time_get,
    /** @export */
    M: _emscripten_date_now,
    /** @export */
    ia: _emscripten_get_heap_max,
    /** @export */
    x: _emscripten_get_now,
    /** @export */
    ha: _emscripten_resize_heap,
    /** @export */
    L: _emscripten_sleep,
    /** @export */
    wa: _environ_get,
    /** @export */
    va: _environ_sizes_get,
    /** @export */
    p: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    P: _fd_fdstat_get,
    /** @export */
    O: _fd_read,
    /** @export */
    ua: _fd_seek,
    /** @export */
    C: _fd_write,
    /** @export */
    K: _getaddrinfo,
    /** @export */
    B: _getnameinfo,
    /** @export */
    ga: _getprotobyname,
    /** @export */
    fa: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    s: invoke_iiiiii,
    /** @export */
    u: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    J: invoke_iiiiiiiiii,
    /** @export */
    I: invoke_iiji,
    /** @export */
    ea: invoke_iijii,
    /** @export */
    da: invoke_iijiji,
    /** @export */
    ca: invoke_jii,
    /** @export */
    ba: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    k: invoke_viiii,
    /** @export */
    v: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    n: invoke_viijii,
    /** @export */
    H: invoke_vji,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    aa: js_fd_read,
    /** @export */
    F: _js_open_process,
    /** @export */
    _: js_popen_to_file,
    /** @export */
    Z: _js_process_status,
    /** @export */
    Y: _js_waitpid,
    /** @export */
    X: _js_wasm_trace,
    /** @export */
    ta: _proc_exit,
    /** @export */
    W: _strptime,
    /** @export */
    r: _wasm_close,
    /** @export */
    t: wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt,
    /** @export */
    V: _wasm_shutdown
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["eb"])();
  var _free2 = (a0) => (_free2 = wasmExports["gb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["hb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["ib"])(a0, a1, a2);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["jb"])(
    a0,
    a1,
    a2
  );
  var _fflush = (a0) => (_fflush = wasmExports["kb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["lb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["mb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _htons = (a0) => (_htons = wasmExports["nb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ob"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["pb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["qb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["rb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["sb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["tb"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["ub"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["vb"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["wb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["xb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["yb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["zb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Bb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Cb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Db"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Eb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Fb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Gb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Hb"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Ib"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Jb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Kb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Lb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Mb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Nb"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Ob"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Pb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Qb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Rb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Sb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Tb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Ub"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Vb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Wb"])(a0, a1, a2);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["Xb"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Yb"])(a0, a1);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Zb"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["_b"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["$b"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["ac"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["bc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["cc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["dc"])(a0);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["ec"])(a0);
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["fc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["ic"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["jc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["kc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["lc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["mc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["nc"])(a0, a1, a2);
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["oc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["pc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["qc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["rc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["sc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["tc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["uc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["vc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename14, dependenciesTotalSize14;
var init_php_7_42 = __esm({
  "packages/php-wasm/node/asyncify/php_7_4.js"() {
    "use strict";
    dependencyFilename14 = path14.join(__dirname + "/asyncify", "7_4_33", "php_7_4.wasm");
    dependenciesTotalSize14 = 19027659;
  }
});

// packages/php-wasm/node/asyncify/php_7_3.js
var php_7_3_exports2 = {};
__export(php_7_3_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize15,
  dependencyFilename: () => dependencyFilename15,
  init: () => init15
});
import path15 from "path";
function init15(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["db"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename15);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["cb"];
      updateMemoryViews();
      wasmTable = wasmExports["eb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    Z: __asyncjs__js_module_onMessage,
    /** @export */
    bb: ___call_sighandler,
    /** @export */
    T: ___cxa_throw,
    /** @export */
    ab: ___syscall_accept4,
    /** @export */
    $a: ___syscall_bind,
    /** @export */
    _a: ___syscall_chdir,
    /** @export */
    S: ___syscall_chmod,
    /** @export */
    Za: ___syscall_connect,
    /** @export */
    Ya: ___syscall_dup,
    /** @export */
    Xa: ___syscall_dup3,
    /** @export */
    Wa: ___syscall_faccessat,
    /** @export */
    Va: ___syscall_fallocate,
    /** @export */
    Ua: ___syscall_fchmod,
    /** @export */
    Ta: ___syscall_fchown32,
    /** @export */
    R: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    Sa: ___syscall_fdatasync,
    /** @export */
    Ra: ___syscall_fstat64,
    /** @export */
    Qa: ___syscall_ftruncate64,
    /** @export */
    Pa: ___syscall_getcwd,
    /** @export */
    Oa: ___syscall_getdents64,
    /** @export */
    Na: ___syscall_getpeername,
    /** @export */
    Ma: ___syscall_getsockname,
    /** @export */
    La: ___syscall_getsockopt,
    /** @export */
    F: ___syscall_ioctl,
    /** @export */
    Ka: ___syscall_listen,
    /** @export */
    Ja: ___syscall_lstat64,
    /** @export */
    Ia: ___syscall_mkdirat,
    /** @export */
    Ha: ___syscall_newfstatat,
    /** @export */
    x: ___syscall_openat,
    /** @export */
    Ga: ___syscall_pipe,
    /** @export */
    Fa: ___syscall_poll,
    /** @export */
    Ea: ___syscall_readlinkat,
    /** @export */
    Da: ___syscall_recvfrom,
    /** @export */
    Ca: ___syscall_renameat,
    /** @export */
    Q: ___syscall_rmdir,
    /** @export */
    Ba: ___syscall_sendto,
    /** @export */
    P: ___syscall_socket,
    /** @export */
    Aa: ___syscall_stat64,
    /** @export */
    za: ___syscall_statfs64,
    /** @export */
    ya: ___syscall_symlinkat,
    /** @export */
    E: ___syscall_unlinkat,
    /** @export */
    xa: ___syscall_utimensat,
    /** @export */
    ra: __abort_js,
    /** @export */
    qa: __emscripten_lookup_name,
    /** @export */
    pa: __emscripten_runtime_keepalive_clear,
    /** @export */
    oa: __emscripten_throw_longjmp,
    /** @export */
    na: __gmtime_js,
    /** @export */
    ma: __localtime_js,
    /** @export */
    la: __mktime_js,
    /** @export */
    ka: __mmap_js,
    /** @export */
    ja: __munmap_js,
    /** @export */
    M: __setitimer_js,
    /** @export */
    ia: __tzset_js,
    /** @export */
    wa: _clock_time_get,
    /** @export */
    L: _emscripten_date_now,
    /** @export */
    ha: _emscripten_get_heap_max,
    /** @export */
    w: _emscripten_get_now,
    /** @export */
    ga: _emscripten_resize_heap,
    /** @export */
    K: _emscripten_sleep,
    /** @export */
    va: _environ_get,
    /** @export */
    ua: _environ_sizes_get,
    /** @export */
    p: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    O: _fd_fdstat_get,
    /** @export */
    N: _fd_read,
    /** @export */
    ta: _fd_seek,
    /** @export */
    D: _fd_write,
    /** @export */
    J: _getaddrinfo,
    /** @export */
    C: _getnameinfo,
    /** @export */
    fa: _getprotobyname,
    /** @export */
    ea: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    s: invoke_iiiiii,
    /** @export */
    u: invoke_iiiiiii,
    /** @export */
    v: invoke_iiiiiiii,
    /** @export */
    B: invoke_iiiiiiiiii,
    /** @export */
    da: invoke_iiji,
    /** @export */
    ca: invoke_iijii,
    /** @export */
    ba: invoke_iijiji,
    /** @export */
    aa: invoke_jii,
    /** @export */
    $: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    k: invoke_viiii,
    /** @export */
    z: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    y: invoke_viiiiiiiii,
    /** @export */
    n: invoke_viijii,
    /** @export */
    I: invoke_vji,
    /** @export */
    H: _js_create_input_device,
    /** @export */
    _: js_fd_read,
    /** @export */
    G: _js_open_process,
    /** @export */
    Y: js_popen_to_file,
    /** @export */
    X: _js_process_status,
    /** @export */
    W: _js_waitpid,
    /** @export */
    V: _js_wasm_trace,
    /** @export */
    sa: _proc_exit,
    /** @export */
    U: _strptime,
    /** @export */
    r: _wasm_close,
    /** @export */
    t: wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["db"])();
  var _malloc = (a0) => (_malloc = wasmExports["fb"])(a0);
  var _free2 = (a0) => (_free2 = wasmExports["gb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["hb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["ib"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["jb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["kb"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["lb"])(
    a0,
    a1,
    a2
  );
  var _htons = (a0) => (_htons = wasmExports["mb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["nb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["ob"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["pb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["qb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["rb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["sb"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["tb"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["ub"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["vb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["xb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["yb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["zb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Bb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Cb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Db"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Eb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Fb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Gb"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Hb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Ib"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Jb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Kb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Lb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Mb"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Nb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Ob"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Pb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Qb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Rb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Sb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Tb"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Ub"])(a0, a1);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Vb"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Wb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Xb"])(a0, a1, a2);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Yb"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Zb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["_b"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["$b"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["ac"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["bc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["cc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["dc"])(a0);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["ec"])(a0);
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["fc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["ic"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["jc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["kc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["lc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["mc"])(a0, a1, a2);
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["oc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["pc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["qc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["rc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["sc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["tc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["uc"])();
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename15, dependenciesTotalSize15;
var init_php_7_32 = __esm({
  "packages/php-wasm/node/asyncify/php_7_3.js"() {
    "use strict";
    dependencyFilename15 = path15.join(__dirname + "/asyncify", "7_3_33", "php_7_3.wasm");
    dependenciesTotalSize15 = 18511097;
  }
});

// packages/php-wasm/node/asyncify/php_7_2.js
var php_7_2_exports2 = {};
__export(php_7_2_exports2, {
  dependenciesTotalSize: () => dependenciesTotalSize16,
  dependencyFilename: () => dependencyFilename16,
  init: () => init16
});
import path16 from "path";
function init16(RuntimeName, PHPLoader) {
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = {
    ...Module
  };
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path17) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path17, scriptDirectory);
    }
    return scriptDirectory + path17;
  }
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs3 = __require("fs");
    var nodePath = __require("path");
    scriptDirectory = __dirname + "/asyncify/";
    readBinary = (filename) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename);
      return ret;
    };
    readAsync = async (filename, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : filename;
      var ret = fs3.readFileSync(filename, binary ? void 0 : "utf8");
      return ret;
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
  var runtimeInitialized = false;
  var runtimeExited = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
    Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.initialized)
      FS.init();
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    wasmExports["db"]();
    FS.ignorePermissions = false;
  }
  function exitRuntime() {
    ___funcs_on_exit();
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(
      what
    );
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return locateFile(dependencyFilename16);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    if (!wasmBinary) {
      try {
        var response = await readAsync(binaryFile);
        return new Uint8Array(response);
      } catch {
      }
    }
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !ENVIRONMENT_IS_NODE) {
      try {
        var response = fetch(binaryFile, {
          credentials: "same-origin"
        });
        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
        return instantiationResult;
      } catch (reason) {
        err(`wasm streaming compile failed: ${reason}`);
        err("falling back to ArrayBuffer instantiation");
      }
    }
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return {
      a: wasmImports
    };
  }
  async function createWasm() {
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["cb"];
      updateMemoryViews();
      wasmTable = wasmExports["eb"];
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(
          55296 | ch >> 10,
          56320 | ch & 1023
        );
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => abort(
    `Assertion failed: ${UTF8ToString(condition)}, at: ` + [
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]
  );
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  class ExceptionInfo {
    // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    // Initialize native structure fields. Should be called once after allocated.
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var initRandomFill = () => (view) => crypto.getRandomValues(view);
  var randomFill = (view) => {
    (randomFill = initRandomFill())(view);
  };
  var PATH = {
    isAbs: (path17) => path17.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path17) => {
      var isAbsolute = PATH.isAbs(path17), trailingSlash = path17.slice(-1) === "/";
      path17 = PATH.normalizeArray(
        path17.split("/").filter((p) => !!p),
        !isAbsolute
      ).join("/");
      if (!path17 && !isAbsolute) {
        path17 = ".";
      }
      if (path17 && trailingSlash) {
        path17 += "/";
      }
      return (isAbsolute ? "/" : "") + path17;
    },
    dirname: (path17) => {
      var result = PATH.splitPath(path17), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, -1);
      }
      return root + dir;
    },
    basename: (path17) => path17 && path17.match(/([^\/]+|\/)\/*$/)[1],
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path17 = i >= 0 ? args[i] : FS.cwd();
        if (typeof path17 != "string") {
          throw new TypeError(
            "Arguments to path.resolve must be strings"
          );
        } else if (!path17) {
          return "";
        }
        resolvedPath = path17 + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path17);
      }
      resolvedPath = PATH.normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).slice(1);
      to = PATH_FS.resolve(to).slice(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var intArrayFromString = (stringy, dontAddNull, length) => {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(
      stringy,
      u8array,
      0,
      u8array.length
    );
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  };
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs3.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [
            3,
            28,
            127,
            21,
            4,
            0,
            1,
            0,
            17,
            19,
            26,
            0,
            18,
            15,
            23,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output?.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (ptr)
      zeroMemory(ptr, size);
    return ptr;
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16895, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.atime = node.mtime = node.ctime = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.atime = parent.mtime = parent.ctime = node.atime;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(
        newCapacity,
        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
      );
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(
            oldContents.subarray(
              0,
              Math.min(newSize, node.usedBytes)
            )
          );
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.atime);
        attr.mtime = new Date(node.mtime);
        attr.ctime = new Date(node.ctime);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        for (const key of ["mode", "atime", "mtime", "ctime"]) {
          if (attr[key] != null) {
            node[key] = attr[key];
          }
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          if (FS.isDir(old_node.mode)) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
          FS.hashRemoveNode(new_node);
        }
        delete old_node.parent.contents[old_node.name];
        new_dir.contents[new_name] = old_node;
        old_node.name = new_name;
        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.ctime = parent.mtime = Date.now();
      },
      readdir(node) {
        return [".", "..", ...Object.keys(node.contents)];
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(
            contents.subarray(position, position + size),
            offset
          );
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.mtime = node.ctime = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(
              offset,
              offset + length
            );
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(
            buffer.subarray(offset, offset + length),
            position
          );
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(
                  position,
                  position + length
                );
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var asyncLoad = async (url) => {
    var arrayBuffer = await readAsync(url);
    return new Uint8Array(arrayBuffer);
  };
  asyncLoad.isAsync = true;
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(
            parent,
            name,
            byteArray2,
            canRead,
            canWrite,
            canOwn
          );
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url).then(processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      r: 0,
      "r+": 2,
      w: 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      a: 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    EPERM: 63,
    ENOENT: 44,
    ESRCH: 71,
    EINTR: 27,
    EIO: 29,
    ENXIO: 60,
    E2BIG: 1,
    ENOEXEC: 45,
    EBADF: 8,
    ECHILD: 12,
    EAGAIN: 6,
    EWOULDBLOCK: 6,
    ENOMEM: 48,
    EACCES: 2,
    EFAULT: 21,
    ENOTBLK: 105,
    EBUSY: 10,
    EEXIST: 20,
    EXDEV: 75,
    ENODEV: 43,
    ENOTDIR: 54,
    EISDIR: 31,
    EINVAL: 28,
    ENFILE: 41,
    EMFILE: 33,
    ENOTTY: 59,
    ETXTBSY: 74,
    EFBIG: 22,
    ENOSPC: 51,
    ESPIPE: 70,
    EROFS: 69,
    EMLINK: 34,
    EPIPE: 64,
    EDOM: 18,
    ERANGE: 68,
    ENOMSG: 49,
    EIDRM: 24,
    ECHRNG: 106,
    EL2NSYNC: 156,
    EL3HLT: 107,
    EL3RST: 108,
    ELNRNG: 109,
    EUNATCH: 110,
    ENOCSI: 111,
    EL2HLT: 112,
    EDEADLK: 16,
    ENOLCK: 46,
    EBADE: 113,
    EBADR: 114,
    EXFULL: 115,
    ENOANO: 104,
    EBADRQC: 103,
    EBADSLT: 102,
    EDEADLOCK: 16,
    EBFONT: 101,
    ENOSTR: 100,
    ENODATA: 116,
    ETIME: 117,
    ENOSR: 118,
    ENONET: 119,
    ENOPKG: 120,
    EREMOTE: 121,
    ENOLINK: 47,
    EADV: 122,
    ESRMNT: 123,
    ECOMM: 124,
    EPROTO: 65,
    EMULTIHOP: 36,
    EDOTDOT: 125,
    EBADMSG: 9,
    ENOTUNIQ: 126,
    EBADFD: 127,
    EREMCHG: 128,
    ELIBACC: 129,
    ELIBBAD: 130,
    ELIBSCN: 131,
    ELIBMAX: 132,
    ELIBEXEC: 133,
    ENOSYS: 52,
    ENOTEMPTY: 55,
    ENAMETOOLONG: 37,
    ELOOP: 32,
    EOPNOTSUPP: 138,
    EPFNOSUPPORT: 139,
    ECONNRESET: 15,
    ENOBUFS: 42,
    EAFNOSUPPORT: 5,
    EPROTOTYPE: 67,
    ENOTSOCK: 57,
    ENOPROTOOPT: 50,
    ESHUTDOWN: 140,
    ECONNREFUSED: 14,
    EADDRINUSE: 3,
    ECONNABORTED: 13,
    ENETUNREACH: 40,
    ENETDOWN: 38,
    ETIMEDOUT: 73,
    EHOSTDOWN: 142,
    EHOSTUNREACH: 23,
    EINPROGRESS: 26,
    EALREADY: 7,
    EDESTADDRREQ: 17,
    EMSGSIZE: 35,
    EPROTONOSUPPORT: 66,
    ESOCKTNOSUPPORT: 137,
    EADDRNOTAVAIL: 4,
    ENETRESET: 39,
    EISCONN: 30,
    ENOTCONN: 53,
    ETOOMANYREFS: 141,
    EUSERS: 136,
    EDQUOT: 19,
    ESTALE: 72,
    ENOTSUP: 138,
    ENOMEDIUM: 148,
    EILSEQ: 25,
    EOVERFLOW: 61,
    ECANCELED: 11,
    ENOTRECOVERABLE: 56,
    EOWNERDEAD: 62,
    ESTRPIPE: 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants")["fs"];
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(
        null,
        "/",
        NODEFS.getMode(mount.opts.root),
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path17) {
      return NODEFS.tryFSOperation(() => {
        var mode = fs3.lstatSync(path17).mode;
        if (NODEFS.isWindows) {
          mode |= (mode & 292) >> 2;
        }
        return mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    getattr(func, node) {
      var stat = NODEFS.tryFSOperation(func);
      if (NODEFS.isWindows) {
        if (!stat.blksize) {
          stat.blksize = 4096;
        }
        if (!stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        stat.mode |= (stat.mode & 292) >> 2;
      }
      return {
        dev: stat.dev,
        ino: node.id,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr(arg, node, attr, chmod, utimes, truncate, stat) {
      NODEFS.tryFSOperation(() => {
        if (attr.mode !== void 0) {
          var mode = attr.mode;
          if (NODEFS.isWindows) {
            mode &= 384;
          }
          chmod(arg, mode);
          node.mode = attr.mode;
        }
        if (typeof (attr.atime ?? attr.mtime) === "number") {
          var atime = new Date(attr.atime ?? stat(arg).atime);
          var mtime = new Date(attr.mtime ?? stat(arg).mtime);
          utimes(arg, atime, mtime);
        }
        if (attr.size !== void 0) {
          truncate(arg, attr.size);
        }
      });
    },
    node_ops: {
      getattr(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.getattr(() => fs3.lstatSync(path17), node);
      },
      setattr(node, attr) {
        var path17 = NODEFS.realPath(node);
        if (attr.mode != null && attr.dontFollow) {
          throw new FS.ErrnoError(52);
        }
        NODEFS.setattr(
          path17,
          node,
          attr,
          fs3.chmodSync,
          fs3.utimesSync,
          fs3.truncateSync,
          fs3.lstatSync
        );
      },
      lookup(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path17);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path17 = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs3.mkdirSync(path17, node.mode);
          } else {
            fs3.writeFileSync(path17, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          FS.unlink(newPath);
        } catch (e) {
        }
        NODEFS.tryFSOperation(() => fs3.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.unlinkSync(path17));
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs3.rmdirSync(path17));
      },
      readdir(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readdirSync(path17));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs3.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path17 = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs3.readlinkSync(path17));
      },
      statfs(path17) {
        var stats = NODEFS.tryFSOperation(() => fs3.statfsSync(path17));
        stats.frsize = stats.bsize;
        return stats;
      }
    },
    stream_ops: {
      getattr(stream) {
        return NODEFS.getattr(
          () => fs3.fstatSync(stream.nfd),
          stream.node
        );
      },
      setattr(stream, attr) {
        NODEFS.setattr(
          stream.nfd,
          stream.node,
          attr,
          fs3.fchmodSync,
          fs3.futimesSync,
          fs3.ftruncateSync,
          fs3.fstatSync
        );
      },
      open(stream) {
        var path17 = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          stream.shared.refcount = 1;
          stream.nfd = fs3.openSync(
            path17,
            NODEFS.flagsForNode(stream.flags)
          );
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (stream.nfd && --stream.shared.refcount === 0) {
            fs3.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.readSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(
          () => fs3.writeSync(
            stream.nfd,
            new Int8Array(buffer.buffer, offset, length),
            0,
            length,
            position
          )
        );
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs3.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(
          stream,
          buffer,
          0,
          length,
          offset,
          false
        );
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(
        null,
        "/",
        mount.opts.fs.lstat(mount.opts.root).mode,
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path17 = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path17 = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path17, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.atime || attr.mtime) {
            var atime = new Date(attr.atime || attr.mtime);
            var mtime = new Date(attr.mtime || attr.atime);
            node.mount.opts.fs.utime(path17, atime, mtime);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path17, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path17 = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path17).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path17 = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path17, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path17, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path17 = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path17 = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path17);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path17 = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(
            path17,
            stream.flags
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(
            stream.nfd,
            buffer,
            offset,
            length,
            position
          );
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(
                stream.node
              );
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    filesystems: null,
    syncFSRequests: 0,
    readFiles: {},
    ErrnoError: class {
      name = "ErrnoError";
      // We set the `name` property to be able to identify `FS.ErrnoError`
      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
      // - when using PROXYFS, an error can come from an underlying FS
      // as different FS objects have their own FS.ErrnoError each,
      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
      // we'll use the reliable test `err.name == "ErrnoError"` instead
      constructor(errno) {
        this.errno = errno;
      }
    },
    FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
        this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path17, opts = {}) {
      if (!path17) {
        throw new FS.ErrnoError(44);
      }
      opts.follow_mount ??= true;
      if (!PATH.isAbs(path17)) {
        path17 = FS.cwd() + "/" + path17;
      }
      linkloop:
        for (var nlinks = 0; nlinks < 40; nlinks++) {
          var parts = path17.split("/").filter((p) => !!p);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            if (parts[i] === ".") {
              continue;
            }
            if (parts[i] === "..") {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              if (e?.errno === 44 && islast && opts.noent_okay) {
                return {
                  path: current_path
                };
              }
              throw e;
            }
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + "/" + link;
              }
              path17 = link + "/" + parts.slice(i + 1).join("/");
              continue linkloop;
            }
          }
          return {
            path: current_path,
            node: current
          };
        }
      throw new FS.ErrnoError(32);
    },
    getPath(node) {
      var path17;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path17)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path17}` : mount + path17;
        }
        path17 = path17 ? `${node.name}/${path17}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      if (!FS.isDir(dir.mode)) {
        return 54;
      }
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    checkOpExists(op, err2) {
      if (!op) {
        throw new FS.ErrnoError(err2);
      }
      return op;
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    doSetAttr(stream, node, attr) {
      var setattr = stream?.stream_ops.setattr;
      var arg = setattr ? stream : node;
      setattr ??= node.node_ops.setattr;
      FS.checkOpExists(setattr, 63);
      setattr(arg, attr);
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(
          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
        );
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path17, mode, dev) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      if (!name) {
        throw new FS.ErrnoError(28);
      }
      if (name === "." || name === "..") {
        throw new FS.ErrnoError(20);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    statfs(path17) {
      return FS.statfsNode(
        FS.lookupPath(path17, {
          follow: true
        }).node
      );
    },
    statfsStream(stream) {
      return FS.statfsNode(stream.node);
    },
    statfsNode(node) {
      var rtn = {
        bsize: 4096,
        frsize: 4096,
        blocks: 1e6,
        bfree: 5e5,
        bavail: 5e5,
        files: FS.nextInode,
        ffree: FS.nextInode - 1,
        fsid: 42,
        flags: 2,
        namelen: 255
      };
      if (node.node_ops.statfs) {
        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
      }
      return rtn;
    },
    create(path17, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path17, mode, 0);
    },
    mkdir(path17, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path17, mode, 0);
    },
    mkdirTree(path17, mode) {
      var dirs = path17.split("/");
      var d = "";
      for (var dir of dirs) {
        if (!dir)
          continue;
        d += "/" + dir;
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path17, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path17, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
      return readdir(node);
    },
    unlink(path17) {
      var lookup3 = FS.lookupPath(path17, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path17);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path17) {
      var lookup3 = FS.lookupPath(path17);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    },
    stat(path17, dontFollow) {
      var lookup3 = FS.lookupPath(path17, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
      return getattr(node);
    },
    fstat(fd) {
      var stream = FS.getStreamChecked(fd);
      var node = stream.node;
      var getattr = stream.stream_ops.getattr;
      var arg = getattr ? stream : node;
      getattr ??= node.node_ops.getattr;
      FS.checkOpExists(getattr, 63);
      return getattr(arg);
    },
    lstat(path17) {
      return FS.stat(path17, true);
    },
    doChmod(stream, node, mode, dontFollow) {
      FS.doSetAttr(stream, node, {
        mode: mode & 4095 | node.mode & ~4095,
        ctime: Date.now(),
        dontFollow
      });
    },
    chmod(path17, mode, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChmod(null, node, mode, dontFollow);
    },
    lchmod(path17, mode) {
      FS.chmod(path17, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.doChmod(stream, stream.node, mode, false);
    },
    doChown(stream, node, dontFollow) {
      FS.doSetAttr(stream, node, {
        timestamp: Date.now(),
        dontFollow
      });
    },
    chown(path17, uid, gid, dontFollow) {
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doChown(null, node, dontFollow);
    },
    lchown(path17, uid, gid) {
      FS.chown(path17, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.doChown(stream, stream.node, false);
    },
    doTruncate(stream, node, len) {
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.doSetAttr(stream, node, {
        size: len,
        timestamp: Date.now()
      });
    },
    truncate(path17, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path17 == "string") {
        var lookup3 = FS.lookupPath(path17, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path17;
      }
      FS.doTruncate(null, node, len);
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if (len < 0 || (stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.doTruncate(stream, stream.node, len);
    },
    utime(path17, atime, mtime) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
      setattr(node, {
        atime,
        mtime
      });
    },
    open(path17, flags, mode = 438) {
      if (path17 === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      var isDirPath;
      if (typeof path17 == "object") {
        node = path17;
      } else {
        isDirPath = path17.endsWith("/");
        var lookup3 = FS.lookupPath(path17, {
          follow: !(flags & 131072),
          noent_okay: true
        });
        node = lookup3.node;
        path17 = lookup3.path;
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else if (isDirPath) {
          throw new FS.ErrnoError(31);
        } else {
          node = FS.mknod(path17, mode | 511, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        // we want the absolute path to the node
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        // used by the file family libc calls (fopen, fwrite, ferror, etc.)
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (created) {
        FS.chmod(node, mode & 511);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!(path17 in FS.readFiles)) {
          FS.readFiles[path17] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(
        stream,
        buffer,
        offset,
        length,
        position
      );
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(
        stream,
        buffer,
        offset,
        length,
        position,
        canOwn
      );
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length) {
        throw new FS.ErrnoError(28);
      }
      return stream.stream_ops.mmap(
        stream,
        length,
        position,
        prot,
        flags
      );
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(
        stream,
        buffer,
        offset,
        length,
        mmapFlags
      );
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path17, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path17, opts.flags);
      var stat = FS.stat(path17);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path17, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path17, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(
          data,
          buf,
          0,
          buf.length
        );
        FS.write(
          stream,
          buf,
          0,
          actualNumBytes,
          void 0,
          opts.canOwn
        );
      } else if (ArrayBuffer.isView(data)) {
        FS.write(
          stream,
          data,
          0,
          data.byteLength,
          void 0,
          opts.canOwn
        );
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path17) {
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length,
        llseek: () => 0
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomFill(randomBuffer);
          randomLeft = randomBuffer.byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount(
        {
          mount() {
            var node = FS.createNode(proc_self, "fd", 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: () => stream.path
                  },
                  id: fd + 1
                };
                ret.parent = ret;
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        },
        {},
        "/proc/self/fd"
      );
    },
    createStandardStreams(input, output, error) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error) {
        FS.createDevice("/dev", "stderr", null, error);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        MEMFS,
        NODEFS,
        PROXYFS
      };
    },
    init(input, output, error) {
      FS.initialized = true;
      input ??= Module["stdin"];
      output ??= Module["stdout"];
      error ??= Module["stderr"];
      FS.createStandardStreams(input, output, error);
    },
    quit() {
      FS.initialized = false;
      _fflush(0);
      for (var stream of FS.streams) {
        if (stream) {
          FS.close(stream);
        }
      }
    },
    findObject(path17, dontResolveLastLink) {
      var ret = FS.analyzePath(path17, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path17, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        path17 = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path17, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path17);
        lookup3 = FS.lookupPath(path17, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path17, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path17.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path17, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path17 = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path17 = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path17, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path17 = PATH.join2(
        typeof parent == "string" ? parent : FS.getPath(parent),
        name
      );
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path17, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error(
          "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
        );
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        lengthKnown = false;
        chunks = [];
        // Loaded chunks. Index is the chunk number
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(
            xhr.getResponseHeader("Content-length")
          );
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error(
                "invalid range (" + from + ", " + to + ") or no bytes requested!"
              );
            if (to > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader(
                "Range",
                "bytes=" + from + "-" + to
              );
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType(
                "text/plain; charset=x-user-defined"
              );
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(
        parent,
        name,
        properties,
        canRead,
        canWrite
      );
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    websocketArgs: {},
    callbacks: {},
    on(event, callback) {
      SOCKFS.callbacks[event] = callback;
    },
    emit(event, param) {
      SOCKFS.callbacks[event]?.(param);
    },
    mount(mount) {
      SOCKFS.websocketArgs = Module["websocket"] || {};
      (Module["websocket"] ??= {})["on"] = SOCKFS.on;
      return FS.createNode(null, "/", 16895, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        // Used in getsockopt for SOL_SOCKET/SO_ERROR test
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return `socket[${SOCKFS.nextname.current++}]`;
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error(
                "WebSocket URL must be in the format ws(s)://address:port"
              );
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var url = "ws://".replace("#", "//");
            var subProtocols = "binary";
            var opts = void 0;
            if ("function" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"](...arguments);
            } else if ("string" === typeof SOCKFS.websocketArgs["url"]) {
              url = SOCKFS.websocketArgs["url"];
            }
            if (SOCKFS.websocketArgs["subprotocol"]) {
              subProtocols = SOCKFS.websocketArgs["subprotocol"];
            } else if (SOCKFS.websocketArgs["subprotocol"] === null) {
              subProtocols = "null";
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              __require("ws");
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](
                WebSocketConstructor
              );
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          msg_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.msg_send_queue.push(
            new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ])
          );
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          sock.connecting = false;
          SOCKFS.emit("open", sock.stream.fd);
          try {
            var queued = peer.msg_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.msg_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          SOCKFS.emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            SOCKFS.emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            SOCKFS.emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            SOCKFS.emit("error", [
              sock.stream.fd,
              sock.error,
              "ECONNREFUSED: Connection refused"
            ]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(
          sock,
          sock.daddr,
          sock.dport
        ) : null;
        if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
        dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || // connection-less sockets are always ready to write
        dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          if (sock.connecting) {
            mask |= 4;
          } else {
            mask |= 16;
          }
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        for (var peer of Object.values(sock.peers)) {
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(
            sock,
            sock.daddr,
            sock.dport
          );
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(
          sock,
          addr,
          port
        );
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        sock.connecting = true;
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer2 = __require("ws").Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer2 = Module["websocket"]["serverDecorator"](WebSocketServer2);
        }
        sock.server = new WebSocketServer2({
          host,
          port: sock.sport
        });
        SOCKFS.emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(
              sock.family,
              sock.type,
              sock.protocol
            );
            var peer = SOCKFS.websocket_sock_ops.createPeer(
              newsock,
              ws
            );
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            SOCKFS.emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            SOCKFS.emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          SOCKFS.emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          SOCKFS.emit("error", [
            sock.stream.fd,
            sock.error,
            "EHOSTUNREACH: Host is unreachable"
          ]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data = buffer.slice(offset, offset + length);
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(
                sock,
                addr,
                port
              );
            }
          }
          dest.msg_send_queue.push(data);
          return length;
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(
              sock,
              sock.daddr,
              sock.dport
            );
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(
            queuedBuffer,
            queuedOffset,
            bytesRead
          ),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(
            queuedBuffer,
            queuedOffset + bytesRead,
            bytesRemaining
          );
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = Number(words[words.length - 4]) + Number(words[words.length - 3]) * 256;
      words[words.length - 3] = Number(words[words.length - 2]) + Number(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [
      parts[1] << 16 | parts[0],
      parts[3] << 16 | parts[2],
      parts[5] << 16 | parts[4],
      parts[7] << 16 | parts[6]
    ];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(
          addr,
          newsock.family,
          DNS.lookup_name(newsock.daddr),
          newsock.dport,
          addrlen
        );
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [
      ints[0] & 65535,
      ints[0] >> 16,
      ints[1] & 65535,
      ints[1] >> 16,
      ints[2] & 65535,
      ints[2] >> 16,
      ints[3] & 65535,
      ints[3] >> 16
    ];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [
          HEAP32[sa + 8 >> 2],
          HEAP32[sa + 12 >> 2],
          HEAP32[sa + 16 >> 2],
          HEAP32[sa + 20 >> 2]
        ];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen) => {
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path17, allowEmpty) {
      if (PATH.isAbs(path17)) {
        return path17;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path17.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return dir + "/" + path17;
    },
    writeStat(buf, stat) {
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      HEAP64[buf + 24 >> 3] = BigInt(stat.size);
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
      return 0;
    },
    writeStatFs(buf, stats) {
      HEAP32[buf + 4 >> 2] = stats.bsize;
      HEAP32[buf + 40 >> 2] = stats.bsize;
      HEAP32[buf + 8 >> 2] = stats.blocks;
      HEAP32[buf + 12 >> 2] = stats.bfree;
      HEAP32[buf + 16 >> 2] = stats.bavail;
      HEAP32[buf + 20 >> 2] = stats.files;
      HEAP32[buf + 24 >> 2] = stats.ffree;
      HEAP32[buf + 28 >> 2] = stats.fsid;
      HEAP32[buf + 44 >> 2] = stats.flags;
      HEAP32[buf + 36 >> 2] = stats.namelen;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.chmod(path17, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
        return -8;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path17, amode, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path17, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
    try {
      if (isNaN(offset))
        return 61;
      if (mode != 0) {
        return -138;
      }
      if (offset < 0 || len < 0) {
        return -28;
      }
      var oldSize = FS.fstat(fd).size;
      var newSize = offset + len;
      if (newSize > oldSize) {
        FS.ftruncate(fd, newSize);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path17, owner, group, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      (nofollow ? FS.lchown : FS.chown)(path17, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var syscallGetVarargI = () => {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  };
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      return SYSCALLS.writeStat(buf, FS.fstat(fd));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(
        stream.getdents.length,
        startIdx + Math.floor(count / struct_size)
      );
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        HEAP64[dirp + pos >> 3] = BigInt(id);
        HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.daddr),
        sock.dport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(
        addr,
        sock.family,
        DNS.lookup_name(sock.saddr || "0.0.0.0"),
        sock.sport,
        addrlen
      );
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(
              stream.tty
            );
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.lstat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path17, mode) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      FS.mkdir(path17, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path17, buf, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path17 = SYSCALLS.calculateAt(dirfd, path17, allowEmpty);
      return SYSCALLS.writeStat(
        buf,
        nofollow ? FS.lstat(path17) : FS.stat(path17)
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path17, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path17, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        // refcnt 2 because pipe has a read end and a write end. We need to be
        // able to read from the read end after write end is closed.
        refcnt: 2,
        timestamp: /* @__PURE__ */ new Date()
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      getattr(stream) {
        var node = stream.node;
        var timestamp = node.pipe.timestamp;
        return {
          dev: 14,
          ino: node.id,
          mode: 4480,
          nlink: 1,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          atime: timestamp,
          mtime: timestamp,
          ctime: timestamp,
          blksize: 4096,
          blocks: 0
        };
      },
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        for (var bucket of pipe.buckets) {
          if (bucket.offset - bucket.roffset > 0) {
            return 64 | 1;
          }
        }
        return 0;
      },
      dup(stream) {
        stream.node.pipe.refcnt++;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var bucket of pipe.buckets) {
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var bucket of pipe.buckets) {
          var bucketSize = bucket.offset - bucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              bucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = bucket.buffer.subarray(
              bucket.roffset,
              bucket.offset
            );
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(
            data.subarray(0, freeBytesInCurrBuffer),
            currBucket.offset
          );
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(
            freeBytesInCurrBuffer,
            data.byteLength
          );
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(
            data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)
          );
          data = data.subarray(
            PIPEFS.BUCKET_BUFFER_SIZE,
            data.byteLength
          );
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path17, buf, bufsize) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path17);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(
        sock,
        len,
        typeof flags !== "undefined" ? flags : 0
      );
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(
          addr,
          sock.family,
          DNS.lookup_name(msg.addr),
          msg.port,
          addrlen
        );
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path17) {
    try {
      path17 = SYSCALLS.getStr(path17);
      FS.rmdir(path17);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      if (!addr) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      return sock.sock_ops.sendmsg(
        sock,
        HEAP8,
        message,
        length,
        dest.addr,
        dest.port
      );
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path17, buf) {
    try {
      path17 = SYSCALLS.getStr(path17);
      return SYSCALLS.writeStat(buf, FS.stat(path17));
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path17, size, buf) {
    try {
      SYSCALLS.writeStatFs(buf, FS.statfs(SYSCALLS.getStr(path17)));
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlinkat(target, dirfd, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path17, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17);
      if (flags === 0) {
        FS.unlink(path17);
      } else if (flags === 512) {
        FS.rmdir(path17);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path17, times, flags) {
    try {
      path17 = SYSCALLS.getStr(path17);
      path17 = SYSCALLS.calculateAt(dirfd, path17, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
      }
      if ((mtime ?? atime) !== null) {
        FS.utime(path17, atime, mtime);
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => abort("");
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var runtimeKeepaliveCounter = 0;
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(
      date.getFullYear(),
      6,
      1
    ).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(
        HEAP32[tmPtr + 20 >> 2] + 1900,
        HEAP32[tmPtr + 16 >> 2],
        HEAP32[tmPtr + 12 >> 2],
        HEAP32[tmPtr + 8 >> 2],
        HEAP32[tmPtr + 4 >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(
        date.getFullYear(),
        6,
        1
      ).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(
          summerOffset != winterOffset && dstOffset == guessedOffset
        );
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(
          date.getTime() + (trueOffset - guessedOffset) * 6e4
        );
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return BigInt(ret);
  };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(
        () => __emscripten_timeout(which, _emscripten_get_now())
      );
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (timezoneOffset) => {
      var sign = timezoneOffset >= 0 ? "-" : "+";
      var absOffset = Math.abs(timezoneOffset);
      var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
      var minutes = String(absOffset % 60).padStart(2, "0");
      return `UTC${sign}${hours}${minutes}`;
    };
    var winterName = extractZone(winterOffset);
    var summerName = extractZone(summerOffset);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var nowIsMonotonic = 1;
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
    if (!checkWasiClock(clk_id)) {
      return 28;
    }
    var now;
    if (clk_id === 0) {
      now = _emscripten_date_now();
    } else if (nowIsMonotonic) {
      now = _emscripten_get_now();
    } else {
      return 52;
    }
    var nsec = Math.round(now * 1e3 * 1e3);
    HEAP64[ptime >> 3] = BigInt(nsec);
    return 0;
  }
  var getHeapMax = () => (
    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
    // for any code that deals with heap sizes, which would require special
    // casing all heap size related code to treat 0 specially.
    2147483648
  );
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[newOffset >> 3] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len) {
        break;
      }
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, _htonl(1)];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  function _js_getpid() {
    return PHPLoader.processId ?? 42;
  }
  function _js_wasm_trace(format, ...args) {
    if (PHPLoader.trace instanceof Function) {
      PHPLoader.trace(_js_getpid(), format, ...args);
    }
  }
  var PHPWASM = {
    init: function() {
      Module["ENV"] = Module["ENV"] || {};
      Module["ENV"]["PATH"] = [
        Module["ENV"]["PATH"],
        "/internal/shared/bin"
      ].filter(Boolean).join(":");
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      FS.mkdir("/internal/shared/bin");
      const originalOnRuntimeInitialized = Module["onRuntimeInitialized"];
      Module["onRuntimeInitialized"] = () => {
        FS.writeFile(
          "/internal/shared/bin/php",
          new TextEncoder().encode('#!/bin/sh\nphp "$@"')
        );
        FS.chmod("/internal/shared/bin/php", 493);
        originalOnRuntimeInitialized();
      };
      FS.registerDevice(FS.makedev(64, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStdout(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stdout", FS.makedev(64, 0));
      FS.registerDevice(FS.makedev(63, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onStderr(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/stderr", FS.makedev(63, 0));
      FS.registerDevice(FS.makedev(62, 0), {
        open: () => {
        },
        close: () => {
        },
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => {
          const chunk = buffer.subarray(offset, offset + length);
          PHPWASM.onHeaders(chunk);
          return length;
        }
      });
      FS.mkdev("/internal/headers", FS.makedev(62, 0));
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? __require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach(
              (callback) => {
                callback(data);
              }
            );
          }
        }
        once(eventName, callback) {
          const self = this;
          function removedCallback() {
            callback(...arguments);
            self.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      const originalClose = FS.close;
      FS.close = function(stream) {
        originalClose(stream);
        delete PHPWASM.child_proc_by_fd[stream.fd];
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
      const originalWrite = TTY.stream_ops.write;
      TTY.stream_ops.write = function(stream, ...rest) {
        const retval = originalWrite(stream, ...rest);
        stream.tty.ops.fsync(stream.tty);
        return retval;
      };
      const originalPutChar = TTY.stream_ops.put_char;
      TTY.stream_ops.put_char = function(tty, val) {
        if (val === 10)
          tty.output.push(val);
        return originalPutChar(tty, val);
      };
    },
    onHeaders: function(chunk) {
      if (Module["onHeaders"]) {
        Module["onHeaders"](chunk);
        return;
      }
      console.log("headers", {
        chunk
      });
    },
    onStdout: function(chunk) {
      if (Module["onStdout"]) {
        Module["onStdout"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stdout.write(chunk);
      } else {
        console.log("stdout", {
          chunk
        });
      }
    },
    onStderr: function(chunk) {
      if (Module["onStderr"]) {
        Module["onStderr"](chunk);
        return;
      }
      if (ENVIRONMENT_IS_NODE) {
        process.stderr.write(chunk);
      } else {
        console.warn("stderr", {
          chunk
        });
      }
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](
          command,
          args,
          options
        );
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error(
              "spawnProcess() must return an EventEmitter but returned a different type."
            );
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return __require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error(
        "popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini."
      );
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice(
      "/dev",
      filename,
      function() {
      },
      function(byte) {
        try {
          dataBuffer.push(byte);
          if (dataCallback) {
            dataCallback(new Uint8Array(dataBuffer));
            dataBuffer = [];
          }
        } catch (e) {
          console.error(e);
          throw e;
        }
      }
    );
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : FS.cwd();
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        for (const fd of [
          // The child process exited. Let's clean up its output streams:
          ProcInfo.stdoutChildFd,
          ProcInfo.stderrChildFd
        ]) {
          if (FS.streams[fd] && !FS.isClosed(FS.streams[fd])) {
            FS.close(FS.streams[fd]);
          }
        }
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stdoutChildFd
        );
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(
            stdoutStream,
            data,
            0,
            data.length,
            stdoutAt
          );
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(
          ProcInfo.stderrChildFd
        );
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(
            stderrStream,
            data,
            0,
            data.length,
            stderrAt
          );
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          let resolved = false;
          cp.on("spawn", () => {
            if (resolved)
              return;
            resolved = true;
            resolve();
          });
          cp.on("error", (e) => {
            if (resolved)
              return;
            resolved = true;
            reject(e);
          });
          cp.on("exit", function(code) {
            if (resolved)
              return;
            resolved = true;
            if (code === 0) {
              resolve();
            } else {
              reject(
                new Error(`Process exited with code ${code}`)
              );
            }
          });
          setTimeout(() => {
            if (resolved)
              return;
            resolved = true;
            reject(new Error("Process timed out"));
          }, 5e3);
        });
      } catch (e) {
        console.error(e);
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          if (typeof data === "number") {
            data = new Uint8Array([data]);
          }
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(
              stdinStream,
              buffer,
              0,
              CHUNK_SIZE,
              offset
            );
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(
        new RegExp("\\" + SPECIAL_CHARS[i], "g"),
        "\\" + SPECIAL_CHARS[i]
      );
    }
    var EQUIVALENT_MATCHERS = {
      A: "%a",
      B: "%b",
      c: "%a %b %d %H:%M:%S %Y",
      D: "%m\\/%d\\/%y",
      e: "%d",
      F: "%Y-%m-%d",
      h: "%b",
      R: "%H\\:%M",
      r: "%I\\:%M\\:%S\\s%p",
      T: "%H\\:%M\\:%S",
      x: "%m\\/%d\\/(?:%y|%Y)",
      X: "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      a: "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      b: "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      C: "\\d\\d",
      /* day of month */
      d: "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      H: "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      I: "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      j: "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      m: "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      M: "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      n: " ",
      /* AM/PM */
      p: "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      S: "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      U: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      W: "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      w: "[0-6]",
      /* 2-digit year */
      y: "\\d\\d",
      /* 4-digit year */
      Y: "\\d\\d\\d\\d",
      /* whitespace */
      t: " ",
      /* time zone */
      z: "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(
      // any number of space or tab characters match zero or more spaces
      /\s+/g,
      "\\s*"
    );
    var matches = new RegExp("^" + pattern_out, "i").exec(
      UTF8ToString(buf)
    );
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = Number(value);
      }
      if (value = getMatch("M")) {
        date.min = Number(value);
      }
      if (value = getMatch("H")) {
        date.hour = Number(value);
      } else if (value = getMatch("I")) {
        var hour = Number(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = Number(value);
      } else if (value = getMatch("y")) {
        var year = Number(value);
        if (value = getMatch("C")) {
          year += Number(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = Number(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = Number(value);
      } else if (value = getMatch("j")) {
        var day = Number(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(
            leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
            month - 1
          );
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = Number(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(
              janFirst,
              weekDayNumber + 7 * (weekNumber - 1)
            );
          } else {
            endDate = addDays(
              janFirst,
              7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1)
            );
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(
        date.year,
        date.month,
        date.day,
        date.hour,
        date.min,
        date.sec,
        0
      );
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(
        isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,
        fullDate.getMonth() - 1
      ) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(
        `Unsupported socket option: ${level}, ${optionName}, ${optionValue}`
      );
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_iij|invoke_iiji|invoke_iijii|invoke_iijiji|invoke_jii|invoke_jiii|invoke_viijii|invoke_vji|js_open_process|_js_open_process|_asyncjs__js_open_process|js_popen_to_file|_js_popen_to_file|_asyncjs__js_popen_to_file|__syscall_fcntl64|js_release_file_locks|js_flock|js_fd_read|_js_fd_read|_fd_close|js_module_onMessage|_js_module_onMessage|_asyncjs__js_module_onMessage|js_waitpid|_js_waitpid|_asyncjs__js_waitpid|wasm_poll_socket|_wasm_poll_socket|_asyncjs__wasm_poll_socket|_wasm_shutdown|_asyncjs__wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(
            () => _asyncify_start_rewind(Asyncify.currData)
          );
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(
              Asyncify.currData
            );
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(
                asyncWasmReturnValue
              );
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof MainLoop != "undefined" && MainLoop.func) {
            MainLoop.pause();
          }
          runAndAbortIfError(
            () => _asyncify_start_unwind(Asyncify.currData)
          );
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free2(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      string: (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      array: (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path17) => FS.unlink(path17);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  MEMFS.doesNotExistError = new FS.ErrnoError(44);
  MEMFS.doesNotExistError.stack = "<generic error, no stack>";
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  function js_popen_to_file(command, mode, exitCodePtr) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return returnCallback(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(
          outByteArrays.reduce((acc, curr) => acc + curr.length, 0)
        );
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function wasm_poll_socket(socketd, events, timeout) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return returnCallback((wakeUp) => {
      const polls = [];
      if (FS.isSocket(FS.getStream(socketd)?.node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP || events & POLLIN || events & POLLOUT || events & POLLERR) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn(
          "Unsupported poll event " + events + ", defaulting to setTimeout()."
        );
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function js_fd_read(fd, iov, iovcnt, pnum) {
    const returnCallback = (resolver) => Asyncify.handleSleep(resolver);
    if (Asyncify?.State?.Normal === void 0 || Asyncify?.state === Asyncify?.State?.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return returnCallback((wakeUp) => {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function __asyncjs__js_module_onMessage(data, response_buffer) {
    return Asyncify.handleAsync(async () => {
      if (Module["onMessage"]) {
        const dataStr = UTF8ToString(data);
        return Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[response_buffer] = responsePtr;
          HEAPU8[response_buffer + 1] = responsePtr >> 8;
          HEAPU8[response_buffer + 2] = responsePtr >> 16;
          HEAPU8[response_buffer + 3] = responsePtr >> 24;
          return responseSize;
        }).catch((e) => {
          console.error(e);
          return -1;
        });
      }
    });
  }
  var wasmImports = {
    /** @export */
    m: ___assert_fail,
    /** @export */
    Y: __asyncjs__js_module_onMessage,
    /** @export */
    bb: ___call_sighandler,
    /** @export */
    S: ___cxa_throw,
    /** @export */
    ab: ___syscall_accept4,
    /** @export */
    $a: ___syscall_bind,
    /** @export */
    _a: ___syscall_chdir,
    /** @export */
    R: ___syscall_chmod,
    /** @export */
    Za: ___syscall_connect,
    /** @export */
    Ya: ___syscall_dup,
    /** @export */
    Xa: ___syscall_dup3,
    /** @export */
    Wa: ___syscall_faccessat,
    /** @export */
    Va: ___syscall_fallocate,
    /** @export */
    Ua: ___syscall_fchmod,
    /** @export */
    Ta: ___syscall_fchown32,
    /** @export */
    Q: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    Sa: ___syscall_fdatasync,
    /** @export */
    Ra: ___syscall_fstat64,
    /** @export */
    Qa: ___syscall_ftruncate64,
    /** @export */
    Pa: ___syscall_getcwd,
    /** @export */
    Oa: ___syscall_getdents64,
    /** @export */
    Na: ___syscall_getpeername,
    /** @export */
    Ma: ___syscall_getsockname,
    /** @export */
    La: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Ka: ___syscall_listen,
    /** @export */
    Ja: ___syscall_lstat64,
    /** @export */
    Ia: ___syscall_mkdirat,
    /** @export */
    Ha: ___syscall_newfstatat,
    /** @export */
    x: ___syscall_openat,
    /** @export */
    Ga: ___syscall_pipe,
    /** @export */
    Fa: ___syscall_poll,
    /** @export */
    Ea: ___syscall_readlinkat,
    /** @export */
    Da: ___syscall_recvfrom,
    /** @export */
    Ca: ___syscall_renameat,
    /** @export */
    P: ___syscall_rmdir,
    /** @export */
    Ba: ___syscall_sendto,
    /** @export */
    O: ___syscall_socket,
    /** @export */
    Aa: ___syscall_stat64,
    /** @export */
    za: ___syscall_statfs64,
    /** @export */
    ya: ___syscall_symlinkat,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    xa: ___syscall_utimensat,
    /** @export */
    ra: __abort_js,
    /** @export */
    qa: __emscripten_lookup_name,
    /** @export */
    pa: __emscripten_runtime_keepalive_clear,
    /** @export */
    oa: __emscripten_throw_longjmp,
    /** @export */
    na: __gmtime_js,
    /** @export */
    ma: __localtime_js,
    /** @export */
    la: __mktime_js,
    /** @export */
    ka: __mmap_js,
    /** @export */
    ja: __munmap_js,
    /** @export */
    L: __setitimer_js,
    /** @export */
    ia: __tzset_js,
    /** @export */
    wa: _clock_time_get,
    /** @export */
    K: _emscripten_date_now,
    /** @export */
    ha: _emscripten_get_heap_max,
    /** @export */
    w: _emscripten_get_now,
    /** @export */
    ga: _emscripten_resize_heap,
    /** @export */
    J: _emscripten_sleep,
    /** @export */
    va: _environ_get,
    /** @export */
    ua: _environ_sizes_get,
    /** @export */
    p: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    N: _fd_fdstat_get,
    /** @export */
    M: _fd_read,
    /** @export */
    ta: _fd_seek,
    /** @export */
    C: _fd_write,
    /** @export */
    fa: _getaddrinfo,
    /** @export */
    I: _getnameinfo,
    /** @export */
    ea: _getprotobyname,
    /** @export */
    da: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    s: invoke_iiiiii,
    /** @export */
    u: invoke_iiiiiii,
    /** @export */
    v: invoke_iiiiiiii,
    /** @export */
    B: invoke_iiiiiiiiii,
    /** @export */
    ca: invoke_iiji,
    /** @export */
    ba: invoke_iijii,
    /** @export */
    aa: invoke_iijiji,
    /** @export */
    $: invoke_jii,
    /** @export */
    _: invoke_jiii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    k: invoke_viiii,
    /** @export */
    z: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    y: invoke_viiiiiiiii,
    /** @export */
    n: invoke_viijii,
    /** @export */
    H: invoke_vji,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    Z: js_fd_read,
    /** @export */
    F: _js_open_process,
    /** @export */
    X: js_popen_to_file,
    /** @export */
    W: _js_process_status,
    /** @export */
    V: _js_waitpid,
    /** @export */
    U: _js_wasm_trace,
    /** @export */
    sa: _proc_exit,
    /** @export */
    T: _strptime,
    /** @export */
    r: _wasm_close,
    /** @export */
    t: wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt
  };
  var wasmExports;
  createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["db"])();
  var _malloc = (a0) => (_malloc = wasmExports["fb"])(a0);
  var _free2 = (a0) => (_free2 = wasmExports["gb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["hb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["ib"])(a0);
  var _htons = (a0) => (_htons = wasmExports["jb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["kb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["lb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["mb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["nb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["ob"])(
    a0,
    a1,
    a2,
    a3
  );
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["pb"])(
    a0,
    a1,
    a2
  );
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["qb"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["rb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["sb"])(a0);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["tb"])(
    a0
  );
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["ub"])();
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["vb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["xb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["yb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["zb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Bb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Cb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Db"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Eb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Fb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Gb"])(
    a0
  );
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Hb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Ib"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Jb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Kb"])();
  var _wasm_free = Module["_wasm_free"] = (a0) => (_wasm_free = Module["_wasm_free"] = wasmExports["Lb"])(a0);
  var _wasm_trace = Module["_wasm_trace"] = (a0, a1) => (_wasm_trace = Module["_wasm_trace"] = wasmExports["Mb"])(a0, a1);
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Nb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Ob"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Pb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Qb"])(a0, a1);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Rb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Sb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Tb"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Ub"])(a0, a1);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Vb"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Wb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Xb"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["Yb"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Zb"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["_b"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["$b"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["ac"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["bc"])(a0);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["cc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["dc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["ec"])(a0);
  var dynCall_iijii = Module["dynCall_iijii"] = (a0, a1, a2, a3, a4) => (dynCall_iijii = Module["dynCall_iijii"] = wasmExports["fc"])(
    a0,
    a1,
    a2,
    a3,
    a4
  );
  var dynCall_jiii = Module["dynCall_jiii"] = (a0, a1, a2, a3) => (dynCall_jiii = Module["dynCall_jiii"] = wasmExports["gc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["hc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["ic"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6
  );
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["jc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7
  );
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["kc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9
  );
  var dynCall_iiji = Module["dynCall_iiji"] = (a0, a1, a2, a3) => (dynCall_iiji = Module["dynCall_iiji"] = wasmExports["lc"])(
    a0,
    a1,
    a2,
    a3
  );
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["mc"])(a0, a1, a2);
  var dynCall_viijii = Module["dynCall_viijii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viijii = Module["dynCall_viijii"] = wasmExports["nc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_iijiji = Module["dynCall_iijiji"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iijiji = Module["dynCall_iijiji"] = wasmExports["oc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var dynCall_vji = Module["dynCall_vji"] = (a0, a1, a2) => (dynCall_vji = Module["dynCall_vji"] = wasmExports["pc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["qc"])(
    a0,
    a1,
    a2,
    a3,
    a4,
    a5
  );
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["rc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["sc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["tc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["uc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vji(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vji(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viijii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viijii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_jiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(
        index,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9
      );
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iijii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iijiji(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iijiji(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiji(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiji(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
      return 0n;
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = typeof _free2 === "function" ? _free2 : PHPLoader["_wasm_free"];
  if (typeof NODEFS === "object") {
    const originalCreateNode = NODEFS.createNode;
    NODEFS.createNode = function createNodeWithSharedFlag() {
      const node = originalCreateNode.apply(NODEFS, arguments);
      node.isSharedFS = true;
      return node;
    };
    var originalHashAddNode = FS.hashAddNode;
    FS.hashAddNode = function hashAddNodeIfNotSharedFS(node) {
      if (typeof locking === "object" && locking?.is_shared_fs_node(node)) {
        return;
      }
      return originalHashAddNode.apply(FS, arguments);
    };
  }
  return PHPLoader;
}
var dependencyFilename16, dependenciesTotalSize16;
var init_php_7_22 = __esm({
  "packages/php-wasm/node/asyncify/php_7_2.js"() {
    "use strict";
    dependencyFilename16 = path16.join(__dirname + "/asyncify", "7_2_34", "php_7_2.wasm");
    dependenciesTotalSize16 = 18432541;
  }
});

// packages/php-wasm/node/src/index.ts
import "@php-wasm/node-polyfills";

// packages/php-wasm/node/src/lib/get-php-loader-module.ts
import { LatestSupportedPHPVersion } from "@php-wasm/universal";
import { jspi } from "wasm-feature-detect";
async function getPHPLoaderModule(version = LatestSupportedPHPVersion) {
  if (await jspi()) {
    switch (version) {
      case "8.4":
        return await Promise.resolve().then(() => (init_php_8_4(), php_8_4_exports));
      case "8.3":
        return await Promise.resolve().then(() => (init_php_8_3(), php_8_3_exports));
      case "8.2":
        return await Promise.resolve().then(() => (init_php_8_2(), php_8_2_exports));
      case "8.1":
        return await Promise.resolve().then(() => (init_php_8_1(), php_8_1_exports));
      case "8.0":
        return await Promise.resolve().then(() => (init_php_8_0(), php_8_0_exports));
      case "7.4":
        return await Promise.resolve().then(() => (init_php_7_4(), php_7_4_exports));
      case "7.3":
        return await Promise.resolve().then(() => (init_php_7_3(), php_7_3_exports));
      case "7.2":
        return await Promise.resolve().then(() => (init_php_7_2(), php_7_2_exports));
    }
  } else {
    switch (version) {
      case "8.4":
        return await Promise.resolve().then(() => (init_php_8_42(), php_8_4_exports2));
      case "8.3":
        return await Promise.resolve().then(() => (init_php_8_32(), php_8_3_exports2));
      case "8.2":
        return await Promise.resolve().then(() => (init_php_8_22(), php_8_2_exports2));
      case "8.1":
        return await Promise.resolve().then(() => (init_php_8_12(), php_8_1_exports2));
      case "8.0":
        return await Promise.resolve().then(() => (init_php_8_02(), php_8_0_exports2));
      case "7.4":
        return await Promise.resolve().then(() => (init_php_7_42(), php_7_4_exports2));
      case "7.3":
        return await Promise.resolve().then(() => (init_php_7_32(), php_7_3_exports2));
      case "7.2":
        return await Promise.resolve().then(() => (init_php_7_22(), php_7_2_exports2));
    }
  }
  throw new Error(`Unsupported PHP version ${version}`);
}

// packages/php-wasm/node/src/lib/networking/outbound-ws-to-tcp-proxy.ts
import * as dns from "dns";
import * as util from "node:util";
import * as net2 from "net";
import * as http from "http";
import { WebSocketServer } from "ws";

// packages/php-wasm/node/src/lib/networking/utils.ts
import * as net from "net";
import { logger } from "@php-wasm/logger";
function debugLog(message, ...args) {
  if (process.env["DEV"] && !process.env["TEST"]) {
    logger.log(message, ...args);
  }
}
async function findFreePorts(n) {
  const serversPromises = [];
  for (let i = 0; i < n; i++) {
    serversPromises.push(listenOnRandomPort());
  }
  const servers = await Promise.all(serversPromises);
  const ports = [];
  for (const server of servers) {
    const address = server.address();
    ports.push(address.port);
    server.close();
  }
  return ports;
}
function listenOnRandomPort() {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.listen(0, () => {
      resolve(server);
    });
  });
}

// packages/php-wasm/node/src/lib/networking/outbound-ws-to-tcp-proxy.ts
function log(...args) {
  debugLog("[WS Server]", ...args);
}
var lookup2 = util.promisify(dns.lookup);
function prependByte(chunk, byte) {
  if (typeof chunk === "string") {
    chunk = String.fromCharCode(byte) + chunk;
  } else if (chunk instanceof ArrayBuffer || "byteLength" in chunk) {
    const buffer = new Uint8Array(chunk.byteLength + 1);
    buffer[0] = byte;
    buffer.set(new Uint8Array(chunk), 1);
    chunk = buffer.buffer;
  } else {
    log({ chunk });
    throw new Error("Unsupported chunk type: " + typeof chunk);
  }
  return chunk;
}
var COMMAND_CHUNK = 1;
var COMMAND_SET_SOCKETOPT = 2;
function addSocketOptionsSupportToWebSocketClass(WebSocketConstructor) {
  return class PHPWasmWebSocketConstructor extends WebSocketConstructor {
    // @ts-ignore
    send(chunk, callback) {
      return this.sendCommand(COMMAND_CHUNK, chunk, callback);
    }
    setSocketOpt(optionClass, optionName, optionValue) {
      return this.sendCommand(
        COMMAND_SET_SOCKETOPT,
        new Uint8Array([optionClass, optionName, optionValue]).buffer,
        () => void 0
      );
    }
    sendCommand(commandType, chunk, callback) {
      return WebSocketConstructor.prototype.send.call(
        this,
        prependByte(chunk, commandType),
        callback
      );
    }
  };
}
function initOutboundWebsocketProxyServer(listenPort, listenHost = "127.0.0.1") {
  log(`Binding the WebSockets server to ${listenHost}:${listenPort}...`);
  const webServer = http.createServer((request, response) => {
    response.writeHead(403, { "Content-Type": "text/plain" });
    response.write(
      "403 Permission Denied\nOnly websockets are allowed here.\n"
    );
    response.end();
  });
  return new Promise((resolve) => {
    webServer.listen(listenPort, listenHost, function() {
      const wsServer = new WebSocketServer({ server: webServer });
      wsServer.on("connection", onWsConnect);
      resolve(webServer);
    });
  });
}
async function onWsConnect(client, request) {
  const clientAddr = client?._socket?.remoteAddress || client.url;
  const clientLog = function(...args) {
    log(" " + clientAddr + ": ", ...args);
  };
  clientLog(
    "WebSocket connection from : " + clientAddr + " at URL " + (request ? request.url : client.upgradeReq.url)
  );
  clientLog(
    "Version " + client.protocolVersion + ", subprotocol: " + client.protocol
  );
  const reqUrl = new URL(`ws://0.0.0.0` + request.url);
  const reqTargetPort = Number(reqUrl.searchParams.get("port"));
  const reqTargetHost = reqUrl.searchParams.get("host");
  if (!reqTargetPort || !reqTargetHost) {
    clientLog("Missing host or port information");
    client.close(3e3);
    return;
  }
  let target;
  const recvQueue = [];
  function flushMessagesQueue() {
    while (recvQueue.length > 0) {
      const msg = recvQueue.pop();
      const commandType = msg[0];
      clientLog("flushing", { commandType }, msg);
      if (commandType === COMMAND_CHUNK) {
        target.write(msg.slice(1));
      } else if (commandType === COMMAND_SET_SOCKETOPT) {
        const SOL_SOCKET = 1;
        const SO_KEEPALIVE = 9;
        const IPPROTO_TCP = 6;
        const TCP_NODELAY = 1;
        if (msg[1] === SOL_SOCKET && msg[2] === SO_KEEPALIVE) {
          target.setKeepAlive(msg[3]);
        } else if (msg[1] === IPPROTO_TCP && msg[2] === TCP_NODELAY) {
          target.setNoDelay(msg[3]);
        }
      } else {
        clientLog("Unknown command type: " + commandType);
        process.exit();
      }
    }
  }
  client.on("message", function(msg) {
    recvQueue.unshift(msg);
    if (target) {
      flushMessagesQueue();
    }
  });
  client.on("close", function(code, reason) {
    clientLog(
      "WebSocket client disconnected: " + code + " [" + reason + "]"
    );
    if (target) {
      target.end();
    }
  });
  client.on("error", function(a) {
    clientLog("WebSocket client error: " + a);
    target.end();
  });
  let reqTargetIp;
  if (net2.isIP(reqTargetHost) === 0) {
    clientLog("resolving " + reqTargetHost + "... ");
    try {
      const resolution = await lookup2(reqTargetHost);
      reqTargetIp = resolution.address;
      clientLog("resolved " + reqTargetHost + " -> " + reqTargetIp);
    } catch (e) {
      clientLog("can't resolve " + reqTargetHost + " due to:", e);
      client.send([]);
      client.close(3e3);
      return;
    }
  } else {
    reqTargetIp = reqTargetHost;
  }
  clientLog(
    "Opening a socket connection to " + reqTargetIp + ":" + reqTargetPort
  );
  target = net2.createConnection(reqTargetPort, reqTargetIp, function() {
    clientLog("Connected to target");
    flushMessagesQueue();
  });
  target.on("data", function(data) {
    try {
      client.send(data);
    } catch {
      clientLog("Client closed, cleaning up target");
      target.end();
    }
  });
  target.on("end", function() {
    clientLog("target disconnected");
    client.close();
  });
  target.on("error", function(e) {
    clientLog("target connection error", e);
    target.end();
    client.close(3e3);
  });
}

// packages/php-wasm/node/src/lib/networking/inbound-tcp-to-ws-proxy.ts
import { createServer as createServer3 } from "net";
import { WebSocket as WebSocket2 } from "ws";
function log2(...args) {
  debugLog("[TCP Server]", ...args);
}
function addTCPServerToWebSocketServerClass(wsListenPort, WSServer) {
  return class PHPWasmWebSocketServer extends WSServer {
    constructor(options, callback) {
      const requestedPort = options.port;
      options.port = wsListenPort;
      listenTCPToWSProxy({
        tcpListenPort: requestedPort,
        wsConnectPort: wsListenPort
      });
      super(options, callback);
    }
  };
}
function listenTCPToWSProxy(options) {
  options = {
    wsConnectHost: "127.0.0.1",
    ...options
  };
  const { tcpListenPort, wsConnectHost, wsConnectPort } = options;
  const server = createServer3();
  server.on("connection", function handleConnection(tcpSource) {
    const inBuffer = [];
    const wsTarget = new WebSocket2(
      `ws://${wsConnectHost}:${wsConnectPort}/`
    );
    wsTarget.binaryType = "arraybuffer";
    function wsSend(data) {
      wsTarget.send(new Uint8Array(data));
    }
    wsTarget.addEventListener("open", function() {
      log2("Outbound WebSocket connection established");
      while (inBuffer.length > 0) {
        wsSend(inBuffer.shift());
      }
    });
    wsTarget.addEventListener("message", (e) => {
      log2(
        "WS->TCP message:",
        new TextDecoder().decode(e.data)
      );
      tcpSource.write(Buffer.from(e.data));
    });
    wsTarget.addEventListener("close", () => {
      log2("WebSocket connection closed");
      tcpSource.end();
    });
    tcpSource.on("data", function(data) {
      log2("TCP->WS message:", data);
      if (wsTarget.readyState === WebSocket2.OPEN) {
        while (inBuffer.length > 0) {
          wsSend(inBuffer.shift());
        }
        wsSend(data);
      } else {
        inBuffer.push(data);
      }
    });
    tcpSource.once("close", function() {
      log2("TCP connection closed");
      wsTarget.close();
    });
    tcpSource.on("error", function() {
      log2("TCP connection error");
      wsTarget.close();
    });
  });
  server.listen(tcpListenPort, function() {
    log2("TCP server listening");
  });
}

// packages/php-wasm/node/src/lib/networking/with-networking.ts
async function withNetworking(phpModuleArgs = {}) {
  const [inboundProxyWsServerPort, outboundProxyWsServerPort] = await findFreePorts(2);
  const outboundNetworkProxyServer = await initOutboundWebsocketProxyServer(
    outboundProxyWsServerPort
  );
  return {
    ...phpModuleArgs,
    outboundNetworkProxyServer,
    websocket: {
      ...phpModuleArgs["websocket"] || {},
      url: (_, host, port) => {
        const query = new URLSearchParams({
          host,
          port
        }).toString();
        return `ws://127.0.0.1:${outboundProxyWsServerPort}/?${query}`;
      },
      subprotocol: "binary",
      decorator: addSocketOptionsSupportToWebSocketClass,
      serverDecorator: addTCPServerToWebSocketServerClass.bind(
        null,
        inboundProxyWsServerPort
      )
    }
  };
}

// packages/php-wasm/node/src/lib/load-runtime.ts
import { loadPHPRuntime, FSHelpers as FSHelpers2 } from "@php-wasm/universal";
import fs2 from "fs";

// packages/php-wasm/node/src/lib/data/with-icu-data.ts
import { FSHelpers } from "@php-wasm/universal";
import fs from "fs";
async function withICUData(options) {
  const fileName = "icudt74l.dat";
  const filePath = `${__dirname}/shared/${fileName}`;
  const ICUData = fs.readFileSync(filePath);
  return {
    ENV: {
      ...options.ENV,
      ICU_DATA: "/internal/shared"
    },
    onRuntimeInitialized: (phpRuntime) => {
      if (options.onRuntimeInitialized) {
        options.onRuntimeInitialized(phpRuntime);
      }
      if (!FSHelpers.fileExists(
        phpRuntime.FS,
        `${phpRuntime.ENV.ICU_DATA}/${fileName}`
      )) {
        phpRuntime.FS.mkdirTree(phpRuntime.ENV.ICU_DATA);
        phpRuntime.FS.writeFile(
          `${phpRuntime.ENV.ICU_DATA}/${fileName}`,
          new Uint8Array(ICUData)
        );
      }
    }
  };
}

// packages/php-wasm/node/src/lib/load-runtime.ts
import { joinPaths } from "@php-wasm/util";
async function loadNodeRuntime(phpVersion, options = {}) {
  const emscriptenOptions = {
    /**
     * Emscripten default behavior is to kill the process when
     * the WASM program calls `exit()`. We want to throw an
     * exception instead.
     */
    quit: function(code, error) {
      throw error;
    },
    ...options.emscriptenOptions || {},
    onRuntimeInitialized: (phpRuntime) => {
      if (options?.followSymlinks === true) {
        phpRuntime.FS.filesystems.NODEFS.node_ops.readlink = (node) => {
          const absoluteSourcePath = phpRuntime.FS.filesystems.NODEFS.tryFSOperation(
            () => fs2.realpathSync(
              phpRuntime.FS.filesystems.NODEFS.realPath(node)
            )
          );
          const symlinkPath = joinPaths(
            `/internals/symlinks`,
            absoluteSourcePath
          );
          if (!FSHelpers2.fileExists(phpRuntime.FS, symlinkPath) && fs2.existsSync(absoluteSourcePath)) {
            phpRuntime.FS.mkdirTree(symlinkPath);
            phpRuntime.FS.mount(
              phpRuntime.FS.filesystems.NODEFS,
              { root: absoluteSourcePath },
              symlinkPath
            );
          }
          return symlinkPath;
        };
      }
      phpRuntime.FS.root.node_ops = {
        ...phpRuntime.FS.root.node_ops,
        statfs: phpRuntime.FS.filesystems.NODEFS.node_ops.statfs
      };
      phpRuntime.FS.root.mount.opts.root = ".";
    }
  };
  return await loadPHPRuntime(
    await getPHPLoaderModule(phpVersion),
    await withNetworking(emscriptenOptions),
    await withICUData(emscriptenOptions)
  );
}

// packages/php-wasm/node/src/lib/use-host-filesystem.ts
import { lstatSync, readdirSync } from "node:fs";

// packages/php-wasm/node/src/lib/node-fs-mount.ts
function createNodeFsMountHandler(localPath) {
  return async function(php, FS, vfsMountPoint) {
    FS.mount(FS.filesystems["NODEFS"], { root: localPath }, vfsMountPoint);
    return () => {
      FS.unmount(vfsMountPoint);
    };
  };
}

// packages/php-wasm/node/src/lib/use-host-filesystem.ts
function useHostFilesystem(php) {
  const dirs = readdirSync("/").filter((file) => file !== "dev").map((file) => `/${file}`).filter((file) => {
    try {
      return statPathFollowSymlinks(file).isDirectory();
    } catch {
      return false;
    }
  });
  for (const dir of dirs) {
    if (!php.fileExists(dir)) {
      php.mkdirTree(dir);
    }
    php.mount(dir, createNodeFsMountHandler(dir));
  }
  php.chdir(process.cwd());
}
function statPathFollowSymlinks(path17) {
  let stat = lstatSync(path17);
  if (stat.isSymbolicLink()) {
    const fs3 = __require("fs");
    let target = path17;
    const seen = /* @__PURE__ */ new Set();
    while (true) {
      if (seen.has(target)) {
        throw new Error(`Symlink loop detected: ${path17}`);
      }
      seen.add(target);
      const linkStat = lstatSync(target);
      if (linkStat.isSymbolicLink()) {
        target = fs3.realpathSync(target);
        continue;
      }
      stat = linkStat;
      break;
    }
  }
  return stat;
}

// packages/php-wasm/node/src/lib/file-lock-manager-for-node.ts
import { logger as logger2 } from "@php-wasm/logger";
import { openSync, closeSync } from "fs";
import { flockSync as nativeFlockSync } from "fs-ext";
var MAX_64BIT_OFFSET = BigInt(2n ** 64n - 1n);
var FileLockManagerForNode = class {
  constructor() {
    this.locks = /* @__PURE__ */ new Map();
  }
  /**
   * Lock the whole file.
   *
   * @param path The path to the file to lock. This should be the path
   *             of the file in the native filesystem.
   * @param op The whole file lock operation to perform.
   * @returns True if the lock was granted, false otherwise.
   */
  lockWholeFile(path17, op) {
    if (this.locks.get(path17) === void 0) {
      if (op.type === "unlock") {
        return true;
      }
      const maybeLock = FileLock.maybeCreate(path17, op.type);
      if (maybeLock === void 0) {
        return false;
      }
      this.locks.set(path17, maybeLock);
    }
    const lock = this.locks.get(path17);
    const result = lock.lockWholeFile(op);
    this.forgetPathIfUnlocked(path17);
    return result;
  }
  /**
   * Lock a byte range.
   *
   * @param path The path to the file to lock. This should be the path
   *             of the file in the native filesystem.
   * @param requestedLock The byte range lock to perform.
   * @returns True if the lock was granted, false otherwise.
   */
  lockFileByteRange(path17, requestedLock) {
    if (!this.locks.has(path17)) {
      if (requestedLock.type === "unlocked") {
        return true;
      }
      const maybeLock = FileLock.maybeCreate(path17, requestedLock.type);
      if (maybeLock === void 0) {
        return false;
      }
      this.locks.set(path17, maybeLock);
    }
    const lock = this.locks.get(path17);
    return lock.lockFileByteRange(requestedLock);
  }
  /**
   * Find the first conflicting byte range lock.
   *
   * @param path The path to the file to find the conflicting lock for.
   * @param desiredLock The desired byte range lock.
   * @returns The first conflicting byte range lock, or undefined if no conflicting lock exists.
   */
  findFirstConflictingByteRangeLock(path17, desiredLock) {
    const lock = this.locks.get(path17);
    if (lock === void 0) {
      return void 0;
    }
    return lock.findFirstConflictingByteRangeLock(desiredLock);
  }
  /**
   * Release all locks for the given process.
   *
   * @param pid The process ID to release locks for.
   */
  releaseLocksForProcess(pid) {
    for (const [path17, lock] of this.locks.entries()) {
      lock.releaseLocksForProcess(pid);
      this.forgetPathIfUnlocked(path17);
    }
  }
  /**
   * Release all locks for the given process and file descriptor.
   *
   * @param pid The process ID to release locks for.
   * @param fd The file descriptor to release locks for.
   * @param path The path to the file to release locks for.
   */
  releaseLocksForProcessFd(pid, fd, nativePath) {
    const lock = this.locks.get(nativePath);
    if (!lock) {
      return;
    }
    lock.releaseLocksForProcessFd(pid, fd);
    this.forgetPathIfUnlocked(nativePath);
  }
  /**
   * Forget the path if it is unlocked.
   *
   * @param path The path to the file to forget.
   */
  forgetPathIfUnlocked(path17) {
    const lock = this.locks.get(path17);
    if (!lock) {
      return;
    }
    if (lock.isUnlocked()) {
      lock.dispose();
      this.locks.delete(path17);
    }
  }
};
var FileLock = class _FileLock {
  /**
   * Create a new FileLock instance for the given file and mode.
   * Fail if the underlying native file lock cannot be acquired.
   *
   * @param path The path to the file to lock
   * @param mode The type of lock to acquire
   * @returns A FileLock instance if the lock was acquired, undefined otherwise
   */
  static maybeCreate(path17, mode) {
    let fd;
    try {
      fd = openSync(path17, "a+");
      const flockFlags = mode === "exclusive" ? "exnb" : "shnb";
      nativeFlockSync(fd, flockFlags);
      const nativeLock = { fd, mode };
      return new _FileLock(nativeLock);
    } catch {
      if (fd !== void 0) {
        try {
          closeSync(fd);
        } catch (error) {
          logger2.error(
            "Error closing locking file descriptor",
            error
          );
        }
      }
      return void 0;
    }
  }
  constructor(nativeLock) {
    this.nativeLock = nativeLock;
    this.rangeLocks = new FileLockIntervalTree();
    this.wholeFileLock = { type: "unlocked" };
  }
  /**
   * Close the file descriptor and release the native lock.
   *
   * @TODO Replace this with a Symbol.dispose property once supported by all JS runtimes.
   */
  dispose() {
    try {
      closeSync(this.nativeLock.fd);
    } catch (error) {
      logger2.error("Error closing locking file descriptor", error);
    }
  }
  /**
   * Lock the whole file.
   *
   * This method corresponds to the flock() function.
   *
   * @param op The whole file lock operation to perform.
   * @returns True if the lock was granted, false otherwise.
   */
  lockWholeFile(op) {
    if (op.type === "unlock") {
      const originalType = this.wholeFileLock.type;
      if (originalType === "unlocked") {
      } else if (this.wholeFileLock.type === "exclusive" && this.wholeFileLock.pid === op.pid && this.wholeFileLock.fd === op.fd) {
        this.wholeFileLock = { type: "unlocked" };
      } else if (this.wholeFileLock.type === "shared" && this.wholeFileLock.pidFds.has(op.pid) && this.wholeFileLock.pidFds.get(op.pid).has(op.fd)) {
        this.wholeFileLock.pidFds.get(op.pid).delete(op.fd);
        if (this.wholeFileLock.pidFds.get(op.pid).size === 0) {
          this.wholeFileLock.pidFds.delete(op.pid);
        }
        if (this.wholeFileLock.pidFds.size === 0) {
          this.wholeFileLock = { type: "unlocked" };
        }
      }
      if (!this.ensureCompatibleNativeLock()) {
        logger2.error(
          "Unable to update native lock after removing a whole file lock."
        );
      }
      return true;
    }
    if (this.doesAConflictingLockExist({
      type: op.type,
      start: 0n,
      end: MAX_64BIT_OFFSET,
      pid: op.pid
    })) {
      return false;
    }
    if (!this.ensureCompatibleNativeLock({
      overrideWholeFileLockType: op.type
    })) {
      return false;
    }
    if (op.type === "exclusive") {
      this.wholeFileLock = {
        type: "exclusive",
        pid: op.pid,
        fd: op.fd
      };
      return true;
    }
    if (op.type === "shared") {
      if (this.wholeFileLock.type !== "shared") {
        this.wholeFileLock = {
          type: "shared",
          pidFds: /* @__PURE__ */ new Map()
        };
      }
      const sharedLock = this.wholeFileLock;
      if (!sharedLock.pidFds.has(op.pid)) {
        sharedLock.pidFds.set(op.pid, /* @__PURE__ */ new Set());
      }
      sharedLock.pidFds.get(op.pid).add(op.fd);
      return true;
    }
    throw new Error(`Unexpected wholeFileLock() op: '${op.type}'`);
  }
  /**
   * Lock a byte range.
   *
   * This method corresponds to the fcntl() F_SETLK command.
   *
   * @param requestedLock The byte range lock to perform.
   * @returns True if the lock was granted, false otherwise.
   */
  lockFileByteRange(requestedLock) {
    if (requestedLock.start === requestedLock.end) {
      requestedLock = {
        ...requestedLock,
        end: MAX_64BIT_OFFSET
      };
    }
    if (requestedLock.type === "unlocked") {
      const overlappingLocksBySameProcess = this.rangeLocks.findOverlapping(requestedLock).filter((lock) => lock.pid === requestedLock.pid);
      for (const overlappingLock of overlappingLocksBySameProcess) {
        this.rangeLocks.remove(overlappingLock);
        if (overlappingLock.start < requestedLock.start) {
          this.rangeLocks.insert({
            ...overlappingLock,
            end: requestedLock.start
          });
        }
        if (overlappingLock.end > requestedLock.end) {
          this.rangeLocks.insert({
            ...overlappingLock,
            start: requestedLock.end
          });
        }
      }
      if (!this.ensureCompatibleNativeLock()) {
        logger2.error(
          "Unable to update native lock after removing a byte range lock."
        );
      }
      return true;
    }
    if (this.doesAConflictingLockExist(requestedLock)) {
      return false;
    }
    if (!this.ensureCompatibleNativeLock({
      overrideRangeLockType: requestedLock.type
    })) {
      return false;
    }
    const overlappingLocksFromSameProcess = this.rangeLocks.findOverlapping(requestedLock).filter((lock) => lock.pid === requestedLock.pid);
    let minStart = requestedLock.start;
    let maxEnd = requestedLock.end;
    for (const overlappingLock of overlappingLocksFromSameProcess) {
      this.rangeLocks.remove(overlappingLock);
      if (overlappingLock.start < minStart) {
        minStart = overlappingLock.start;
      }
      if (overlappingLock.end > maxEnd) {
        maxEnd = overlappingLock.end;
      }
    }
    const mergedLock = {
      ...requestedLock,
      start: minStart,
      end: maxEnd
    };
    this.rangeLocks.insert(mergedLock);
    return true;
  }
  /**
   * Find the first conflicting byte range lock.
   *
   * This method corresponds to the fcntl() F_GETLK command.
   *
   * @param desiredLock The desired byte range lock.
   * @returns The first conflicting byte range lock, or undefined if no conflicting lock exists.
   */
  findFirstConflictingByteRangeLock(desiredLock) {
    const overlappingLocks = this.rangeLocks.findOverlapping(desiredLock);
    const firstConflictingRangeLock = overlappingLocks.find(
      (lock) => lock.pid !== desiredLock.pid && (desiredLock.type === "exclusive" || lock.type === "exclusive")
    );
    if (firstConflictingRangeLock) {
      return firstConflictingRangeLock;
    }
    if (this.wholeFileLock.type === "unlocked") {
      return void 0;
    }
    const wfl = this.wholeFileLock;
    if (wfl.type === "exclusive" || desiredLock.type === "exclusive") {
      return {
        type: this.wholeFileLock.type,
        start: 0n,
        end: 0n,
        pid: -1
      };
    }
    return void 0;
  }
  /**
   * Release all locks for the given process.
   *
   * @param pid The process ID to release locks for.
   */
  releaseLocksForProcess(pid) {
    for (const rangeLock of this.rangeLocks.findLocksForProcess(pid)) {
      this.lockFileByteRange({
        ...rangeLock,
        type: "unlocked"
      });
    }
    if (this.wholeFileLock.type === "exclusive" && this.wholeFileLock.pid === pid) {
      this.lockWholeFile({
        pid,
        fd: this.wholeFileLock.fd,
        type: "unlock"
      });
    } else if (this.wholeFileLock.type === "shared" && this.wholeFileLock.pidFds.has(pid)) {
      for (const fd of this.wholeFileLock.pidFds.get(pid)) {
        this.lockWholeFile({
          pid,
          fd,
          type: "unlock"
        });
      }
    }
  }
  /**
   * Release all locks for the given process and file descriptor.
   *
   * @param pid The process ID to release locks for.
   * @param fd The file descriptor to release locks for.
   */
  releaseLocksForProcessFd(pid, fd) {
    for (const rangeLock of this.rangeLocks.findLocksForProcess(pid)) {
      this.lockFileByteRange({
        ...rangeLock,
        type: "unlocked"
      });
    }
    this.lockWholeFile({
      pid,
      fd,
      type: "unlock"
    });
  }
  /**
   * Check if the file lock is unlocked.
   *
   * @returns True if the file lock is unlocked, false otherwise.
   */
  isUnlocked() {
    return this.wholeFileLock.type === "unlocked" && this.rangeLocks.isEmpty();
  }
  /**
   * Ensure that the native lock is compatible with the php-wasm lock,
   * upgrading or downgrading as needed.
   *
   * @param overrideWholeFileLockType If provided, use this type for the whole file lock.
   * @param overrideRangeLockType If provided, use this type for the range lock.
   * @returns True if the native lock was upgraded or downgraded, false otherwise.
   */
  ensureCompatibleNativeLock({
    overrideWholeFileLockType,
    overrideRangeLockType
  } = {}) {
    const wholeFileLockType = overrideWholeFileLockType ?? this.wholeFileLock.type;
    const rangeLockType = overrideRangeLockType ?? this.rangeLocks.findStrictestExistingLockType();
    let requiredNativeLockType;
    if (wholeFileLockType === "exclusive" || rangeLockType === "exclusive") {
      requiredNativeLockType = "exclusive";
    } else if (wholeFileLockType === "shared" || rangeLockType === "shared") {
      requiredNativeLockType = "shared";
    } else {
      requiredNativeLockType = "unlock";
    }
    if (this.nativeLock.mode === requiredNativeLockType) {
      return true;
    }
    const flockFlags = requiredNativeLockType === "exclusive" && "exnb" || requiredNativeLockType === "shared" && "shnb" || "un";
    try {
      nativeFlockSync(this.nativeLock.fd, flockFlags);
      this.nativeLock.mode = requiredNativeLockType;
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Check if a conflicting lock exists.
   *
   * @param requestedLock The desired byte range lock.
   * @returns True if a conflicting lock exists, false otherwise.
   */
  doesAConflictingLockExist(requestedLock) {
    return this.findFirstConflictingByteRangeLock(requestedLock) !== void 0;
  }
};
var IntervalNode = class {
  constructor(range) {
    this.left = null;
    this.right = null;
    this.range = range;
    this.max = range.end;
  }
};
var FileLockIntervalTree = class {
  constructor() {
    this.root = null;
  }
  isEmpty() {
    return this.root === null;
  }
  /**
   * Insert a new locked range into the tree
   */
  insert(range) {
    this.root = this.insertNode(this.root, range);
  }
  /**
   * Find all ranges that overlap with the given range
   */
  findOverlapping(range) {
    const result = [];
    this.findOverlappingRanges(this.root, range, result);
    return result;
  }
  /**
   * Remove a lock range from the tree
   */
  remove(range) {
    this.root = this.removeNode(this.root, range);
  }
  /**
   * Find all ranges locked by the given process.
   *
   * @param pid The process ID to find locks for.
   * @returns All locked ranges for the given process.
   */
  findLocksForProcess(pid) {
    const result = [];
    this.findLocksForProcessInNode(this.root, pid, result);
    return result;
  }
  /**
   * Find the strictest existing lock type in the range lock tree.
   *
   * @returns The strictest existing lock type, or 'unlocked' if no locks exist.
   */
  findStrictestExistingLockType() {
    let maxType = "unlocked";
    const traverse = (node) => {
      if (!node) {
        return;
      }
      if (node.range.type === "exclusive") {
        maxType = "exclusive";
        return;
      }
      if (node.range.type === "shared") {
        maxType = "shared";
      }
      traverse(node.left);
      traverse(node.right);
    };
    traverse(this.root);
    return maxType;
  }
  insertNode(node, range) {
    if (!node) {
      return new IntervalNode(range);
    }
    if (range.start < node.range.start) {
      node.left = this.insertNode(node.left, range);
    } else {
      node.right = this.insertNode(node.right, range);
    }
    node.max = this.bigintMax(node.max, range.end);
    return node;
  }
  bigintMax(...args) {
    return args.reduce((max, current) => {
      return current > max ? current : max;
    }, args[0]);
  }
  findOverlappingRanges(node, range, result) {
    if (!node) {
      return;
    }
    if (this.doRangesOverlap(node.range, range)) {
      result.push(node.range);
    }
    if (node.left && node.left.max >= range.start) {
      this.findOverlappingRanges(node.left, range, result);
    }
    if (node.right && node.range.start <= range.end) {
      this.findOverlappingRanges(node.right, range, result);
    }
  }
  doRangesOverlap(a, b) {
    return a.start < b.end && b.start < a.end;
  }
  removeNode(node, range) {
    if (!node) {
      return null;
    }
    if (this.areRangesEqual(node.range, range)) {
      if (!node.left) {
        return node.right;
      }
      if (!node.right) {
        return node.left;
      }
      const successor = this.findMin(node.right);
      node.range = successor.range;
      node.right = this.removeNode(node.right, successor.range);
    } else if (range.start < node.range.start) {
      node.left = this.removeNode(node.left, range);
    } else {
      node.right = this.removeNode(node.right, range);
    }
    node.max = node.range.end;
    if (node.left) {
      node.max = this.bigintMax(node.max, node.left.max);
    }
    if (node.right) {
      node.max = this.bigintMax(node.max, node.right.max);
    }
    return node;
  }
  findMin(node) {
    let current = node;
    while (current.left) {
      current = current.left;
    }
    return current;
  }
  areRangesEqual(a, b) {
    return a.start === b.start && a.end === b.end && a.pid === b.pid;
  }
  findLocksForProcessInNode(node, pid, result) {
    if (!node) {
      return;
    }
    if (node.range.pid === pid) {
      result.push(node.range);
    }
    this.findLocksForProcessInNode(node.left, pid, result);
    this.findLocksForProcessInNode(node.right, pid, result);
  }
};
export {
  FileLock,
  FileLockManagerForNode,
  createNodeFsMountHandler,
  getPHPLoaderModule,
  loadNodeRuntime,
  useHostFilesystem,
  withNetworking
};
