import { LatestSupportedPHPVersion as fe, FSHelpers as W, loadPHPRuntime as pe, __private__dont__use as k } from "@php-wasm/universal";
import { consumeAPI as mt, exposeAPI as gt } from "@php-wasm/universal";
import { jspi as we } from "wasm-feature-detect";
import { concatArrayBuffers as B, concatUint8Arrays as u, Semaphore as Le, joinPaths as ie, basename as ye } from "@php-wasm/util";
import { logger as U } from "@php-wasm/logger";
import { teeRequest as me, cloneRequest as ge } from "@php-wasm/web-service-worker";
import { journalFSEvents as Ke, normalizeFilesystemOperations as Ie } from "@php-wasm/fs-journal";
async function De(i = fe) {
  if (await we())
    switch (i) {
      case "8.4":
        return await import("./php/jspi/php_8_4.js");
      case "8.3":
        return await import("./php/jspi/php_8_3.js");
      case "8.2":
        return await import("./php/jspi/php_8_2.js");
      case "8.1":
        return await import("./php/jspi/php_8_1.js");
      case "8.0":
        return await import("./php/jspi/php_8_0.js");
      case "7.4":
        return await import("./php/jspi/php_7_4.js");
      case "7.3":
        return await import("./php/jspi/php_7_3.js");
      case "7.2":
        return await import("./php/jspi/php_7_2.js");
    }
  else
    switch (i) {
      case "8.4":
        return await import("./php/asyncify/php_8_4.js");
      case "8.3":
        return await import("./php/asyncify/php_8_3.js");
      case "8.2":
        return await import("./php/asyncify/php_8_2.js");
      case "8.1":
        return await import("./php/asyncify/php_8_1.js");
      case "8.0":
        return await import("./php/asyncify/php_8_0.js");
      case "7.4":
        return await import("./php/asyncify/php_7_4.js");
      case "7.3":
        return await import("./php/asyncify/php_7_3.js");
      case "7.2":
        return await import("./php/asyncify/php_7_2.js");
    }
  throw new Error(`Unsupported PHP version ${i}`);
}
function f(i) {
  return Object.fromEntries(Object.entries(i).map(([e, t]) => [t, e]));
}
function K(i) {
  return new Uint8Array([i >> 8 & 255, i & 255]);
}
function w(i) {
  return new Uint8Array([
    i >> 16 & 255,
    i >> 8 & 255,
    i & 255
  ]);
}
function $(i) {
  const e = new ArrayBuffer(8);
  return new DataView(e).setBigUint64(0, BigInt(i), !1), new Uint8Array(e);
}
class y {
  constructor(e) {
    this.offset = 0, this.buffer = e, this.view = new DataView(e);
  }
  readUint8() {
    const e = this.view.getUint8(this.offset);
    return this.offset += 1, e;
  }
  readUint16() {
    const e = this.view.getUint16(this.offset);
    return this.offset += 2, e;
  }
  readUint32() {
    const e = this.view.getUint32(this.offset);
    return this.offset += 4, e;
  }
  readUint8Array(e) {
    const t = this.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, new Uint8Array(t);
  }
  isFinished() {
    return this.offset >= this.buffer.byteLength;
  }
}
class v {
  constructor(e) {
    this.offset = 0, this.buffer = new ArrayBuffer(e), this.uint8Array = new Uint8Array(this.buffer), this.view = new DataView(this.buffer);
  }
  writeUint8(e) {
    this.view.setUint8(this.offset, e), this.offset += 1;
  }
  writeUint16(e) {
    this.view.setUint16(this.offset, e), this.offset += 2;
  }
  writeUint32(e) {
    this.view.setUint32(this.offset, e), this.offset += 4;
  }
  writeUint8Array(e) {
    this.uint8Array.set(e, this.offset), this.offset += e.length;
  }
}
const b = {
  server_name: 0,
  max_fragment_length: 1,
  client_certificate_url: 2,
  trusted_ca_keys: 3,
  truncated_hmac: 4,
  status_request: 5,
  user_mapping: 6,
  client_authz: 7,
  server_authz: 8,
  cert_type: 9,
  supported_groups: 10,
  ec_point_formats: 11,
  srp: 12,
  signature_algorithms: 13,
  use_srtp: 14,
  heartbeat: 15,
  application_layer_protocol_negotiation: 16,
  status_request_v2: 17,
  signed_certificate_timestamp: 18,
  client_certificate_type: 19,
  server_certificate_type: 20,
  padding: 21,
  encrypt_then_mac: 22,
  extended_master_secret: 23,
  token_binding: 24,
  cached_info: 25,
  tls_its: 26,
  compress_certificate: 27,
  record_size_limit: 28,
  pwd_protect: 29,
  pwo_clear: 30,
  password_salt: 31,
  ticket_pinning: 32,
  tls_cert_with_extern_psk: 33,
  delegated_credential: 34,
  session_ticket: 35,
  TLMSP: 36,
  TLMSP_proxying: 37,
  TLMSP_delegate: 38,
  supported_ekt_ciphers: 39,
  pre_shared_key: 41,
  early_data: 42,
  supported_versions: 43,
  cookie: 44,
  psk_key_exchange_modes: 45,
  reserved: 46,
  certificate_authorities: 47,
  oid_filters: 48,
  post_handshake_auth: 49,
  signature_algorithms_cert: 50,
  key_share: 51,
  transparency_info: 52,
  connection_id: 54
}, We = f(b), _e = {
  host_name: 0
}, be = f(_e);
class ae {
  static decodeFromClient(e) {
    const t = new DataView(e.buffer);
    let r = 0;
    const n = t.getUint16(r);
    r += 2;
    const s = [];
    for (; r < n + 2; ) {
      const _ = e[r];
      r += 1;
      const a = t.getUint16(r);
      r += 2;
      const c = e.slice(r, r + a);
      switch (r += a, _) {
        case _e.host_name:
          s.push({
            name_type: be[_],
            name: {
              host_name: new TextDecoder().decode(c)
            }
          });
          break;
        default:
          throw new Error(`Unsupported name type ${_}`);
      }
    }
    return { server_name_list: s };
  }
  /**
   * Encode the server_name extension
   *
   * +------------------------------------+
   * | Extension Type (server_name) [2B]  |
   * | 0x00 0x00                          |
   * +------------------------------------+
   * | Extension Length             [2B]  |
   * | 0x00 0x00                          |
   * +------------------------------------+
   */
  static encodeForClient(e) {
    if (e != null && e.server_name_list.length)
      throw new Error(
        "Encoding non-empty lists for ClientHello is not supported yet. Only empty lists meant for ServerHello are supported today."
      );
    const t = new v(4);
    return t.writeUint16(b.server_name), t.writeUint16(0), t.uint8Array;
  }
}
const oe = {
  TLS1_CK_PSK_WITH_RC4_128_SHA: 138,
  TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: 139,
  TLS1_CK_PSK_WITH_AES_128_CBC_SHA: 140,
  TLS1_CK_PSK_WITH_AES_256_CBC_SHA: 141,
  TLS1_CK_DHE_PSK_WITH_RC4_128_SHA: 142,
  TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA: 143,
  TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA: 144,
  TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA: 145,
  TLS1_CK_RSA_PSK_WITH_RC4_128_SHA: 146,
  TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA: 147,
  TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA: 148,
  TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA: 149,
  TLS1_CK_PSK_WITH_AES_128_GCM_SHA256: 168,
  TLS1_CK_PSK_WITH_AES_256_GCM_SHA384: 169,
  TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256: 170,
  TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384: 171,
  TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256: 172,
  TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384: 173,
  TLS1_CK_PSK_WITH_AES_128_CBC_SHA256: 174,
  TLS1_CK_PSK_WITH_AES_256_CBC_SHA384: 175,
  TLS1_CK_PSK_WITH_NULL_SHA256: 176,
  TLS1_CK_PSK_WITH_NULL_SHA384: 177,
  TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256: 178,
  TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384: 179,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA256: 180,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA384: 181,
  TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256: 182,
  TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384: 183,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA256: 184,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA384: 185,
  TLS1_CK_PSK_WITH_NULL_SHA: 44,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA: 45,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA: 46,
  TLS1_CK_RSA_WITH_AES_128_SHA: 47,
  TLS1_CK_DH_DSS_WITH_AES_128_SHA: 48,
  TLS1_CK_DH_RSA_WITH_AES_128_SHA: 49,
  TLS1_CK_DHE_DSS_WITH_AES_128_SHA: 50,
  TLS1_CK_DHE_RSA_WITH_AES_128_SHA: 51,
  TLS1_CK_ADH_WITH_AES_128_SHA: 52,
  TLS1_CK_RSA_WITH_AES_256_SHA: 53,
  TLS1_CK_DH_DSS_WITH_AES_256_SHA: 54,
  TLS1_CK_DH_RSA_WITH_AES_256_SHA: 55,
  TLS1_CK_DHE_DSS_WITH_AES_256_SHA: 56,
  TLS1_CK_DHE_RSA_WITH_AES_256_SHA: 57,
  TLS1_CK_ADH_WITH_AES_256_SHA: 58,
  TLS1_CK_RSA_WITH_NULL_SHA256: 59,
  TLS1_CK_RSA_WITH_AES_128_SHA256: 60,
  TLS1_CK_RSA_WITH_AES_256_SHA256: 61,
  TLS1_CK_DH_DSS_WITH_AES_128_SHA256: 62,
  TLS1_CK_DH_RSA_WITH_AES_128_SHA256: 63,
  TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: 64,
  TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: 65,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: 66,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: 67,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: 68,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: 69,
  TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: 70,
  TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: 103,
  TLS1_CK_DH_DSS_WITH_AES_256_SHA256: 104,
  TLS1_CK_DH_RSA_WITH_AES_256_SHA256: 105,
  TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: 106,
  TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: 107,
  TLS1_CK_ADH_WITH_AES_128_SHA256: 108,
  TLS1_CK_ADH_WITH_AES_256_SHA256: 109,
  TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: 132,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: 133,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: 134,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: 135,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: 136,
  TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: 137,
  TLS1_CK_RSA_WITH_SEED_SHA: 150,
  TLS1_CK_DH_DSS_WITH_SEED_SHA: 151,
  TLS1_CK_DH_RSA_WITH_SEED_SHA: 152,
  TLS1_CK_DHE_DSS_WITH_SEED_SHA: 153,
  TLS1_CK_DHE_RSA_WITH_SEED_SHA: 154,
  TLS1_CK_ADH_WITH_SEED_SHA: 155,
  TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: 156,
  TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: 157,
  TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: 158,
  TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: 159,
  TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: 160,
  TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: 161,
  TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: 162,
  TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: 163,
  TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: 164,
  TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: 165,
  TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: 166,
  TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: 167,
  TLS1_CK_RSA_WITH_AES_128_CCM: 49308,
  TLS1_CK_RSA_WITH_AES_256_CCM: 49309,
  TLS1_CK_DHE_RSA_WITH_AES_128_CCM: 49310,
  TLS1_CK_DHE_RSA_WITH_AES_256_CCM: 49311,
  TLS1_CK_RSA_WITH_AES_128_CCM_8: 49312,
  TLS1_CK_RSA_WITH_AES_256_CCM_8: 49313,
  TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8: 49314,
  TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8: 49315,
  TLS1_CK_PSK_WITH_AES_128_CCM: 49316,
  TLS1_CK_PSK_WITH_AES_256_CCM: 49317,
  TLS1_CK_DHE_PSK_WITH_AES_128_CCM: 49318,
  TLS1_CK_DHE_PSK_WITH_AES_256_CCM: 49319,
  TLS1_CK_PSK_WITH_AES_128_CCM_8: 49320,
  TLS1_CK_PSK_WITH_AES_256_CCM_8: 49321,
  TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8: 49322,
  TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8: 49323,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM: 49324,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM: 49325,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8: 49326,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8: 49327,
  TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256: 186,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: 187,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: 188,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: 189,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: 190,
  TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256: 191,
  TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256: 192,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: 193,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: 194,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: 195,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: 196,
  TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256: 197,
  TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: 49153,
  TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: 49154,
  TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: 49155,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: 49156,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: 49157,
  TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: 49158,
  TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: 49159,
  TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: 49160,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: 49161,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: 49162,
  TLS1_CK_ECDH_RSA_WITH_NULL_SHA: 49163,
  TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: 49164,
  TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: 49165,
  TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: 49166,
  TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: 49167,
  TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: 49168,
  TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: 49169,
  TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: 49170,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: 49171,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: 49172,
  TLS1_CK_ECDH_anon_WITH_NULL_SHA: 49173,
  TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: 49174,
  TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: 49175,
  TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: 49176,
  TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: 49177,
  TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: 49178,
  TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: 49179,
  TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: 49180,
  TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: 49181,
  TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: 49182,
  TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: 49183,
  TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: 49184,
  TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: 49185,
  TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: 49186,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: 49187,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: 49188,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: 49189,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: 49190,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: 49191,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: 49192,
  TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: 49193,
  TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: 49194,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: 49195,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: 49196,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: 49197,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: 49198,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: 49199,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: 49200,
  TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: 49201,
  TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: 49202,
  TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA: 49203,
  TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: 49204,
  TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA: 49205,
  TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA: 49206,
  TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256: 49207,
  TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384: 49208,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA: 49209,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256: 49210,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384: 49211,
  TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: 49266,
  TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: 49267,
  TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: 49268,
  TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: 49269,
  TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: 49270,
  TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: 49271,
  TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: 49272,
  TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: 49273,
  TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49300,
  TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49301,
  TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49302,
  TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49303,
  TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49304,
  TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49305,
  TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49306,
  TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49307,
  TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305: 52392,
  TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: 52393,
  TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305: 52394,
  TLS1_CK_PSK_WITH_CHACHA20_POLY1305: 52395,
  TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305: 52396,
  TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305: 52397,
  TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305: 52398
}, V = f(oe), ce = {
  secp256r1: 23,
  secp384r1: 24,
  secp521r1: 25,
  x25519: 29,
  x448: 30
}, z = f(ce);
class Re {
  /**
   * +--------------------------------------------------+
   * | Payload Length                            [2B]   |
   * +--------------------------------------------------+
   * | Supported Groups List Length              [2B]   |
   * +--------------------------------------------------+
   * | Supported Group 1                         [2B]   |
   * +--------------------------------------------------+
   * | Supported Group 2                         [2B]   |
   * +--------------------------------------------------+
   * | ...                                              |
   * +--------------------------------------------------+
   * | Supported Group n                         [2B]   |
   * +--------------------------------------------------+
   */
  static decodeFromClient(e) {
    const t = new y(e.buffer);
    t.readUint16();
    const r = [];
    for (; !t.isFinished(); ) {
      const n = t.readUint16();
      n in z && r.push(z[n]);
    }
    return r;
  }
  /**
   * +--------------------------------------------------+
   * | Extension Type (supported_groups)         [2B]   |
   * | 0x00 0x0A                                        |
   * +--------------------------------------------------+
   * | Extension Length                          [2B]   |
   * +--------------------------------------------------+
   * | Selected Group                            [2B]   |
   * +--------------------------------------------------+
   */
  static encodeForClient(e) {
    const t = new v(6);
    return t.writeUint16(b.supported_groups), t.writeUint16(2), t.writeUint16(ce[e]), t.uint8Array;
  }
}
const Se = {
  uncompressed: 0,
  ansiX962_compressed_prime: 1,
  ansiX962_compressed_char2: 2
}, Y = f(Se);
class Be {
  /**
   * +--------------------------------------------------+
   * | Payload Length                            [2B]   |
   * +--------------------------------------------------+
   * | EC Point Formats Length                   [1B]   |
   * +--------------------------------------------------+
   * | EC Point Format 1                         [1B]   |
   * +--------------------------------------------------+
   * | EC Point Format 2                         [1B]   |
   * +--------------------------------------------------+
   * | ...                                              |
   * +--------------------------------------------------+
   * | EC Point Format n                         [1B]   |
   * +--------------------------------------------------+
   */
  static decodeFromClient(e) {
    const t = new y(e.buffer), r = t.readUint8(), n = [];
    for (let s = 0; s < r; s++) {
      const _ = t.readUint8();
      _ in Y && n.push(Y[_]);
    }
    return n;
  }
  /**
   * Encode the ec_point_formats extension
   *
   * +--------------------------------------------------+
   * | Extension Type (ec_point_formats)         [2B]   |
   * | 0x00 0x0B                                        |
   * +--------------------------------------------------+
   * | Body Length                               [2B]   |
   * +--------------------------------------------------+
   * | EC Point Format Length                    [1B]   |
   * +--------------------------------------------------+
   * | EC Point Format                           [1B]   |
   * +--------------------------------------------------+
   */
  static encodeForClient(e) {
    const t = new v(6);
    return t.writeUint16(b.ec_point_formats), t.writeUint16(2), t.writeUint8(1), t.writeUint8(Se[e]), t.uint8Array;
  }
}
const F = {
  anonymous: 0,
  rsa: 1,
  dsa: 2,
  ecdsa: 3
}, Z = f(F), j = {
  none: 0,
  md5: 1,
  sha1: 2,
  sha224: 3,
  sha256: 4,
  sha384: 5,
  sha512: 6
}, J = f(j);
class Pe {
  /**
   * Binary layout:
   *
   * +------------------------------------+
   * | Payload Length              [2B]   |
   * +------------------------------------+
   * | Hash Algorithm 1            [1B]   |
   * | Signature Algorithm 1       [1B]   |
   * +------------------------------------+
   * | Hash Algorithm 2            [1B]   |
   * | Signature Algorithm 2       [1B]   |
   * +------------------------------------+
   * | ...                                |
   * +------------------------------------+
   */
  static decodeFromClient(e) {
    const t = new y(e.buffer);
    t.readUint16();
    const r = [];
    for (; !t.isFinished(); ) {
      const n = t.readUint8(), s = t.readUint8();
      if (Z[s]) {
        if (!J[n]) {
          U.warn(`Unknown hash algorithm: ${n}`);
          continue;
        }
        r.push({
          algorithm: Z[s],
          hash: J[n]
        });
      }
    }
    return r;
  }
  /**
   * +--------------------------------------------------+
   * | Extension Type (signature_algorithms)     [2B]   |
   * | 0x00 0x0D                                        |
   * +--------------------------------------------------+
   * | Body Length                               [2B]   |
   * +--------------------------------------------------+
   * | Hash Algorithm                            [1B]   |
   * | Signature Algorithm                       [1B]   |
   * +--------------------------------------------------+
   */
  static encodeforClient(e, t) {
    const r = new v(6);
    return r.writeUint16(b.signature_algorithms), r.writeUint16(2), r.writeUint8(j[e]), r.writeUint8(F[t]), r.uint8Array;
  }
}
const X = {
  server_name: ae,
  signature_algorithms: Pe,
  supported_groups: Re,
  ec_point_formats: Be
};
function Ue(i) {
  const e = new y(i.buffer), t = [];
  for (; !e.isFinished(); ) {
    const r = e.offset, n = e.readUint16(), s = We[n], _ = e.readUint16(), a = e.readUint8Array(_);
    if (!(s in X))
      continue;
    const c = X[s];
    t.push({
      type: s,
      data: c.decodeFromClient(a),
      raw: i.slice(r, r + 4 + _)
    });
  }
  return t;
}
async function q(i, e, t, r) {
  const n = B([e, t]), s = await crypto.subtle.importKey(
    "raw",
    i,
    { name: "HMAC", hash: { name: "SHA-256" } },
    !1,
    ["sign"]
  );
  let _ = n;
  const a = [];
  for (; B(a).byteLength < r; ) {
    _ = await Q(s, _);
    const S = B([_, n]), h = await Q(s, S);
    a.push(h);
  }
  return B(a).slice(0, r);
}
async function Q(i, e) {
  return await crypto.subtle.sign(
    { name: "HMAC", hash: "SHA-256" },
    i,
    e
  );
}
const ve = {
  Null: 0
}, Me = {
  Warning: 1,
  Fatal: 2
}, Ce = f(Me), Ne = {
  CloseNotify: 0,
  UnexpectedMessage: 10,
  BadRecordMac: 20,
  DecryptionFailed: 21,
  RecordOverflow: 22,
  DecompressionFailure: 30,
  HandshakeFailure: 40,
  NoCertificate: 41,
  BadCertificate: 42,
  UnsupportedCertificate: 43,
  CertificateRevoked: 44,
  CertificateExpired: 45,
  CertificateUnknown: 46,
  IllegalParameter: 47,
  UnknownCa: 48,
  AccessDenied: 49,
  DecodeError: 50,
  DecryptError: 51,
  ExportRestriction: 60,
  ProtocolVersion: 70,
  InsufficientSecurity: 71,
  InternalError: 80,
  UserCanceled: 90,
  NoRenegotiation: 100,
  UnsupportedExtension: 110
}, he = f(Ne), C = {
  ChangeCipherSpec: 20,
  Alert: 21,
  Handshake: 22,
  ApplicationData: 23
}, T = {
  HelloRequest: 0,
  ClientHello: 1,
  ServerHello: 2,
  Certificate: 11,
  ServerKeyExchange: 12,
  ServerHelloDone: 14,
  ClientKeyExchange: 16,
  Finished: 20
}, xe = {
  /**
   * Indicates that a named curve is used.  This option
   * SHOULD be used when applicable.
   */
  NamedCurve: 3
  /**
   * Values 248 through 255 are reserved for private use.
   */
}, ke = {
  secp256r1: 23
};
class ee extends Error {
}
const P = new Uint8Array([3, 3]), qe = crypto.subtle.generateKey(
  {
    name: "ECDH",
    namedCurve: "P-256"
    // Use secp256r1 curve
  },
  !0,
  // Extractable
  ["deriveKey", "deriveBits"]
  // Key usage
);
class Oe {
  constructor() {
    this.receivedRecordSequenceNumber = 0, this.sentRecordSequenceNumber = 0, this.closed = !1, this.receivedBytesBuffer = new Uint8Array(), this.receivedTLSRecords = [], this.partialTLSMessages = {}, this.handshakeMessages = [], this.MAX_CHUNK_SIZE = 1024 * 16, this.clientEnd = {
      // We don't need to chunk the encrypted data.
      // OpenSSL already done that for us.
      upstream: new TransformStream(),
      downstream: new TransformStream()
    }, this.clientDownstreamWriter = this.clientEnd.downstream.writable.getWriter(), this.clientUpstreamReader = this.clientEnd.upstream.readable.getReader(), this.serverEnd = {
      upstream: new TransformStream(),
      /**
       * Chunk the data before encrypting it. The
       * TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256 cipher suite
       * only supports up to 16KB of data per record.
       *
       * This will spread some messages across multiple records,
       * but TLS supports it so that's fine.
       */
      downstream: Fe(this.MAX_CHUNK_SIZE)
    }, this.serverUpstreamWriter = this.serverEnd.upstream.writable.getWriter();
    const e = this;
    this.serverEnd.downstream.readable.pipeTo(
      new WritableStream({
        async write(t) {
          await e.writeTLSRecord(
            C.ApplicationData,
            t
          );
        },
        async abort(t) {
          e.clientDownstreamWriter.releaseLock(), e.clientEnd.downstream.writable.abort(t), e.close();
        },
        close() {
          e.close();
        }
      })
    ).catch(() => {
    });
  }
  /**
   * Marks this connections as closed and closes all the associated
   * streams.
   */
  async close() {
    if (!this.closed) {
      this.closed = !0;
      try {
        await this.clientDownstreamWriter.close();
      } catch {
      }
      try {
        await this.clientUpstreamReader.cancel();
      } catch {
      }
      try {
        await this.serverUpstreamWriter.close();
      } catch {
      }
      try {
        await this.clientEnd.upstream.readable.cancel();
      } catch {
      }
      try {
        await this.clientEnd.downstream.writable.close();
      } catch {
      }
    }
  }
  /**
   * TLS handshake as per RFC 5246.
   *
   * https://datatracker.ietf.org/doc/html/rfc5246#section-7.4
   */
  async TLSHandshake(e, t) {
    const r = await this.readNextHandshakeMessage(
      T.ClientHello
    );
    if (!r.body.cipher_suites.length)
      throw new Error(
        "Client did not propose any supported cipher suites."
      );
    const n = crypto.getRandomValues(new Uint8Array(32));
    await this.writeTLSRecord(
      C.Handshake,
      g.serverHello(
        r.body,
        n,
        ve.Null
      )
    ), await this.writeTLSRecord(
      C.Handshake,
      g.certificate(t)
    );
    const s = await qe, _ = r.body.random, a = await g.ECDHEServerKeyExchange(
      _,
      n,
      s,
      e
    );
    await this.writeTLSRecord(C.Handshake, a), await this.writeTLSRecord(
      C.Handshake,
      g.serverHelloDone()
    );
    const c = await this.readNextHandshakeMessage(
      T.ClientKeyExchange
    );
    await this.readNextMessage(C.ChangeCipherSpec), this.sessionKeys = await this.deriveSessionKeys({
      clientRandom: _,
      serverRandom: n,
      serverPrivateKey: s.privateKey,
      clientPublicKey: await crypto.subtle.importKey(
        "raw",
        c.body.exchange_keys,
        { name: "ECDH", namedCurve: "P-256" },
        !1,
        []
      )
    }), await this.readNextHandshakeMessage(T.Finished), await this.writeTLSRecord(
      C.ChangeCipherSpec,
      g.changeCipherSpec()
    ), await this.writeTLSRecord(
      C.Handshake,
      await g.createFinishedMessage(
        this.handshakeMessages,
        this.sessionKeys.masterSecret
      )
    ), this.handshakeMessages = [], this.pollForClientMessages();
  }
  /**
   * Derives the session keys from the random values and the
   * pre-master secret – as per RFC 5246.
   */
  async deriveSessionKeys({
    clientRandom: e,
    serverRandom: t,
    serverPrivateKey: r,
    clientPublicKey: n
  }) {
    const s = await crypto.subtle.deriveBits(
      {
        name: "ECDH",
        public: n
      },
      r,
      256
      // Length of the derived secret (256 bits for P-256)
    ), _ = new Uint8Array(
      await q(
        s,
        new TextEncoder().encode("master secret"),
        u([e, t]),
        48
      )
    ), a = await q(
      _,
      new TextEncoder().encode("key expansion"),
      u([t, e]),
      // Client key, server key, client IV, server IV
      40
    ), c = new y(a), S = c.readUint8Array(16), h = c.readUint8Array(16), A = c.readUint8Array(4), l = c.readUint8Array(4);
    return {
      masterSecret: _,
      clientWriteKey: await crypto.subtle.importKey(
        "raw",
        S,
        { name: "AES-GCM" },
        !1,
        ["encrypt", "decrypt"]
      ),
      serverWriteKey: await crypto.subtle.importKey(
        "raw",
        h,
        { name: "AES-GCM" },
        !1,
        ["encrypt", "decrypt"]
      ),
      clientIV: A,
      serverIV: l
    };
  }
  async readNextHandshakeMessage(e) {
    const t = await this.readNextMessage(C.Handshake);
    if (t.msg_type !== e)
      throw new Error(`Expected ${e} message`);
    return t;
  }
  async readNextMessage(e) {
    let t, r = !1;
    do
      t = await this.readNextTLSRecord(e), r = await this.accumulateUntilMessageIsComplete(
        t
      );
    while (r === !1);
    const n = E.TLSMessage(
      t.type,
      r
    );
    return t.type === C.Handshake && this.handshakeMessages.push(t.fragment), n;
  }
  async readNextTLSRecord(e) {
    for (; ; ) {
      for (let a = 0; a < this.receivedTLSRecords.length; a++) {
        const c = this.receivedTLSRecords[a];
        if (c.type === e)
          return this.receivedTLSRecords.splice(a, 1), c;
      }
      const t = await this.pollBytes(5), r = t[3] << 8 | t[4], n = t[0], s = await this.pollBytes(r), _ = {
        type: n,
        version: {
          major: t[1],
          minor: t[2]
        },
        length: r,
        fragment: this.sessionKeys && n !== C.ChangeCipherSpec ? await this.decryptData(n, s) : s
      };
      if (_.type === C.Alert) {
        const a = Ce[_.fragment[0]], c = he[_.fragment[1]];
        throw new Error(
          `TLS non-warning alert received: ${a} ${c}`
        );
      }
      this.receivedTLSRecords.push(_);
    }
  }
  /**
   * Returns the requested number of bytes from the client.
   * Waits for the bytes to arrive if necessary.
   */
  async pollBytes(e) {
    for (; this.receivedBytesBuffer.length < e; ) {
      const { value: r, done: n } = await this.clientUpstreamReader.read();
      if (n)
        throw await this.close(), new ee("TLS connection closed");
      if (this.receivedBytesBuffer = u([
        this.receivedBytesBuffer,
        r
      ]), this.receivedBytesBuffer.length >= e)
        break;
      await new Promise((s) => setTimeout(s, 100));
    }
    const t = this.receivedBytesBuffer.slice(0, e);
    return this.receivedBytesBuffer = this.receivedBytesBuffer.slice(e), t;
  }
  /**
   * Listens for all incoming messages and passes them to the
   * server handler.
   */
  async pollForClientMessages() {
    try {
      for (; ; ) {
        const e = await this.readNextMessage(
          C.ApplicationData
        );
        this.serverUpstreamWriter.write(e.body);
      }
    } catch (e) {
      if (e instanceof ee)
        return;
      throw e;
    }
  }
  /**
   * Decrypts data in a TLS 1.2-compliant manner using
   * the AES-GCM algorithm.
   */
  async decryptData(e, t) {
    const r = this.sessionKeys.clientIV, n = t.slice(0, 8), s = new Uint8Array([...r, ...n]), _ = await crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: s,
        additionalData: new Uint8Array([
          ...$(this.receivedRecordSequenceNumber),
          e,
          ...P,
          // Payload length without IV and tag
          ...K(t.length - 8 - 16)
        ]),
        tagLength: 128
      },
      this.sessionKeys.clientWriteKey,
      // Payload without the explicit IV
      t.slice(8)
    );
    return ++this.receivedRecordSequenceNumber, new Uint8Array(_);
  }
  async accumulateUntilMessageIsComplete(e) {
    this.partialTLSMessages[e.type] = u([
      this.partialTLSMessages[e.type] || new Uint8Array(),
      e.fragment
    ]);
    const t = this.partialTLSMessages[e.type];
    switch (e.type) {
      case C.Handshake: {
        if (t.length < 4)
          return !1;
        const r = t[1] << 8 | t[2];
        if (t.length < 3 + r)
          return !1;
        break;
      }
      case C.Alert: {
        if (t.length < 2)
          return !1;
        break;
      }
      case C.ChangeCipherSpec:
      case C.ApplicationData:
        break;
      default:
        throw new Error(`TLS: Unsupported record type ${e.type}`);
    }
    return delete this.partialTLSMessages[e.type], t;
  }
  /**
   * Passes a TLS record to the client.
   *
   * Accepts unencrypted data and ensures it gets encrypted
   * if needed before sending it to the client. The encryption
   * only kicks in after the handshake is complete.
   */
  async writeTLSRecord(e, t) {
    e === C.Handshake && this.handshakeMessages.push(t), this.sessionKeys && e !== C.ChangeCipherSpec && (t = await this.encryptData(e, t));
    const r = P, n = t.length, s = new Uint8Array(5);
    s[0] = e, s[1] = r[0], s[2] = r[1], s[3] = n >> 8 & 255, s[4] = n & 255;
    const _ = u([s, t]);
    this.clientDownstreamWriter.write(_);
  }
  /**
   * Encrypts data in a TLS 1.2-compliant manner using
   * the AES-GCM algorithm.
   */
  async encryptData(e, t) {
    const r = this.sessionKeys.serverIV, n = crypto.getRandomValues(new Uint8Array(8)), s = new Uint8Array([...r, ...n]), _ = new Uint8Array([
      ...$(this.sentRecordSequenceNumber),
      e,
      ...P,
      // Payload length without IV and tag
      ...K(t.length)
    ]), a = await crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv: s,
        additionalData: _,
        tagLength: 128
      },
      this.sessionKeys.serverWriteKey,
      t
    );
    return ++this.sentRecordSequenceNumber, u([
      n,
      new Uint8Array(a)
    ]);
  }
}
class E {
  static TLSMessage(e, t) {
    switch (e) {
      case C.Handshake:
        return E.clientHandshake(t);
      case C.Alert:
        return E.alert(t);
      case C.ChangeCipherSpec:
        return E.changeCipherSpec();
      case C.ApplicationData:
        return E.applicationData(t);
      default:
        throw new Error(`TLS: Unsupported TLS record type ${e}`);
    }
  }
  /**
   * Parses the cipher suites from the server hello message.
   *
   * The cipher suites are encoded as a list of 2-byte values.
   *
   * Binary layout:
   *
   * +----------------------------+
   * | Cipher Suites Length       |  2 bytes
   * +----------------------------+
   * | Cipher Suite 1             |  2 bytes
   * +----------------------------+
   * | Cipher Suite 2             |  2 bytes
   * +----------------------------+
   * | ...                        |
   * +----------------------------+
   * | Cipher Suite n             |  2 bytes
   * +----------------------------+
   *
   * The full list of supported cipher suites values is available at:
   *
   * https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4
   */
  static parseCipherSuites(e) {
    const t = new y(e);
    t.readUint16();
    const r = [];
    for (; !t.isFinished(); ) {
      const n = t.readUint16();
      n in V && r.push(V[n]);
    }
    return r;
  }
  static applicationData(e) {
    return {
      type: C.ApplicationData,
      body: e
    };
  }
  static changeCipherSpec() {
    return {
      type: C.ChangeCipherSpec,
      body: new Uint8Array()
    };
  }
  static alert(e) {
    return {
      type: C.Alert,
      level: Ce[e[0]],
      description: he[e[1]]
    };
  }
  static clientHandshake(e) {
    const t = e[0], r = e[1] << 16 | e[2] << 8 | e[3], n = e.slice(4);
    let s;
    switch (t) {
      case T.HelloRequest:
        s = E.clientHelloRequestPayload();
        break;
      case T.ClientHello:
        s = E.clientHelloPayload(n);
        break;
      case T.ClientKeyExchange:
        s = E.clientKeyExchangePayload(n);
        break;
      case T.Finished:
        s = E.clientFinishedPayload(n);
        break;
      default:
        throw new Error(`Invalid handshake type ${t}`);
    }
    return {
      type: C.Handshake,
      msg_type: t,
      length: r,
      body: s
    };
  }
  static clientHelloRequestPayload() {
    return {};
  }
  /**
   *	Offset  Size    Field
   *	(bytes) (bytes)
   *	+------+------+---------------------------+
   *	| 0000 |  1   | Handshake Type (1 = ClientHello)
   *	+------+------+---------------------------+
   *	| 0001 |  3   | Length of ClientHello
   *	+------+------+---------------------------+
   *	| 0004 |  2   | Protocol Version
   *	+------+------+---------------------------+
   *	| 0006 |  32  | Client Random
   *	|      |      | (4 bytes timestamp +
   *	|      |      |  28 bytes random)
   *	+------+------+---------------------------+
   *	| 0038 |  1   | Session ID Length
   *	+------+------+---------------------------+
   *	| 0039 |  0+  | Session ID (variable)
   *	|      |      | (0-32 bytes)
   *	+------+------+---------------------------+
   *	| 003A*|  2   | Cipher Suites Length
   *	+------+------+---------------------------+
   *	| 003C*|  2+  | Cipher Suites
   *	|      |      | (2 bytes each)
   *	+------+------+---------------------------+
   *	| xxxx |  1   | Compression Methods Length
   *	+------+------+---------------------------+
   *	| xxxx |  1+  | Compression Methods
   *	|      |      | (1 byte each)
   *	+------+------+---------------------------+
   *	| xxxx |  2   | Extensions Length
   *	+------+------+---------------------------+
   *	| xxxx |  2   | Extension Type
   *	+------+------+---------------------------+
   *	| xxxx |  2   | Extension Length
   *	+------+------+---------------------------+
   *	| xxxx |  v   | Extension Data
   *	+------+------+---------------------------+
   *	|      |      | (Additional extensions...)
   *	+------+------+---------------------------+
   */
  static clientHelloPayload(e) {
    const t = new y(e.buffer), r = {
      client_version: t.readUint8Array(2),
      /**
       * Technically this consists of a GMT timestamp
       * and 28 random bytes, but we don't need to
       * parse this further.
       */
      random: t.readUint8Array(32)
    }, n = t.readUint8();
    r.session_id = t.readUint8Array(n);
    const s = t.readUint16();
    r.cipher_suites = E.parseCipherSuites(
      t.readUint8Array(s).buffer
    );
    const _ = t.readUint8();
    r.compression_methods = t.readUint8Array(
      _
    );
    const a = t.readUint16();
    return r.extensions = Ue(
      t.readUint8Array(a)
    ), r;
  }
  /**
   * Binary layout:
   *
   *	+------------------------------------+
   *	| ECDH Client Public Key Length [1B] |
   *	+------------------------------------+
   *	| ECDH Client Public Key   [variable]|
   *	+------------------------------------+
   */
  static clientKeyExchangePayload(e) {
    return {
      // Skip the first byte, which is the length of the public key
      exchange_keys: e.slice(1, e.length)
    };
  }
  static clientFinishedPayload(e) {
    return {
      verify_data: e
    };
  }
}
function Fe(i) {
  return new TransformStream({
    transform(e, t) {
      for (; e.length > 0; )
        t.enqueue(e.slice(0, i)), e = e.slice(i);
    }
  });
}
class g {
  static certificate(e) {
    const t = [];
    for (const s of e)
      t.push(w(s.byteLength)), t.push(new Uint8Array(s));
    const r = u(t), n = new Uint8Array([
      ...w(r.byteLength),
      ...r
    ]);
    return new Uint8Array([
      T.Certificate,
      ...w(n.length),
      ...n
    ]);
  }
  /*
   * Byte layout of the ServerKeyExchange message:
   *
   * +-----------------------------------+
   * |    ServerKeyExchange Message      |
   * +-----------------------------------+
   * | Handshake type (1 byte)           |
   * +-----------------------------------+
   * | Length (3 bytes)                  |
   * +-----------------------------------+
   * | Curve Type (1 byte)               |
   * +-----------------------------------+
   * | Named Curve (2 bytes)             |
   * +-----------------------------------+
   * | EC Point Format (1 byte)          |
   * +-----------------------------------+
   * | Public Key Length (1 byte)        |
   * +-----------------------------------+
   * | Public Key (variable)             |
   * +-----------------------------------+
   * | Signature Algorithm (2 bytes)     |
   * +-----------------------------------+
   * | Signature Length (2 bytes)        |
   * +-----------------------------------+
   * | Signature (variable)              |
   * +-----------------------------------+
   *
   * @param clientRandom - 32 bytes from ClientHello
   * @param serverRandom - 32 bytes from ServerHello
   * @param ecdheKeyPair - ECDHE key pair
   * @param rsaPrivateKey - RSA private key for signing
   * @returns
   */
  static async ECDHEServerKeyExchange(e, t, r, n) {
    const s = new Uint8Array(
      await crypto.subtle.exportKey("raw", r.publicKey)
    ), _ = new Uint8Array([
      // Curve type (1 byte)
      xe.NamedCurve,
      // Curve name (2 bytes)
      ...K(ke.secp256r1),
      // Public key length (1 byte)
      s.byteLength,
      // Public key (65 bytes, uncompressed format)
      ...s
    ]), a = await crypto.subtle.sign(
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256"
      },
      n,
      new Uint8Array([...e, ...t, ..._])
    ), c = new Uint8Array(a), S = new Uint8Array([
      j.sha256,
      F.rsa
    ]), h = new Uint8Array([
      ..._,
      ...S,
      ...K(c.length),
      ...c
    ]);
    return new Uint8Array([
      T.ServerKeyExchange,
      ...w(h.length),
      ...h
    ]);
  }
  /**
   * +------------------------------------+
   * | Content Type (Handshake)     [1B]  |
   * | 0x16                               |
   * +------------------------------------+
   * | Version (TLS 1.2)            [2B]  |
   * | 0x03 0x03                          |
   * +------------------------------------+
   * | Length                       [2B]  |
   * +------------------------------------+
   * | Handshake Type (ServerHello) [1B]  |
   * | 0x02                               |
   * +------------------------------------+
   * | Handshake Length             [3B]  |
   * +------------------------------------+
   * | Server Version               [2B]  |
   * +------------------------------------+
   * | Server Random               [32B]  |
   * +------------------------------------+
   * | Session ID Length            [1B]  |
   * +------------------------------------+
   * | Session ID             [0-32B]     |
   * +------------------------------------+
   * | Cipher Suite                 [2B]  |
   * +------------------------------------+
   * | Compression Method           [1B]  |
   * +------------------------------------+
   * | Extensions Length            [2B]  |
   * +------------------------------------+
   * | Extension: ec_point_formats        |
   * |   Type (0x00 0x0B)           [2B]  |
   * |   Length                     [2B]  |
   * |   EC Point Formats Length    [1B]  |
   * |   EC Point Format            [1B]  |
   * +------------------------------------+
   * | Other Extensions...                |
   * +------------------------------------+
   */
  static serverHello(e, t, r) {
    const n = e.extensions.map((a) => {
      switch (a.type) {
        case "server_name":
          return ae.encodeForClient();
      }
    }).filter((a) => a !== void 0), s = u(n), _ = new Uint8Array([
      // Version field – 0x03, 0x03 means TLS 1.2
      ...P,
      ...t,
      e.session_id.length,
      ...e.session_id,
      ...K(oe.TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256),
      r,
      // Extensions length (2 bytes)
      ...K(s.length),
      ...s
    ]);
    return new Uint8Array([
      T.ServerHello,
      ...w(_.length),
      ..._
    ]);
  }
  static serverHelloDone() {
    return new Uint8Array([T.ServerHelloDone, ...w(0)]);
  }
  /**
   * Server finished message.
   * The structure is defined in:
   * https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.9
   *
   * struct {
   *     opaque verify_data[verify_data_length];
   * } Finished;
   *
   * verify_data
   *    PRF(master_secret, finished_label, Hash(handshake_messages))
   *       [0..verify_data_length-1];
   *
   * finished_label
   *    For Finished messages sent by the client, the string
   *    "client finished".  For Finished messages sent by the server,
   *    the string "server finished".
   */
  static async createFinishedMessage(e, t) {
    const r = await crypto.subtle.digest(
      "SHA-256",
      u(e)
    ), n = new Uint8Array(
      await q(
        t,
        new TextEncoder().encode("server finished"),
        r,
        // verify_data length. TLS 1.2 specifies 12 bytes for verify_data
        12
      )
    );
    return new Uint8Array([
      T.Finished,
      ...w(n.length),
      ...n
    ]);
  }
  static changeCipherSpec() {
    return new Uint8Array([1]);
  }
}
function je(i, e) {
  return Ge.generateCertificate(i, e);
}
function Ht(i) {
  return `-----BEGIN CERTIFICATE-----
${le(
    Ae(i.buffer)
  )}
-----END CERTIFICATE-----`;
}
async function dt(i) {
  const e = await crypto.subtle.exportKey("pkcs8", i);
  return `-----BEGIN PRIVATE KEY-----
${le(
    Ae(e)
  )}
-----END PRIVATE KEY-----`;
}
class Ge {
  static async generateCertificate(e, t) {
    const r = await crypto.subtle.generateKey(
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1])
      },
      !0,
      // extractable
      ["sign", "verify"]
    ), n = await this.signingRequest(
      e,
      r.publicKey
    ), s = await this.sign(
      n,
      (t == null ? void 0 : t.privateKey) ?? r.privateKey
    );
    return {
      keyPair: r,
      certificate: s,
      tbsCertificate: n,
      tbsDescription: e
    };
  }
  static async sign(e, t) {
    const r = await crypto.subtle.sign(
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256"
      },
      t,
      e.buffer
    );
    return o.sequence([
      new Uint8Array(e.buffer),
      this.signatureAlgorithm("sha256WithRSAEncryption"),
      o.bitString(new Uint8Array(r))
    ]);
  }
  static async signingRequest(e, t) {
    const r = [];
    return e.keyUsage && r.push(this.keyUsage(e.keyUsage)), e.extKeyUsage && r.push(this.extKeyUsage(e.extKeyUsage)), e.subjectAltNames && r.push(this.subjectAltName(e.subjectAltNames)), e.nsCertType && r.push(this.nsCertType(e.nsCertType)), e.basicConstraints && r.push(
      this.basicConstraints(e.basicConstraints)
    ), o.sequence([
      this.version(e.version),
      this.serialNumber(e.serialNumber),
      this.signatureAlgorithm(e.signatureAlgorithm),
      this.distinguishedName(e.issuer ?? e.subject),
      this.validity(e.validity),
      this.distinguishedName(e.subject),
      await this.subjectPublicKeyInfo(t),
      this.extensions(r)
    ]);
  }
  static version(e = 2) {
    return o.ASN1(
      160,
      o.integer(new Uint8Array([e]))
    );
  }
  static serialNumber(e = crypto.getRandomValues(new Uint8Array(4))) {
    return o.integer(e);
  }
  static signatureAlgorithm(e = "sha256WithRSAEncryption") {
    return o.sequence([
      o.objectIdentifier(p(e)),
      o.null()
    ]);
  }
  static async subjectPublicKeyInfo(e) {
    return new Uint8Array(await crypto.subtle.exportKey("spki", e));
  }
  static extensions(e) {
    return o.ASN1(163, o.sequence(e));
  }
  static distinguishedName(e) {
    const t = [];
    for (const [r, n] of Object.entries(e)) {
      const s = [
        o.objectIdentifier(p(r))
      ];
      switch (r) {
        case "countryName":
          s.push(o.printableString(n));
          break;
        default:
          s.push(o.utf8String(n));
      }
      t.push(o.set([o.sequence(s)]));
    }
    return o.sequence(t);
  }
  static validity(e) {
    return o.sequence([
      o.ASN1(
        d.UTCTime,
        new TextEncoder().encode(
          re((e == null ? void 0 : e.notBefore) ?? /* @__PURE__ */ new Date())
        )
      ),
      o.ASN1(
        d.UTCTime,
        new TextEncoder().encode(
          re(
            (e == null ? void 0 : e.notAfter) ?? Ve(/* @__PURE__ */ new Date(), 10)
          )
        )
      )
    ]);
  }
  static basicConstraints({
    ca: e = !0,
    pathLenConstraint: t = void 0
  }) {
    const r = [o.boolean(e)];
    return t !== void 0 && r.push(
      o.integer(new Uint8Array([t]))
    ), o.sequence([
      o.objectIdentifier(p("basicConstraints")),
      o.octetString(o.sequence(r))
    ]);
  }
  static keyUsage(e) {
    const t = new Uint8Array([0]);
    return e != null && e.digitalSignature && (t[0] |= 1), e != null && e.nonRepudiation && (t[0] |= 2), e != null && e.keyEncipherment && (t[0] |= 4), e != null && e.dataEncipherment && (t[0] |= 8), e != null && e.keyAgreement && (t[0] |= 16), e != null && e.keyCertSign && (t[0] |= 32), e != null && e.cRLSign && (t[0] |= 64), e != null && e.encipherOnly && (t[0] |= 128), e != null && e.decipherOnly && (t[0] |= 64), o.sequence([
      o.objectIdentifier(p("keyUsage")),
      o.boolean(!0),
      // Critical
      o.octetString(o.bitString(t))
    ]);
  }
  static extKeyUsage(e = {}) {
    return o.sequence([
      o.objectIdentifier(p("extKeyUsage")),
      o.boolean(!0),
      // Critical
      o.octetString(
        o.sequence(
          Object.entries(e).map(([t, r]) => r ? o.objectIdentifier(
            p(t)
          ) : o.null())
        )
      )
    ]);
  }
  static nsCertType(e) {
    const t = new Uint8Array([0]);
    return e.client && (t[0] |= 1), e.server && (t[0] |= 2), e.email && (t[0] |= 4), e.objsign && (t[0] |= 8), e.sslCA && (t[0] |= 16), e.emailCA && (t[0] |= 32), e.objCA && (t[0] |= 64), o.sequence([
      o.objectIdentifier(p("nsCertType")),
      o.octetString(t)
    ]);
  }
  static subjectAltName(e) {
    var s, _;
    const t = ((s = e.dnsNames) == null ? void 0 : s.map((a) => {
      const c = o.ia5String(a);
      return o.contextSpecific(2, c);
    })) || [], r = ((_ = e.ipAddresses) == null ? void 0 : _.map((a) => {
      const c = o.ia5String(a);
      return o.contextSpecific(7, c);
    })) || [], n = o.octetString(
      o.sequence([...t, ...r])
    );
    return o.sequence([
      o.objectIdentifier(p("subjectAltName")),
      o.boolean(!0),
      n
    ]);
  }
}
const $e = {
  // Algorithm OIDs
  "1.2.840.113549.1.1.1": "rsaEncryption",
  "1.2.840.113549.1.1.4": "md5WithRSAEncryption",
  "1.2.840.113549.1.1.5": "sha1WithRSAEncryption",
  "1.2.840.113549.1.1.7": "RSAES-OAEP",
  "1.2.840.113549.1.1.8": "mgf1",
  "1.2.840.113549.1.1.9": "pSpecified",
  "1.2.840.113549.1.1.10": "RSASSA-PSS",
  "1.2.840.113549.1.1.11": "sha256WithRSAEncryption",
  "1.2.840.113549.1.1.12": "sha384WithRSAEncryption",
  "1.2.840.113549.1.1.13": "sha512WithRSAEncryption",
  "1.3.101.112": "EdDSA25519",
  "1.2.840.10040.4.3": "dsa-with-sha1",
  "1.3.14.3.2.7": "desCBC",
  "1.3.14.3.2.26": "sha1",
  "1.3.14.3.2.29": "sha1WithRSASignature",
  "2.16.840.1.101.3.4.2.1": "sha256",
  "2.16.840.1.101.3.4.2.2": "sha384",
  "2.16.840.1.101.3.4.2.3": "sha512",
  "2.16.840.1.101.3.4.2.4": "sha224",
  "2.16.840.1.101.3.4.2.5": "sha512-224",
  "2.16.840.1.101.3.4.2.6": "sha512-256",
  "1.2.840.113549.2.2": "md2",
  "1.2.840.113549.2.5": "md5",
  // pkcs#7 content types
  "1.2.840.113549.1.7.1": "data",
  "1.2.840.113549.1.7.2": "signedData",
  "1.2.840.113549.1.7.3": "envelopedData",
  "1.2.840.113549.1.7.4": "signedAndEnvelopedData",
  "1.2.840.113549.1.7.5": "digestedData",
  "1.2.840.113549.1.7.6": "encryptedData",
  // pkcs#9 oids
  "1.2.840.113549.1.9.1": "emailAddress",
  "1.2.840.113549.1.9.2": "unstructuredName",
  "1.2.840.113549.1.9.3": "contentType",
  "1.2.840.113549.1.9.4": "messageDigest",
  "1.2.840.113549.1.9.5": "signingTime",
  "1.2.840.113549.1.9.6": "counterSignature",
  "1.2.840.113549.1.9.7": "challengePassword",
  "1.2.840.113549.1.9.8": "unstructuredAddress",
  "1.2.840.113549.1.9.14": "extensionRequest",
  "1.2.840.113549.1.9.20": "friendlyName",
  "1.2.840.113549.1.9.21": "localKeyId",
  "1.2.840.113549.1.9.22.1": "x509Certificate",
  // pkcs#12 safe bags
  "1.2.840.113549.1.12.10.1.1": "keyBag",
  "1.2.840.113549.1.12.10.1.2": "pkcs8ShroudedKeyBag",
  "1.2.840.113549.1.12.10.1.3": "certBag",
  "1.2.840.113549.1.12.10.1.4": "crlBag",
  "1.2.840.113549.1.12.10.1.5": "secretBag",
  "1.2.840.113549.1.12.10.1.6": "safeContentsBag",
  // password-based-encryption for pkcs#12
  "1.2.840.113549.1.5.13": "pkcs5PBES2",
  "1.2.840.113549.1.5.12": "pkcs5PBKDF2",
  "1.2.840.113549.1.12.1.1": "pbeWithSHAAnd128BitRC4",
  "1.2.840.113549.1.12.1.2": "pbeWithSHAAnd40BitRC4",
  "1.2.840.113549.1.12.1.3": "pbeWithSHAAnd3-KeyTripleDES-CBC",
  "1.2.840.113549.1.12.1.4": "pbeWithSHAAnd2-KeyTripleDES-CBC",
  "1.2.840.113549.1.12.1.5": "pbeWithSHAAnd128BitRC2-CBC",
  "1.2.840.113549.1.12.1.6": "pbewithSHAAnd40BitRC2-CBC",
  // hmac OIDs
  "1.2.840.113549.2.7": "hmacWithSHA1",
  "1.2.840.113549.2.8": "hmacWithSHA224",
  "1.2.840.113549.2.9": "hmacWithSHA256",
  "1.2.840.113549.2.10": "hmacWithSHA384",
  "1.2.840.113549.2.11": "hmacWithSHA512",
  // symmetric key algorithm oids
  "1.2.840.113549.3.7": "des-EDE3-CBC",
  "2.16.840.1.101.3.4.1.2": "aes128-CBC",
  "2.16.840.1.101.3.4.1.22": "aes192-CBC",
  "2.16.840.1.101.3.4.1.42": "aes256-CBC",
  // certificate issuer/subject OIDs
  "2.5.4.3": "commonName",
  "2.5.4.4": "surname",
  "2.5.4.5": "serialNumber",
  "2.5.4.6": "countryName",
  "2.5.4.7": "localityName",
  "2.5.4.8": "stateOrProvinceName",
  "2.5.4.9": "streetAddress",
  "2.5.4.10": "organizationName",
  "2.5.4.11": "organizationalUnitName",
  "2.5.4.12": "title",
  "2.5.4.13": "description",
  "2.5.4.15": "businessCategory",
  "2.5.4.17": "postalCode",
  "2.5.4.42": "givenName",
  "1.3.6.1.4.1.311.60.2.1.2": "jurisdictionOfIncorporationStateOrProvinceName",
  "1.3.6.1.4.1.311.60.2.1.3": "jurisdictionOfIncorporationCountryName",
  // X.509 extension OIDs
  "2.16.840.1.113730.1.1": "nsCertType",
  "2.16.840.1.113730.1.13": "nsComment",
  "2.5.29.14": "subjectKeyIdentifier",
  "2.5.29.15": "keyUsage",
  "2.5.29.17": "subjectAltName",
  "2.5.29.18": "issuerAltName",
  "2.5.29.19": "basicConstraints",
  "2.5.29.31": "cRLDistributionPoints",
  "2.5.29.32": "certificatePolicies",
  "2.5.29.35": "authorityKeyIdentifier",
  "2.5.29.37": "extKeyUsage",
  // extKeyUsage purposes
  "1.3.6.1.4.1.11129.2.4.2": "timestampList",
  "1.3.6.1.5.5.7.1.1": "authorityInfoAccess",
  "1.3.6.1.5.5.7.3.1": "serverAuth",
  "1.3.6.1.5.5.7.3.2": "clientAuth",
  "1.3.6.1.5.5.7.3.3": "codeSigning",
  "1.3.6.1.5.5.7.3.4": "emailProtection",
  "1.3.6.1.5.5.7.3.8": "timeStamping"
};
function p(i) {
  for (const [e, t] of Object.entries($e))
    if (t === i)
      return e;
  throw new Error(`OID not found for name: ${i}`);
}
const te = 32, d = {
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  Utf8String: 12,
  Sequence: 16 | te,
  Set: 17 | te,
  PrintableString: 19,
  IA5String: 22,
  UTCTime: 23
};
class o {
  // Helper functions for ASN.1 DER encoding
  static length_(e) {
    if (e < 128)
      return new Uint8Array([e]);
    {
      let t = e;
      const r = [];
      for (; t > 0; )
        r.unshift(t & 255), t >>= 8;
      const n = r.length, s = new Uint8Array(1 + n);
      s[0] = 128 | n;
      for (let _ = 0; _ < n; _++)
        s[_ + 1] = r[_];
      return s;
    }
  }
  static ASN1(e, t) {
    const r = o.length_(t.length), n = new Uint8Array(1 + r.length + t.length);
    return n[0] = e, n.set(r, 1), n.set(t, 1 + r.length), n;
  }
  static integer(e) {
    if (e[0] > 127) {
      const t = new Uint8Array(e.length + 1);
      t[0] = 0, t.set(e, 1), e = t;
    }
    return o.ASN1(d.Integer, e);
  }
  static bitString(e) {
    const t = new Uint8Array([0]), r = new Uint8Array(t.length + e.length);
    return r.set(t), r.set(e, t.length), o.ASN1(d.BitString, r);
  }
  static octetString(e) {
    return o.ASN1(d.OctetString, e);
  }
  static null() {
    return o.ASN1(d.Null, new Uint8Array(0));
  }
  static objectIdentifier(e) {
    const t = e.split(".").map(Number), n = [t[0] * 40 + t[1]];
    for (let s = 2; s < t.length; s++) {
      let _ = t[s];
      const a = [];
      do
        a.unshift(_ & 127), _ >>= 7;
      while (_ > 0);
      for (let c = 0; c < a.length - 1; c++)
        a[c] |= 128;
      n.push(...a);
    }
    return o.ASN1(d.OID, new Uint8Array(n));
  }
  static utf8String(e) {
    const t = new TextEncoder().encode(e);
    return o.ASN1(d.Utf8String, t);
  }
  static printableString(e) {
    const t = new TextEncoder().encode(e);
    return o.ASN1(d.PrintableString, t);
  }
  static sequence(e) {
    return o.ASN1(d.Sequence, u(e));
  }
  static set(e) {
    return o.ASN1(d.Set, u(e));
  }
  static ia5String(e) {
    const t = new TextEncoder().encode(e);
    return o.ASN1(d.IA5String, t);
  }
  static contextSpecific(e, t, r = !1) {
    const n = (r ? 160 : 128) | e;
    return o.ASN1(n, t);
  }
  static boolean(e) {
    return o.ASN1(
      d.Boolean,
      new Uint8Array([e ? 255 : 0])
    );
  }
}
function Ae(i) {
  return btoa(String.fromCodePoint(...new Uint8Array(i)));
}
function le(i) {
  var e;
  return ((e = i.match(/.{1,64}/g)) == null ? void 0 : e.join(`
`)) || i;
}
function re(i) {
  const e = i.getUTCFullYear().toString().substr(2), t = D(i.getUTCMonth() + 1), r = D(i.getUTCDate()), n = D(i.getUTCHours()), s = D(i.getUTCMinutes()), _ = D(i.getUTCSeconds());
  return `${e}${t}${r}${n}${s}${_}Z`;
}
function D(i) {
  return i.toString().padStart(2, "0");
}
function Ve(i, e) {
  const t = new Date(i);
  return t.setUTCFullYear(t.getUTCFullYear() + e), t;
}
async function ze(i, e, t, r) {
  var S;
  const n = typeof i == "string" ? new Request(i, e) : i;
  if (!t)
    return await fetch(n);
  const s = r ? new URL(r) : null, _ = new URL(
    n.url,
    s || void 0
  );
  if (s && _.protocol === s.protocol && _.hostname === s.hostname && _.port === s.port && _.pathname.startsWith(s.pathname))
    return await fetch(n);
  const [a, c] = await me(n);
  try {
    return await fetch(a);
  } catch {
    const A = ((S = new Headers(c.headers).get("x-cors-proxy-allowed-request-headers")) == null ? void 0 : S.split(",")) || [], l = A.includes("authorization") || A.includes("cookie"), H = await ge(c, {
      url: `${t}${n.url}`,
      ...l && { credentials: "include" }
    });
    return await fetch(H, e);
  }
}
class Ye extends TransformStream {
  constructor() {
    let e = new Uint8Array(0), t = "SCAN_CHUNK_SIZE", r = 0;
    super({
      transform(n, s) {
        for (e = u([e, n]); e.length > 0; )
          if (t === "SCAN_CHUNK_SIZE") {
            if (e.length < 3)
              return;
            let _ = 0;
            for (; _ < e.length; ) {
              const S = e[_];
              if (!(S >= 48 && S <= 57 || // 0-9
              S >= 97 && S <= 102 || // a-f
              S >= 65 && S <= 70)) break;
              _++;
            }
            if (_ === 0)
              throw new Error("Invalid chunk size format");
            if (e.length < _ + 2)
              return;
            if (e[_] !== 13 || // \r
            e[_ + 1] !== 10)
              throw new Error(
                "Invalid chunk size format. Expected CRLF after chunk size"
              );
            const a = new TextDecoder().decode(
              e.slice(0, _)
            ), c = parseInt(a, 16);
            if (e = e.slice(_ + 2), c === 0) {
              t = "SCAN_FINAL_CHUNK", s.terminate();
              return;
            }
            r = c, t = "SCAN_CHUNK_DATA";
          } else if (t === "SCAN_CHUNK_DATA") {
            const _ = Math.min(
              r,
              e.length
            ), a = e.slice(0, _);
            e = e.slice(_), r -= _, s.enqueue(a), r === 0 && (t = "SCAN_CHUNK_TRAILER");
          } else if (t === "SCAN_CHUNK_TRAILER") {
            if (e.length < 2)
              return;
            if (e[0] !== 13 || e[1] !== 10)
              throw new Error(
                "Invalid chunk trailer format. Expected CRLF after chunk data"
              );
            e = e.slice(2), t = "SCAN_CHUNK_SIZE";
          }
      }
    });
  }
}
const Ze = (i, e) => ({
  ...i,
  websocket: {
    url: (t, r, n) => `ws://playground.internal/?${new URLSearchParams({
      host: r,
      port: n
    }).toString()}`,
    subprotocol: "binary",
    decorator: () => class extends Je {
      constructor(t, r) {
        super(t, r, {
          CAroot: e.CAroot,
          corsProxyUrl: e.corsProxyUrl
        });
      }
    }
  }
});
class Je {
  constructor(e, t, {
    CAroot: r,
    corsProxyUrl: n,
    outputType: s = "messages"
  } = {}) {
    this.CONNECTING = 0, this.OPEN = 1, this.CLOSING = 2, this.CLOSED = 3, this.readyState = this.CONNECTING, this.binaryType = "blob", this.bufferedAmount = 0, this.extensions = "", this.protocol = "ws", this.host = "", this.port = 0, this.listeners = /* @__PURE__ */ new Map(), this.clientUpstream = new TransformStream(), this.clientUpstreamWriter = this.clientUpstream.writable.getWriter(), this.clientDownstream = new TransformStream(), this.fetchInitiated = !1, this.bufferedBytesFromClient = new Uint8Array(0), this.url = e, this.options = t;
    const _ = new URL(e);
    this.host = _.searchParams.get("host"), this.port = parseInt(_.searchParams.get("port"), 10), this.binaryType = "arraybuffer", this.corsProxyUrl = n, this.CAroot = r, s === "messages" && this.clientDownstream.readable.pipeTo(
      new WritableStream({
        write: (a) => {
          this.emit("message", { data: a });
        },
        abort: () => {
          this.emit("error", new Error("ECONNREFUSED")), this.close();
        },
        close: () => {
          this.close();
        }
      })
    ).catch(() => {
    }), this.readyState = this.OPEN, this.emit("open");
  }
  on(e, t) {
    this.addEventListener(e, t);
  }
  once(e, t) {
    const r = (n) => {
      t(n), this.removeEventListener(e, r);
    };
    this.addEventListener(e, r);
  }
  addEventListener(e, t) {
    this.listeners.has(e) || this.listeners.set(e, /* @__PURE__ */ new Set()), this.listeners.get(e).add(t);
  }
  removeListener(e, t) {
    this.removeEventListener(e, t);
  }
  removeEventListener(e, t) {
    const r = this.listeners.get(e);
    r && r.delete(t);
  }
  emit(e, t = {}) {
    e === "message" ? this.onmessage(t) : e === "close" ? this.onclose(t) : e === "error" ? this.onerror(t) : e === "open" && this.onopen(t);
    const r = this.listeners.get(e);
    if (r)
      for (const n of r)
        n(t);
  }
  // Default event handlers that can be overridden by the user
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onclose(e) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onerror(e) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onmessage(e) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onopen(e) {
  }
  /**
   * Emscripten calls this method whenever the WASM module
   * writes bytes to the TCP socket.
   */
  send(e) {
    if (!(this.readyState === this.CLOSING || this.readyState === this.CLOSED) && (this.clientUpstreamWriter.write(new Uint8Array(e)), !this.fetchInitiated))
      switch (this.bufferedBytesFromClient = u([
        this.bufferedBytesFromClient,
        new Uint8Array(e)
      ]), Qe(this.port, this.bufferedBytesFromClient)) {
        case !1:
          return;
        case "other":
          this.emit("error", new Error("Unsupported protocol")), this.close();
          break;
        case "tls":
          this.fetchOverTLS(), this.fetchInitiated = !0;
          break;
        case "http":
          this.fetchOverHTTP(), this.fetchInitiated = !0;
          break;
      }
  }
  async fetchOverTLS() {
    if (!this.CAroot)
      throw new Error(
        "TLS protocol is only supported when the TCPOverFetchWebsocket is instantiated with a CAroot"
      );
    const e = await je(
      {
        subject: {
          commonName: this.host,
          organizationName: this.host,
          countryName: "US"
        },
        issuer: this.CAroot.tbsDescription.subject
      },
      this.CAroot.keyPair
    ), t = new Oe();
    this.clientUpstream.readable.pipeTo(t.clientEnd.upstream.writable).catch(() => {
    }), t.clientEnd.downstream.readable.pipeTo(this.clientDownstream.writable).catch(() => {
    }), await t.TLSHandshake(e.keyPair.privateKey, [
      e.certificate,
      this.CAroot.certificate
    ]);
    const r = await L.parseHttpRequest(
      t.serverEnd.upstream.readable,
      this.host,
      "https"
    );
    try {
      await L.fetchRawResponseBytes(
        r,
        this.corsProxyUrl
      ).pipeTo(t.serverEnd.downstream.writable);
    } catch {
    }
  }
  async fetchOverHTTP() {
    const e = await L.parseHttpRequest(
      this.clientUpstream.readable,
      this.host,
      "http"
    );
    try {
      await L.fetchRawResponseBytes(
        e,
        this.corsProxyUrl
      ).pipeTo(this.clientDownstream.writable);
    } catch {
    }
  }
  close() {
    this.emit("message", { data: new Uint8Array(0) }), this.readyState = this.CLOSING, this.emit("close"), this.readyState = this.CLOSED;
  }
}
const Xe = [
  "GET",
  "POST",
  "HEAD",
  "PATCH",
  "OPTIONS",
  "DELETE",
  "PUT",
  "TRACE"
];
function Qe(i, e) {
  if (e.length < 8)
    return !1;
  if (i === 443 && e[0] === C.Handshake && // TLS versions between 1.0 and 1.2
  e[1] === 3 && e[2] >= 1 && e[2] <= 3)
    return "tls";
  const r = new TextDecoder("latin1", {
    fatal: !0
  }).decode(e);
  return Xe.some(
    (s) => r.startsWith(s + " ")
  ) ? "http" : "other";
}
class L {
  /**
   * Streams a HTTP response including the status line and headers.
   */
  static fetchRawResponseBytes(e, t) {
    return new ReadableStream({
      async start(r) {
        var a;
        let n;
        try {
          n = await ze(
            e,
            void 0,
            t
          );
        } catch (c) {
          r.enqueue(
            new TextEncoder().encode(
              `HTTP/1.1 400 Bad Request\r
Content-Length: 0\r
\r
`
            )
          ), r.error(c);
          return;
        }
        r.enqueue(L.headersAsBytes(n));
        const s = (a = n.body) == null ? void 0 : a.getReader();
        if (!s) {
          r.close();
          return;
        }
        const _ = new TextEncoder();
        for (; ; ) {
          const { done: c, value: S } = await s.read();
          if (S && (r.enqueue(
            _.encode(`${S.length.toString(16)}\r
`)
          ), r.enqueue(S), r.enqueue(_.encode(`\r
`))), c) {
            r.enqueue(_.encode(`0\r
\r
`)), r.close();
            return;
          }
        }
      }
    });
  }
  static headersAsBytes(e) {
    const t = `HTTP/1.1 ${e.status} ${e.statusText}`, r = {};
    e.headers.forEach((_, a) => {
      r[a.toLowerCase()] = _;
    }), delete r["content-length"], r["transfer-encoding"] = "chunked";
    const n = [];
    for (const [_, a] of Object.entries(r))
      n.push(`${_}: ${a}`);
    const s = [t, ...n].join(`\r
`) + `\r
\r
`;
    return new TextEncoder().encode(s);
  }
  /**
   * Parses a raw, streamed HTTP request into a Request object
   * with known headers and a readable body stream.
   */
  static async parseHttpRequest(e, t, r) {
    let n = new Uint8Array(0), s = !1, _ = -1;
    const a = e.getReader();
    for (; _ === -1; ) {
      const { done: N, value: R } = await a.read();
      if (N) {
        s = !0;
        break;
      }
      n = u([n, R]), _ = et(
        n,
        new Uint8Array([13, 10, 13, 10])
      );
    }
    a.releaseLock();
    const c = n.slice(0, _), S = L.parseRequestHeaders(c), h = S.headers.get("Transfer-Encoding") !== null ? "chunked" : "content-length", A = S.headers.get("Content-Length") !== null ? parseInt(S.headers.get("Content-Length"), 10) : void 0, l = n.slice(
      _ + 4
      /* Skip \r\n\r\n */
    );
    let H;
    if (S.method !== "GET") {
      const N = e.getReader();
      let R = l.length, x = l.slice(-6);
      const He = new TextEncoder().encode(`0\r
\r
`);
      H = new ReadableStream({
        async start(I) {
          l.length > 0 && I.enqueue(l), s && I.close();
        },
        async pull(I) {
          const { done: de, value: m } = await N.read();
          if (R += (m == null ? void 0 : m.length) || 0, m && (I.enqueue(m), x = u([
            x,
            m || new Uint8Array()
          ]).slice(-5)), de || h === "content-length" && A !== void 0 && R >= A || h === "chunked" && x.every(
            (Te, Ee) => Te === He[Ee]
          )) {
            I.close();
            return;
          }
        }
      }), h === "chunked" && (H = H.pipeThrough(
        new Ye()
      ));
    }
    const M = S.headers.get("Host") ?? t, G = new URL(S.path, r + "://" + M);
    return G.pathname = S.path, new Request(G.toString(), {
      method: S.method,
      headers: S.headers,
      body: H,
      // In Node.js, duplex: 'half' is required when
      // the body stream is provided.
      // @ts-expect-error
      duplex: "half"
    });
  }
  static parseRequestHeaders(e) {
    const t = new TextDecoder().decode(e), r = t.split(`
`)[0], [n, s] = r.split(" "), _ = new Headers();
    for (const a of t.split(`\r
`).slice(1)) {
      if (a === "")
        break;
      const [c, S] = a.split(": ");
      _.set(c, S);
    }
    return { method: n, path: s, headers: _ };
  }
}
function et(i, e) {
  const t = i.length, r = e.length, n = t - r;
  for (let s = 0; s <= n; s++) {
    let _ = !0;
    for (let a = 0; a < r; a++)
      if (i[s + a] !== e[a]) {
        _ = !1;
        break;
      }
    if (_)
      return s;
  }
  return -1;
}
async function tt(i) {
  const e = "icudt74l.dat", t = (await import("./shared/icudt74l.js")).dataFilename, r = await (await fetch(t)).arrayBuffer();
  return {
    ...i,
    ENV: {
      ...i.ENV,
      ICU_DATA: "/internal/shared"
    },
    onRuntimeInitialized: (n) => {
      i.onRuntimeInitialized && i.onRuntimeInitialized(n), W.fileExists(
        n.FS,
        `${n.ENV.ICU_DATA}/${e}`
      ) || (n.FS.mkdirTree(n.ENV.ICU_DATA), n.FS.writeFile(
        `${n.ENV.ICU_DATA}/${e}`,
        new Uint8Array(r)
      ));
    }
  };
}
const rt = () => ({
  websocket: {
    decorator: (i) => class extends i {
      constructor() {
        try {
          super();
        } catch {
        }
      }
      send() {
        return null;
      }
    }
  }
});
async function Et(i, e = {}) {
  var s;
  let t = {
    ...rt(),
    ...e.emscriptenOptions || {}
  };
  e.tcpOverFetch && (t = Ze(
    t,
    e.tcpOverFetch
  )), e.withICU && (t = tt(t));
  const [r, n] = await Promise.all([
    De(i),
    t
  ]);
  return (s = e.onPhpLoaderModuleLoaded) == null || s.call(e, r), await pe(r, n);
}
function ft(i, e) {
  window.addEventListener("message", (t) => {
    t.source === i.contentWindow && (e && t.origin !== e || typeof t.data != "object" || t.data.type !== "relay" || window.parent.postMessage(t.data, "*"));
  }), window.addEventListener("message", (t) => {
    var r;
    t.source === window.parent && (typeof t.data != "object" || t.data.type !== "relay" || (r = i == null ? void 0 : i.contentWindow) == null || r.postMessage(t.data));
  });
}
async function pt(i) {
  const e = new Worker(i, { type: "module" });
  return new Promise((t, r) => {
    e.onerror = (s) => {
      const _ = new Error(
        `WebWorker failed to load at ${i}. ${s.message ? `Original error: ${s.message}` : ""}`
      );
      _.filename = s.filename, r(_);
    };
    function n(s) {
      s.data === "worker-script-started" && (t(e), e.removeEventListener("message", n));
    }
    e.addEventListener("message", n);
  });
}
function wt(i, e = { initialSync: {} }) {
  return e = {
    ...e,
    initialSync: {
      ...e.initialSync,
      direction: e.initialSync.direction ?? "opfs-to-memfs"
    }
  }, async function(t, r, n) {
    return e.initialSync.direction === "opfs-to-memfs" ? (W.fileExists(r, n) && W.rmdir(r, n), W.mkdir(r, n), await nt(r, i, n)) : await ue(
      r,
      i,
      n,
      e.initialSync.onProgress
    ), it(t, i, n);
  };
}
async function nt(i, e, t) {
  W.mkdir(i, t);
  const r = new Le({
    concurrency: 40
  }), n = [], s = [
    [e, t]
  ];
  for (; s.length > 0; ) {
    const [_, a] = s.pop();
    for await (const c of _.values()) {
      const S = r.run(async () => {
        const h = ie(
          a,
          c.name
        );
        if (c.kind === "directory") {
          try {
            i.mkdir(h);
          } catch (A) {
            if ((A == null ? void 0 : A.errno) !== 20)
              throw U.error(A), A;
          }
          s.push([c, h]);
        } else if (c.kind === "file") {
          const A = await c.getFile(), l = new Uint8Array(await A.arrayBuffer());
          i.createDataFile(
            a,
            c.name,
            l,
            !0,
            !0,
            !0
          );
        }
        n.splice(n.indexOf(S), 1);
      });
      n.push(S);
    }
    for (; s.length === 0 && n.length > 0; )
      await Promise.any(n);
  }
}
async function ue(i, e, t, r) {
  i.mkdirTree(t);
  const n = [];
  async function s(h, A) {
    await Promise.all(
      i.readdir(h).filter(
        (l) => l !== "." && l !== ".."
      ).map(async (l) => {
        const H = ie(h, l);
        if (!st(i, H)) {
          n.push([A, H, l]);
          return;
        }
        const M = await A.getDirectoryHandle(l, {
          create: !0
        });
        return await s(H, M);
      })
    );
  }
  await s(t, e);
  let _ = 0;
  const a = r && ot(r, 100), c = 100, S = /* @__PURE__ */ new Set();
  try {
    for (const [h, A, l] of n) {
      const H = O(
        h,
        l,
        i,
        A
      ).then(() => {
        _++, S.delete(H), a == null || a({
          files: _,
          total: n.length
        });
      });
      S.add(H), S.size >= c && (await Promise.race(S), a == null || a({
        files: _,
        total: n.length
      }));
    }
  } finally {
    await Promise.allSettled(S);
  }
}
function st(i, e) {
  return i.isDir(i.lookupPath(e, { follow: !0 }).node.mode);
}
async function O(i, e, t, r) {
  let n;
  try {
    n = t.readFile(r, {
      encoding: "binary"
    });
  } catch {
    return;
  }
  const s = await i.getFileHandle(e, { create: !0 }), _ = s.createWritable !== void 0 ? (
    // Google Chrome, Firefox, probably more browsers
    await s.createWritable()
  ) : (
    // Safari
    await s.createSyncAccessHandle()
  );
  try {
    await _.truncate(0), await _.write(n);
  } finally {
    await _.close();
  }
}
function it(i, e, t) {
  const r = [], n = Ke(i, t, (a) => {
    r.push(a);
  }), s = new _t(i, e, t);
  async function _() {
    if (r.length === 0)
      return;
    const a = await i.semaphore.acquire(), c = [...r];
    r.splice(0, c.length);
    const S = Ie(c);
    try {
      for (const h of S)
        await s.processEntry(h);
    } finally {
      a();
    }
  }
  return i.addEventListener("request.end", _), function() {
    n(), i.removeEventListener("request.end", _);
  };
}
class _t {
  constructor(e, t, r) {
    this.php = e, this.opfs = t, this.memfsRoot = ne(r);
  }
  toOpfsPath(e) {
    return ne(e.substring(this.memfsRoot.length));
  }
  async processEntry(e) {
    if (!e.path.startsWith(this.memfsRoot) || e.path === this.memfsRoot)
      return;
    const t = this.toOpfsPath(e.path), r = await se(this.opfs, t), n = at(t);
    if (n)
      try {
        if (e.operation === "DELETE")
          try {
            await r.removeEntry(n, {
              recursive: !0
            });
          } catch {
          }
        else if (e.operation === "CREATE")
          e.nodeType === "directory" ? await r.getDirectoryHandle(n, {
            create: !0
          }) : await r.getFileHandle(n, {
            create: !0
          });
        else if (e.operation === "WRITE")
          await O(
            r,
            n,
            this.php[k].FS,
            e.path
          );
        else if (e.operation === "RENAME" && e.toPath.startsWith(this.memfsRoot)) {
          const s = this.toOpfsPath(e.toPath), _ = await se(
            this.opfs,
            s
          );
          if (e.nodeType === "directory") {
            const a = await _.getDirectoryHandle(
              n,
              {
                create: !0
              }
            );
            await ue(
              this.php[k].FS,
              a,
              e.toPath
            ), await r.removeEntry(n, {
              recursive: !0
            });
          } else {
            try {
              await r.removeEntry(n);
            } catch {
            }
            await O(
              _,
              ye(s),
              this.php[k].FS,
              e.toPath
            );
          }
        }
      } catch (s) {
        throw U.log({ entry: e, name: n }), U.error(s), s;
      }
  }
}
function ne(i) {
  return i.replace(/\/$/, "").replace(/\/\/+/g, "/");
}
function at(i) {
  return i.substring(i.lastIndexOf("/") + 1);
}
async function se(i, e) {
  const t = e.replace(/^\/+|\/+$/g, "").replace(/\/+/, "/");
  if (!t)
    return i;
  const r = t.split("/");
  let n = i;
  for (let s = 0; s < r.length - 1; s++) {
    const _ = r[s];
    n = await n.getDirectoryHandle(_, { create: !0 });
  }
  return n;
}
function ot(i, e) {
  let t = 0, r, n;
  return function(..._) {
    n = _;
    const a = Date.now() - t;
    if (r === void 0) {
      const c = Math.max(0, e - a);
      r = setTimeout(() => {
        r = void 0, t = Date.now(), i(...n);
      }, c);
    }
  };
}
export {
  Ht as certificateToPEM,
  mt as consumeAPI,
  wt as createDirectoryHandleMountHandler,
  gt as exposeAPI,
  ze as fetchWithCorsProxy,
  je as generateCertificate,
  De as getPHPLoaderModule,
  Et as loadWebRuntime,
  dt as privateKeyToPEM,
  ft as setupPostMessageRelay,
  pt as spawnPHPWorkerThread
};
//# sourceMappingURL=index.js.map
