/// <reference types="node" />
import type { GeneratedCertificate } from './tls/certificates';
import type { EmscriptenOptions } from '@php-wasm/universal';
export type TCPOverFetchOptions = {
    CAroot: GeneratedCertificate;
    corsProxyUrl?: string;
};
/**
 * Sets up a WebSocket that analyzes the received bytes and, if they look like
 * TLS or HTTP, handles the network transmission using fetch().
 */
export declare const tcpOverFetchWebsocket: (emOptions: EmscriptenOptions, tcpOptions: TCPOverFetchOptions) => {
    websocket: {
        url: (_: any, host: string, port: string) => string;
        subprotocol: string;
        decorator: () => {
            new (url: string, wsOptions: string[]): {
                CONNECTING: number;
                OPEN: number;
                CLOSING: number;
                CLOSED: number;
                readyState: number;
                binaryType: string;
                bufferedAmount: number;
                extensions: string;
                protocol: string;
                host: string;
                port: number;
                listeners: Map<string, any>;
                CAroot?: GeneratedCertificate | undefined;
                corsProxyUrl?: string | undefined;
                clientUpstream: TransformStream<any, any>;
                clientUpstreamWriter: WritableStreamDefaultWriter<any>;
                clientDownstream: TransformStream<any, any>;
                fetchInitiated: boolean;
                bufferedBytesFromClient: Uint8Array;
                url: string;
                options: string[];
                on(eventName: string, callback: (e: any) => void): void;
                once(eventName: string, callback: (e: any) => void): void;
                addEventListener(eventName: string, callback: (e: any) => void): void;
                removeListener(eventName: string, callback: (e: any) => void): void;
                removeEventListener(eventName: string, callback: (e: any) => void): void;
                emit(eventName: string, data?: any): void;
                onclose(data: any): void;
                onerror(data: any): void;
                onmessage(data: any): void;
                onopen(data: any): void;
                /**
                 * Emscripten calls this method whenever the WASM module
                 * writes bytes to the TCP socket.
                 */
                send(data: ArrayBuffer): void;
                fetchOverTLS(): Promise<void>;
                fetchOverHTTP(): Promise<void>;
                close(): void;
            };
        };
    };
    onAbort?: ((message: string) => void) | undefined;
    debug?: boolean | undefined;
    ENV?: Record<string, string> | undefined;
    locateFile?: ((path: string) => string) | undefined;
    noInitialRun?: boolean | undefined;
    print?: ((message: string) => void) | undefined;
    printErr?: ((message: string) => void) | undefined;
    quit?: ((status: number, toThrow: any) => void) | undefined;
    onRuntimeInitialized?: ((phpRuntime: any) => void) | undefined;
    monitorRunDependencies?: ((left: number) => void) | undefined;
    onMessage?: ((listener: import("packages/php-wasm/universal/src/lib/load-php-runtime").EmscriptenMessageListener) => void) | undefined;
    outboundNetworkProxyServer?: import("http").Server<typeof import("http").IncomingMessage, typeof import("http").ServerResponse> | undefined;
    instantiateWasm?: ((info: WebAssembly.Imports, receiveInstance: (instance: WebAssembly.Instance, module: WebAssembly.Module) => void) => void) | undefined;
};
export interface TCPOverFetchWebsocketOptions {
    CAroot?: GeneratedCertificate;
    /**
     * If true, the WebSocket will emit 'message' events with the received bytes
     * and the 'close' event when the WebSocket is closed.
     *
     * If false, the consumer will be responsible for reading the bytes from the
     * clientDownstream stream and tracking the closure of that stream.
     */
    outputType?: 'messages' | 'stream';
    corsProxyUrl?: string;
}
export declare class TCPOverFetchWebsocket {
    CONNECTING: number;
    OPEN: number;
    CLOSING: number;
    CLOSED: number;
    readyState: number;
    binaryType: string;
    bufferedAmount: number;
    extensions: string;
    protocol: string;
    host: string;
    port: number;
    listeners: Map<string, any>;
    CAroot?: GeneratedCertificate;
    corsProxyUrl?: string;
    clientUpstream: TransformStream<any, any>;
    clientUpstreamWriter: WritableStreamDefaultWriter<any>;
    clientDownstream: TransformStream<any, any>;
    fetchInitiated: boolean;
    bufferedBytesFromClient: Uint8Array;
    url: string;
    options: string[];
    constructor(url: string, options: string[], { CAroot, corsProxyUrl, outputType, }?: TCPOverFetchWebsocketOptions);
    on(eventName: string, callback: (e: any) => void): void;
    once(eventName: string, callback: (e: any) => void): void;
    addEventListener(eventName: string, callback: (e: any) => void): void;
    removeListener(eventName: string, callback: (e: any) => void): void;
    removeEventListener(eventName: string, callback: (e: any) => void): void;
    emit(eventName: string, data?: any): void;
    onclose(data: any): void;
    onerror(data: any): void;
    onmessage(data: any): void;
    onopen(data: any): void;
    /**
     * Emscripten calls this method whenever the WASM module
     * writes bytes to the TCP socket.
     */
    send(data: ArrayBuffer): void;
    fetchOverTLS(): Promise<void>;
    fetchOverHTTP(): Promise<void>;
    close(): void;
}
export declare class RawBytesFetch {
    /**
     * Streams a HTTP response including the status line and headers.
     */
    static fetchRawResponseBytes(request: Request, corsProxyUrl?: string): ReadableStream<any>;
    private static headersAsBytes;
    /**
     * Parses a raw, streamed HTTP request into a Request object
     * with known headers and a readable body stream.
     */
    static parseHttpRequest(requestBytesStream: ReadableStream<Uint8Array>, host: string, protocol: 'http' | 'https'): Promise<Request>;
    private static parseRequestHeaders;
}
