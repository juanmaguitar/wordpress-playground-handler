/**
 * TLS 1.2 Record layer types defined after the structs
 * from the TLS 1.2 RFC.
 * https://datatracker.ietf.org/doc/html/rfc5246#section-6.2
 */
import type { ParsedExtension } from '../extensions/parse-extensions';
export declare const CompressionMethod: {
    readonly Null: 0;
    readonly Deflate: 1;
};
export type CompressionMethod = (typeof CompressionMethod)[keyof typeof CompressionMethod];
/**
 * TLS 1.2 Record layer types defined after the structs
 * from the TLS 1.2 RFC.
 * https://datatracker.ietf.org/doc/html/rfc5246#section-6.2.1
 */
export interface TLSRecord {
    type: ContentType;
    version: ProtocolVersion;
    length: number;
    fragment: Uint8Array;
}
export interface ProtocolVersion {
    major: number;
    minor: number;
}
export interface GenericStreamCipher {
    content: Uint8Array;
    MAC: Uint8Array;
}
export interface GenericBlockCipher {
    IV: Uint8Array;
    block_ciphered: BlockCiphered;
}
export interface BlockCiphered {
    content: Uint8Array;
    MAC: Uint8Array;
    padding: Uint8Array;
    padding_length: number;
}
export interface GenericAEADCipher {
    nonce_explicit: Uint8Array;
    aead_encrypted: Uint8Array;
}
/**
 * TLS 1.2 Handshake types defined after the structs
 * from the TLS 1.2 RFC.
 * https://datatracker.ietf.org/doc/html/rfc5246#section-7.4
 */
export type TLSMessage = AlertMessage | HandshakeMessage<any> | ChangeCipherSpecMessage | ApplicationDataMessage;
export interface AlertMessage {
    type: typeof ContentTypes.Alert;
    level: AlertLevel;
    description: AlertDescription;
}
export declare const AlertLevels: {
    readonly Warning: 1;
    readonly Fatal: 2;
};
export type AlertLevel = (typeof AlertLevels)[keyof typeof AlertLevels];
export declare const AlertLevelNames: any;
export declare const AlertDescriptions: {
    readonly CloseNotify: 0;
    readonly UnexpectedMessage: 10;
    readonly BadRecordMac: 20;
    readonly DecryptionFailed: 21;
    readonly RecordOverflow: 22;
    readonly DecompressionFailure: 30;
    readonly HandshakeFailure: 40;
    readonly NoCertificate: 41;
    readonly BadCertificate: 42;
    readonly UnsupportedCertificate: 43;
    readonly CertificateRevoked: 44;
    readonly CertificateExpired: 45;
    readonly CertificateUnknown: 46;
    readonly IllegalParameter: 47;
    readonly UnknownCa: 48;
    readonly AccessDenied: 49;
    readonly DecodeError: 50;
    readonly DecryptError: 51;
    readonly ExportRestriction: 60;
    readonly ProtocolVersion: 70;
    readonly InsufficientSecurity: 71;
    readonly InternalError: 80;
    readonly UserCanceled: 90;
    readonly NoRenegotiation: 100;
    readonly UnsupportedExtension: 110;
};
export type AlertDescription = (typeof AlertDescriptions)[keyof typeof AlertDescriptions];
export declare const AlertDescriptionNames: any;
export interface ChangeCipherSpecMessage {
    type: typeof ContentTypes.ChangeCipherSpec;
    body: Uint8Array;
}
export interface ApplicationDataMessage {
    type: typeof ContentTypes.ApplicationData;
    body: Uint8Array;
}
export declare const ContentTypes: {
    readonly ChangeCipherSpec: 20;
    readonly Alert: 21;
    readonly Handshake: 22;
    readonly ApplicationData: 23;
};
export type ContentType = (typeof ContentTypes)[keyof typeof ContentTypes];
export declare const HandshakeType: {
    readonly HelloRequest: 0;
    readonly ClientHello: 1;
    readonly ServerHello: 2;
    readonly Certificate: 11;
    readonly ServerKeyExchange: 12;
    readonly CertificateRequest: 13;
    readonly ServerHelloDone: 14;
    readonly CertificateVerify: 15;
    readonly ClientKeyExchange: 16;
    readonly Finished: 20;
};
export type HandshakeType = (typeof HandshakeType)[keyof typeof HandshakeType];
export type HandshakeMessageBody = HelloRequest | ClientHello | ServerHello | Certificate | ServerKeyExchange | CertificateRequest | ServerHelloDone | CertificateVerify | ClientKeyExchange | Finished;
export interface HandshakeMessage<Body extends HandshakeMessageBody> {
    type: typeof ContentTypes.Handshake;
    msg_type: HandshakeType;
    length: number;
    body: Body;
}
export interface HelloRequest {
}
/**
 * 1 byte
 */
export type SessionId = Uint8Array;
export interface ClientHello {
    client_version: Uint8Array;
    random: Uint8Array;
    session_id: SessionId;
    cipher_suites: string[];
    compression_methods: Uint8Array;
    extensions: ParsedExtension[];
}
export interface ServerHello {
    server_version: Uint8Array;
    random: Uint8Array;
    session_id: Uint8Array;
    cipher_suite: Uint8Array;
    compression_method: number;
    extensions?: Uint8Array;
}
export interface Certificate {
    certificate_list: Uint8Array[];
}
export interface ServerKeyExchange {
    params: Uint8Array;
    signed_params: Uint8Array;
}
/**
 * ECCurveType from
 * https://datatracker.ietf.org/doc/html/rfc4492#section-5.4
 */
export declare const ECCurveTypes: {
    /**
     * Indicates the elliptic curve domain parameters are
     * conveyed verbosely, and the underlying finite field is a prime
     * field.
     */
    ExplicitPrime: number;
    /**
     * Indicates the elliptic curve domain parameters are
     * conveyed verbosely, and the underlying finite field is a
     * characteristic-2 field.
     */
    ExplicitChar2: number;
    /**
     * Indicates that a named curve is used.  This option
     * SHOULD be used when applicable.
     */
    NamedCurve: number;
};
/**
 * Named elliptic curves from
 * https://datatracker.ietf.org/doc/html/rfc4492#section-5.1.1
 */
export declare const ECNamedCurves: {
    sect163k1: number;
    sect163r1: number;
    sect163r2: number;
    sect193r1: number;
    sect193r2: number;
    sect233k1: number;
    sect233r1: number;
    sect239k1: number;
    sect283k1: number;
    sect283r1: number;
    sect409k1: number;
    sect409r1: number;
    secp256k1: number;
    secp256r1: number;
    secp384r1: number;
    secp521r1: number;
    arbitrary_explicit_prime_curves: number;
    arbitrary_explicit_char2_curves: number;
};
export interface CertificateRequest {
    certificate_types: Uint8Array;
    supported_signature_algorithms: Uint8Array;
    certificate_authorities: Uint8Array;
}
export interface ServerHelloDone {
}
export interface CertificateVerify {
    algorithm: Uint8Array;
    signature: Uint8Array;
}
export interface ClientKeyExchange {
    exchange_keys: Uint8Array;
}
export interface Finished {
    verify_data: Uint8Array;
}
export type SessionKeys = {
    masterSecret: Uint8Array;
    clientWriteKey: CryptoKey;
    serverWriteKey: CryptoKey;
    clientIV: Uint8Array;
    serverIV: Uint8Array;
};
