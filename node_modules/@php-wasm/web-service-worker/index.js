import { isURLScoped as h, setURLScope as p, getURLScope as d } from "@php-wasm/scopes";
const f = 25e3;
let y = 0;
function w(e, t, ...r) {
  const s = u();
  return e.postMessage(
    {
      ...t,
      requestId: s
    },
    ...r
  ), s;
}
function u() {
  return ++y;
}
function m(e, t, r = f) {
  return new Promise((s, c) => {
    const o = (a) => {
      a.data.type === "response" && a.data.requestId === t && (e.removeEventListener("message", o), clearTimeout(n), s(a.data.response));
    }, n = setTimeout(() => {
      c(new Error("Request timed out")), e.removeEventListener("message", o);
    }, r);
    e.addEventListener("message", o);
  });
}
function E(e, t) {
  return {
    type: "response",
    requestId: e,
    response: t
  };
}
async function b(e) {
  let t = new URL(e.request.url);
  if (!h(t))
    try {
      const n = new URL(e.request.referrer);
      t = p(t, d(n));
    } catch {
    }
  const r = e.request.headers.get("content-type"), s = e.request.method === "POST" ? new Uint8Array(await e.request.clone().arrayBuffer()) : void 0, c = {};
  for (const n of e.request.headers.entries())
    c[n[0]] = n[1];
  let o;
  try {
    const n = {
      method: "request",
      args: [
        {
          body: s,
          url: t.toString(),
          method: e.request.method,
          headers: {
            ...c,
            Host: t.host,
            // Safari and Firefox don't make the User-Agent header
            // available in the fetch event. Let's add it manually:
            "User-agent": self.navigator.userAgent,
            "Content-type": r
          }
        }
      ]
    }, a = d(t);
    if (a === null)
      throw new Error(
        `The URL ${t.toString()} is not scoped. This should not happen.`
      );
    const l = await R(n, a);
    o = await m(self, l), delete o.headers["x-frame-options"];
  } catch (n) {
    throw console.error(n, { url: t.toString() }), n;
  }
  return o.httpStatusCode >= 300 && o.httpStatusCode <= 399 && o.headers.location ? Response.redirect(
    o.headers.location[0],
    o.httpStatusCode
  ) : new Response(o.bytes, {
    headers: o.headers,
    status: o.httpStatusCode
  });
}
async function R(e, t) {
  const r = u();
  for (const s of await self.clients.matchAll({
    // Sometimes the client that triggered the current fetch()
    // event is considered uncontrolled in Google Chrome. This
    // only happens on the first few fetches() after the initial
    // registration of the service worker.
    includeUncontrolled: !0
  }))
    s.postMessage({
      ...e,
      /**
       * Attach the scope with a URL starting with `/scope:` to this message.
       *
       * We need this mechanics because this worker broadcasts
       * events to all the listeners across all browser tabs. Scopes
       * helps WASM workers ignore requests meant for other WASM workers.
       */
      scope: t,
      requestId: r
    });
  return r;
}
async function i(e, t) {
  const r = ["GET", "HEAD"].includes(e.method) || "body" in t ? void 0 : await e.blob();
  return new Request(t.url || e.url, {
    body: r,
    method: e.method,
    headers: e.headers,
    referrer: e.referrer,
    referrerPolicy: e.referrerPolicy,
    mode: e.mode === "navigate" ? "same-origin" : e.mode,
    credentials: e.credentials,
    cache: e.cache,
    redirect: e.redirect,
    integrity: e.integrity,
    ...t
  });
}
async function S(e) {
  if (!e.body)
    return [e, e];
  const [t, r] = e.body.tee();
  return [
    await i(e, { body: t, duplex: "half" }),
    await i(e, { body: r, duplex: "half" })
  ];
}
function U(e) {
  const t = {};
  return e.headers.forEach((r, s) => {
    t[s] = r;
  }), t;
}
export {
  m as awaitReply,
  R as broadcastMessageExpectReply,
  i as cloneRequest,
  b as convertFetchEventToPHPRequest,
  u as getNextRequestId,
  U as getRequestHeaders,
  w as postMessageExpectReply,
  E as responseTo,
  S as teeRequest
};
