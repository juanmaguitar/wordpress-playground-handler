var P = (i) => {
  throw TypeError(i);
};
var E = (i, e, t) => e.has(i) || P("Cannot " + t);
var o = (i, e, t) => (E(i, e, "read from private field"), t ? t.call(i) : e.get(i)), c = (i, e, t) => e.has(i) ? P("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t), p = (i, e, t, s) => (E(i, e, "write to private field"), s ? s.call(i, t) : e.set(i, t), t), _ = (i, e, t) => (E(i, e, "access private method"), t);
var b = (i, e, t, s) => ({
  set _(r) {
    p(i, e, r, t);
  },
  get _() {
    return o(i, e, s);
  }
});
import "@php-wasm/node-polyfills";
import { logger as T } from "@php-wasm/logger";
const O = 5 * 1024 * 1024;
var h, l, v, I;
class F extends EventTarget {
  constructor() {
    super(...arguments);
    c(this, v);
    c(this, h, {});
    c(this, l, {});
  }
  expectAssets(t) {
    for (const [s, r] of Object.entries(t)) {
      const n = "http://example.com/", a = new URL(s, n).pathname.split("/").pop();
      a in o(this, h) || (o(this, h)[a] = r), a in o(this, l) || (o(this, l)[a] = 0);
    }
  }
  async monitorFetch(t) {
    const s = await t;
    return R(s, (n) => {
      _(this, v, I).call(this, s.url, n.detail.loaded, n.detail.total);
    });
  }
}
h = new WeakMap(), l = new WeakMap(), v = new WeakSet(), /**
 * Notifies about the download #progress of a file.
 *
 * @param  file   The file name.
 * @param  loaded The number of bytes of that file loaded so far.
 * @param  fileSize  The length number of bytes in the loaded file.
 */
I = function(t, s, r) {
  const n = new URL(t, "http://example.com").pathname.split("/").pop();
  r ? n in o(this, h) || (o(this, h)[n] = r, o(this, l)[n] = s) : r = o(this, h)[n], n in o(this, l) || T.warn(
    `Registered a download #progress of an unregistered file "${n}". This may cause a sudden **decrease** in the #progress percentage as the length number of bytes increases during the download.`
  ), o(this, l)[n] = s, this.dispatchEvent(
    new CustomEvent("progress", {
      detail: {
        loaded: w(o(this, l)),
        total: w(o(this, h))
      }
    })
  );
};
function w(i) {
  return Object.values(i).reduce((e, t) => e + t, 0);
}
function R(i, e) {
  const t = i.headers.get("content-length") || "", s = parseInt(t, 10) || O;
  return new Response(
    x(i.body, s, e),
    {
      status: i.status,
      statusText: i.statusText,
      headers: i.headers
    }
  );
}
function x(i, e, t) {
  function s(r, n) {
    t(
      new CustomEvent("progress", {
        detail: {
          loaded: r,
          total: n
        }
      })
    );
  }
  return new ReadableStream({
    async start(r) {
      if (!i) {
        r.close();
        return;
      }
      const n = i.getReader();
      let d = 0;
      for (; ; )
        try {
          const { done: a, value: m } = await n.read();
          if (m && (d += m.byteLength), a) {
            s(d, d), r.close();
            break;
          } else
            s(d, e), r.enqueue(m);
        } catch (a) {
          T.error({ e: a }), r.error(a);
          break;
        }
    }
  });
}
var g, f, u, L;
class S extends EventTarget {
  constructor() {
    super(...arguments);
    c(this, u);
    c(this, g);
    c(this, f);
    p(this, g, {}), p(this, f, 0), this.progress = 0, this.mode = "REAL_TIME", this.caption = "";
  }
  partialObserver(t, s = "") {
    const r = ++b(this, f)._;
    return o(this, g)[r] = 0, (n) => {
      const { loaded: d, total: a } = (n == null ? void 0 : n.detail) || {};
      o(this, g)[r] = d / a * t, _(this, u, L).call(this, this.totalProgress, "REAL_TIME", s);
    };
  }
  slowlyIncrementBy(t) {
    const s = ++b(this, f)._;
    o(this, g)[s] = t, _(this, u, L).call(this, this.totalProgress, "SLOWLY_INCREMENT");
  }
  get totalProgress() {
    return Object.values(o(this, g)).reduce(
      (t, s) => t + s,
      0
    );
  }
}
g = new WeakMap(), f = new WeakMap(), u = new WeakSet(), L = function(t, s, r) {
  this.dispatchEvent(
    new CustomEvent("progress", {
      detail: {
        progress: t,
        mode: s,
        caption: r
      }
    })
  );
};
const y = 1e-5;
class C extends EventTarget {
  constructor({
    weight: e = 1,
    caption: t = "",
    fillTime: s = 4
  } = {}) {
    super(), this._selfWeight = 1, this._selfDone = !1, this._selfProgress = 0, this._selfCaption = "", this._isFilling = !1, this._subTrackers = [], this._weight = e, this._selfCaption = t, this._fillTime = s;
  }
  /**
   * Creates a new sub-tracker with a specific weight.
   *
   * The weight determines what percentage of the overall progress
   * the sub-tracker represents. For example, if the main tracker is
   * monitoring a process that has two stages, and the first stage
   * is expected to take twice as long as the second stage, you could
   * create the first sub-tracker with a weight of 0.67 and the second
   * sub-tracker with a weight of 0.33.
   *
   * The caption is an optional string that describes the current stage
   * of the operation. If provided, it will be used as the progress caption
   * for the sub-tracker. If not provided, the main tracker will look for
   * the next sub-tracker with a non-empty caption and use that as the progress
   * caption instead.
   *
   * Returns the newly-created sub-tracker.
   *
   * @throws {Error} If the weight of the new stage would cause the total weight of all stages to exceed 1.
   *
   * @param weight The weight of the new stage, as a decimal value between 0 and 1.
   * @param caption The caption for the new stage, which will be used as the progress caption for the sub-tracker.
   *
   * @example
   * ```ts
   * const tracker = new ProgressTracker();
   * const subTracker1 = tracker.stage(0.67, 'Slow stage');
   * const subTracker2 = tracker.stage(0.33, 'Fast stage');
   *
   * subTracker2.set(50);
   * subTracker1.set(75);
   * subTracker2.set(100);
   * subTracker1.set(100);
   * ```
   */
  stage(e, t = "") {
    if (e || (e = this._selfWeight), this._selfWeight - e < -1e-5)
      throw new Error(
        `Cannot add a stage with weight ${e} as the total weight of registered stages would exceed 1.`
      );
    this._selfWeight -= e;
    const s = new C({
      caption: t,
      weight: e,
      fillTime: this._fillTime
    });
    return this._subTrackers.push(s), s.addEventListener("progress", () => this.notifyProgress()), s.addEventListener("done", () => {
      this.done && this.notifyDone();
    }), s;
  }
  /**
   * Fills the progress bar slowly over time, simulating progress.
   *
   * The progress bar is filled in a 100 steps, and each step, the progress
   * is increased by 1. If `stopBeforeFinishing` is true, the progress bar
   * will stop filling when it reaches 99% so that you can call `finish()`
   * explicitly.
   *
   * If the progress bar is filling or already filled, this method does nothing.
   *
   * @example
   * ```ts
   * const progress = new ProgressTracker({ caption: 'Processing...' });
   * progress.fillSlowly();
   * ```
   *
   * @param options Optional options.
   */
  fillSlowly({ stopBeforeFinishing: e = !0 } = {}) {
    if (this._isFilling)
      return;
    this._isFilling = !0;
    const s = this._fillTime / 100;
    this._fillInterval = setInterval(() => {
      this.set(this._selfProgress + 1), e && this._selfProgress >= 99 && clearInterval(this._fillInterval);
    }, s);
  }
  set(e) {
    this._selfProgress = Math.min(e, 100), this.notifyProgress(), this._selfProgress + y >= 100 && this.finish();
  }
  finish() {
    this._fillInterval && clearInterval(this._fillInterval), this._selfDone = !0, this._selfProgress = 100, this._isFilling = !1, this._fillInterval = void 0, this.notifyProgress(), this.notifyDone();
  }
  get caption() {
    for (let e = this._subTrackers.length - 1; e >= 0; e--)
      if (!this._subTrackers[e].done) {
        const t = this._subTrackers[e].caption;
        if (t)
          return t;
      }
    return this._selfCaption;
  }
  setCaption(e) {
    this._selfCaption = e, this.notifyProgress();
  }
  get done() {
    return this.progress + y >= 100;
  }
  get progress() {
    if (this._selfDone)
      return 100;
    const e = this._subTrackers.reduce(
      (t, s) => t + s.progress * s.weight,
      this._selfProgress * this._selfWeight
    );
    return Math.round(e * 1e4) / 1e4;
  }
  get weight() {
    return this._weight;
  }
  get observer() {
    return this._progressObserver || (this._progressObserver = (e) => {
      this.set(e);
    }), this._progressObserver;
  }
  get loadingListener() {
    return this._loadingListener || (this._loadingListener = (e) => {
      this.set(e.detail.loaded / e.detail.total * 100);
    }), this._loadingListener;
  }
  pipe(e) {
    e.setProgress({
      progress: this.progress,
      caption: this.caption
    }), this.addEventListener("progress", (t) => {
      e.setProgress({
        progress: t.detail.progress,
        caption: t.detail.caption
      });
    }), this.addEventListener("done", () => {
      e.setLoaded();
    });
  }
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  notifyProgress() {
    const e = this;
    this.dispatchEvent(
      new CustomEvent("progress", {
        detail: {
          get progress() {
            return e.progress;
          },
          get caption() {
            return e.caption;
          }
        }
      })
    );
  }
  notifyDone() {
    this.dispatchEvent(new CustomEvent("done"));
  }
}
export {
  F as EmscriptenDownloadMonitor,
  S as ProgressObserver,
  C as ProgressTracker,
  R as cloneResponseMonitorProgress,
  x as cloneStreamMonitorProgress
};
//# sourceMappingURL=index.js.map
