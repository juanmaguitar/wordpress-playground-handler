// src/main/ts/depseek.ts
var fullRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)(require\s?(\.\s?resolve\s?)?\(\s?|import\s?\(?\s?)|\sfrom)\s?$/;
var importRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)import\s?\(?\s?|\sfrom)\s?$/;
var importRequireRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)(require\s?\(\s?|import\s?\(?\s?)|\sfrom)\s?$/;
var requireRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)require\s?\(\s?)\s?$/;
var requireResolveRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)(require\s?(\.\s?resolve\s?)?\(\s?))\s?$/;
var isDep = (proposal, re) => !!proposal && re.test(proposal);
var isSpace = (value) => value === " " || value === "\n" || value === "	";
var normalizeOpts = (opts) => ({
  bufferSize: 1e3,
  comments: false,
  re: importRequireRe,
  offset: 19,
  ...opts
});
var depseek = (stream, opts) => new Promise((resolve, reject) => {
  if (typeof stream === "string" || stream instanceof Buffer) {
    return resolve(depseekSync(stream, opts));
  }
  stream.setEncoding("utf8").on("readable", () => {
    resolve(extract(stream, opts));
  }).on("error", reject);
});
var depseekSync = (input, opts) => extract(readify(input.toString()), opts);
var patchRefs = (contents, patcher) => {
  const deps = depseekSync(contents);
  let pos = 0;
  let _contents = "";
  for (const { index, value } of deps) {
    _contents = _contents + contents.slice(pos, index) + patcher(value);
    pos = index + value.length;
  }
  return _contents + contents.slice(pos);
};
var readify = (input) => {
  const chunks = [null, input];
  return { read: () => chunks.pop() };
};
var extract = (readable, _opts) => {
  const { re, comments, bufferSize, offset } = normalizeOpts(_opts);
  const refs = [];
  const pushRef = (type, value, index) => refs.push({ type, value, index });
  let i = 0;
  let prev = "";
  let chunk;
  let c = null;
  let q = null;
  let token = "";
  let strLiteral = "";
  let commentBlock = "";
  let commentValue = "";
  while (null !== (chunk = readable.read(bufferSize))) {
    const len = chunk.length;
    let j = 0;
    while (j < len) {
      const char = chunk[j];
      if (c === q) {
        if (isSpace(char)) {
          if (!isSpace(prev))
            token += char;
        } else if (char === '"' || char === "'" || char === "`")
          q = char;
        else if (prev === "/" && (char === "/" || char === "*"))
          c = char;
        else
          token += char;
      } else if (c === null) {
        if (q === char && prev !== "\\") {
          if (strLiteral && isDep(token.slice(-offset), re))
            pushRef("dep", strLiteral, i - strLiteral.length);
          strLiteral = "";
          token = "";
          q = null;
        } else
          strLiteral += char;
      } else if (q === null) {
        if (c === "/" && char === "\n" || c === "*" && prev === "*" && char === "/") {
          commentValue = c === "*" ? commentBlock.slice(0, -1) : commentBlock;
          if (commentValue && comments)
            pushRef("comment", commentValue, i - commentValue.length);
          commentBlock = "";
          token = token.slice(0, -1);
          c = null;
        } else if (comments)
          commentBlock += char;
      }
      prev = char;
      i++;
      j++;
    }
  }
  return refs;
};
export {
  depseek,
  depseekSync,
  fullRe,
  importRe,
  importRequireRe,
  patchRefs,
  requireRe,
  requireResolveRe
};
